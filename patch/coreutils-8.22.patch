diff -rupN orig/COPYING new/COPYING
--- orig/COPYING	2013-12-04 06:48:30.000000000 -0800
+++ new/COPYING	2018-01-18 14:44:19.327961537 -0800
@@ -1,3 +1,8 @@
+#####################################################################
+#### NOTE: ADDITIONAL TERMS APPLY PER SECTION 7 OF THIS LICENSE. ####
+####       SEE INDIVIDUAL SOURCE FILES FOR THESE TERMS.          ####
+#####################################################################
+
                     GNU GENERAL PUBLIC LICENSE
                        Version 3, 29 June 2007
 
diff -rupN orig/Makefile.in new/Makefile.in
--- orig/Makefile.in	2013-12-13 07:20:00.000000000 -0800
+++ new/Makefile.in	2018-01-18 14:44:19.335961753 -0800
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.13.4 from Makefile.am.
+# Makefile.in generated by automake 1.14 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994-2013 Free Software Foundation, Inc.
@@ -303,8 +303,8 @@ am__aclocal_m4_deps = $(top_srcdir)/m4/0
 	$(top_srcdir)/m4/modechange.m4 $(top_srcdir)/m4/mountlist.m4 \
 	$(top_srcdir)/m4/mpsort.m4 $(top_srcdir)/m4/msvc-inval.m4 \
 	$(top_srcdir)/m4/msvc-nothrow.m4 $(top_srcdir)/m4/multiarch.m4 \
-	$(top_srcdir)/m4/nanosleep.m4 $(top_srcdir)/m4/netdb_h.m4 \
-	$(top_srcdir)/m4/netinet_in_h.m4 \
+	$(top_srcdir)/m4/mutil.m4 $(top_srcdir)/m4/nanosleep.m4 \
+	$(top_srcdir)/m4/netdb_h.m4 $(top_srcdir)/m4/netinet_in_h.m4 \
 	$(top_srcdir)/m4/nl_langinfo.m4 $(top_srcdir)/m4/nls.m4 \
 	$(top_srcdir)/m4/nocrash.m4 \
 	$(top_srcdir)/m4/non-recursive-gnulib-prefix-hack.m4 \
@@ -690,7 +690,7 @@ src_comm_SOURCES = src/comm.c
 src_comm_OBJECTS = src/comm.$(OBJEXT)
 src_comm_DEPENDENCIES = $(am__DEPENDENCIES_2)
 am__objects_4 = src/copy.$(OBJEXT) src/cp-hash.$(OBJEXT) \
-	src/extent-scan.$(OBJEXT)
+	src/extent-scan.$(OBJEXT) src/mutil.$(OBJEXT)
 am__objects_5 = src/selinux.$(OBJEXT)
 am_src_cp_OBJECTS = src/cp.$(OBJEXT) $(am__objects_4) $(am__objects_5)
 src_cp_OBJECTS = $(am_src_cp_OBJECTS)
@@ -761,7 +761,8 @@ src_getlimits_DEPENDENCIES = $(am__DEPEN
 	$(am__DEPENDENCIES_1)
 am__objects_6 = src/src_ginstall-copy.$(OBJEXT) \
 	src/src_ginstall-cp-hash.$(OBJEXT) \
-	src/src_ginstall-extent-scan.$(OBJEXT)
+	src/src_ginstall-extent-scan.$(OBJEXT) \
+	src/src_ginstall-mutil.$(OBJEXT)
 am__objects_7 = src/src_ginstall-selinux.$(OBJEXT)
 am_src_ginstall_OBJECTS = src/src_ginstall-install.$(OBJEXT) \
 	src/src_ginstall-prog-fprintf.$(OBJEXT) $(am__objects_6) \
@@ -815,8 +816,9 @@ src_ls_DEPENDENCIES = $(am__DEPENDENCIES
 src_make_prime_list_SOURCES = src/make-prime-list.c
 src_make_prime_list_OBJECTS = src/make-prime-list.$(OBJEXT)
 src_make_prime_list_DEPENDENCIES =
-src_md5sum_SOURCES = src/md5sum.c
-src_md5sum_OBJECTS = src/src_md5sum-md5sum.$(OBJEXT)
+am_src_md5sum_OBJECTS = src/src_md5sum-md5sum.$(OBJEXT) \
+	src/src_md5sum-mutil.$(OBJEXT)
+src_md5sum_OBJECTS = $(am_src_md5sum_OBJECTS)
 src_md5sum_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
 am_src_mkdir_OBJECTS = src/mkdir.$(OBJEXT) src/prog-fprintf.$(OBJEXT) \
 	$(am__objects_5)
@@ -906,22 +908,27 @@ src_seq_DEPENDENCIES = $(am__DEPENDENCIE
 src_setuidgid_SOURCES = src/setuidgid.c
 src_setuidgid_OBJECTS = src/setuidgid.$(OBJEXT)
 src_setuidgid_DEPENDENCIES = $(am__DEPENDENCIES_2)
-am_src_sha1sum_OBJECTS = src/src_sha1sum-md5sum.$(OBJEXT)
+am_src_sha1sum_OBJECTS = src/src_sha1sum-md5sum.$(OBJEXT) \
+	src/src_sha1sum-mutil.$(OBJEXT)
 src_sha1sum_OBJECTS = $(am_src_sha1sum_OBJECTS)
 src_sha1sum_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-am_src_sha224sum_OBJECTS = src/src_sha224sum-md5sum.$(OBJEXT)
+am_src_sha224sum_OBJECTS = src/src_sha224sum-md5sum.$(OBJEXT) \
+	src/src_sha224sum-mutil.$(OBJEXT)
 src_sha224sum_OBJECTS = $(am_src_sha224sum_OBJECTS)
 src_sha224sum_DEPENDENCIES = $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_1)
-am_src_sha256sum_OBJECTS = src/src_sha256sum-md5sum.$(OBJEXT)
+am_src_sha256sum_OBJECTS = src/src_sha256sum-md5sum.$(OBJEXT) \
+	src/src_sha256sum-mutil.$(OBJEXT)
 src_sha256sum_OBJECTS = $(am_src_sha256sum_OBJECTS)
 src_sha256sum_DEPENDENCIES = $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_1)
-am_src_sha384sum_OBJECTS = src/src_sha384sum-md5sum.$(OBJEXT)
+am_src_sha384sum_OBJECTS = src/src_sha384sum-md5sum.$(OBJEXT) \
+	src/src_sha384sum-mutil.$(OBJEXT)
 src_sha384sum_OBJECTS = $(am_src_sha384sum_OBJECTS)
 src_sha384sum_DEPENDENCIES = $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_1)
-am_src_sha512sum_OBJECTS = src/src_sha512sum-md5sum.$(OBJEXT)
+am_src_sha512sum_OBJECTS = src/src_sha512sum-md5sum.$(OBJEXT) \
+	src/src_sha512sum-mutil.$(OBJEXT)
 src_sha512sum_OBJECTS = $(am_src_sha512sum_OBJECTS)
 src_sha512sum_DEPENDENCIES = $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_1)
@@ -1081,23 +1088,24 @@ SOURCES = $(lib_libcoreutils_a_SOURCES)
 	src/head.c src/hostid.c src/hostname.c $(src_id_SOURCES) \
 	src/join.c $(src_kill_SOURCES) src/libstdbuf.c src/link.c \
 	$(src_ln_SOURCES) src/logname.c $(src_ls_SOURCES) \
-	src/make-prime-list.c src/md5sum.c $(src_mkdir_SOURCES) \
-	$(src_mkfifo_SOURCES) $(src_mknod_SOURCES) src/mktemp.c \
-	$(src_mv_SOURCES) src/nice.c src/nl.c src/nohup.c src/nproc.c \
-	src/numfmt.c src/od.c src/paste.c src/pathchk.c src/pinky.c \
-	src/pr.c src/printenv.c src/printf.c src/ptx.c src/pwd.c \
-	src/readlink.c $(src_realpath_SOURCES) $(src_rm_SOURCES) \
-	$(src_rmdir_SOURCES) src/runcon.c src/seq.c src/setuidgid.c \
-	$(src_sha1sum_SOURCES) $(src_sha224sum_SOURCES) \
-	$(src_sha256sum_SOURCES) $(src_sha384sum_SOURCES) \
-	$(src_sha512sum_SOURCES) src/shred.c src/shuf.c src/sleep.c \
-	src/sort.c src/split.c $(src_stat_SOURCES) src/stdbuf.c \
-	src/stty.c src/sum.c src/sync.c src/tac.c src/tail.c src/tee.c \
-	src/test.c $(src_timeout_SOURCES) src/touch.c src/tr.c \
-	src/true.c src/truncate.c src/tsort.c src/tty.c \
-	$(src_uname_SOURCES) src/unexpand.c src/uniq.c src/unlink.c \
-	src/uptime.c src/users.c $(src_vdir_SOURCES) src/wc.c \
-	src/who.c src/whoami.c src/yes.c
+	src/make-prime-list.c $(src_md5sum_SOURCES) \
+	$(src_mkdir_SOURCES) $(src_mkfifo_SOURCES) \
+	$(src_mknod_SOURCES) src/mktemp.c $(src_mv_SOURCES) src/nice.c \
+	src/nl.c src/nohup.c src/nproc.c src/numfmt.c src/od.c \
+	src/paste.c src/pathchk.c src/pinky.c src/pr.c src/printenv.c \
+	src/printf.c src/ptx.c src/pwd.c src/readlink.c \
+	$(src_realpath_SOURCES) $(src_rm_SOURCES) $(src_rmdir_SOURCES) \
+	src/runcon.c src/seq.c src/setuidgid.c $(src_sha1sum_SOURCES) \
+	$(src_sha224sum_SOURCES) $(src_sha256sum_SOURCES) \
+	$(src_sha384sum_SOURCES) $(src_sha512sum_SOURCES) src/shred.c \
+	src/shuf.c src/sleep.c src/sort.c src/split.c \
+	$(src_stat_SOURCES) src/stdbuf.c src/stty.c src/sum.c \
+	src/sync.c src/tac.c src/tail.c src/tee.c src/test.c \
+	$(src_timeout_SOURCES) src/touch.c src/tr.c src/true.c \
+	src/truncate.c src/tsort.c src/tty.c $(src_uname_SOURCES) \
+	src/unexpand.c src/uniq.c src/unlink.c src/uptime.c \
+	src/users.c $(src_vdir_SOURCES) src/wc.c src/who.c \
+	src/whoami.c src/yes.c
 DIST_SOURCES = $(am__lib_libcoreutils_a_SOURCES_DIST) \
 	$(EXTRA_lib_libcoreutils_a_SOURCES) $(src___SOURCES) \
 	$(src_arch_SOURCES) src/base64.c src/basename.c src/cat.c \
@@ -1111,23 +1119,24 @@ DIST_SOURCES = $(am__lib_libcoreutils_a_
 	src/head.c src/hostid.c src/hostname.c $(src_id_SOURCES) \
 	src/join.c $(src_kill_SOURCES) src/libstdbuf.c src/link.c \
 	$(src_ln_SOURCES) src/logname.c $(src_ls_SOURCES) \
-	src/make-prime-list.c src/md5sum.c $(src_mkdir_SOURCES) \
-	$(src_mkfifo_SOURCES) $(src_mknod_SOURCES) src/mktemp.c \
-	$(src_mv_SOURCES) src/nice.c src/nl.c src/nohup.c src/nproc.c \
-	src/numfmt.c src/od.c src/paste.c src/pathchk.c src/pinky.c \
-	src/pr.c src/printenv.c src/printf.c src/ptx.c src/pwd.c \
-	src/readlink.c $(src_realpath_SOURCES) $(src_rm_SOURCES) \
-	$(src_rmdir_SOURCES) src/runcon.c src/seq.c src/setuidgid.c \
-	$(src_sha1sum_SOURCES) $(src_sha224sum_SOURCES) \
-	$(src_sha256sum_SOURCES) $(src_sha384sum_SOURCES) \
-	$(src_sha512sum_SOURCES) src/shred.c src/shuf.c src/sleep.c \
-	src/sort.c src/split.c $(src_stat_SOURCES) src/stdbuf.c \
-	src/stty.c src/sum.c src/sync.c src/tac.c src/tail.c src/tee.c \
-	src/test.c $(src_timeout_SOURCES) src/touch.c src/tr.c \
-	src/true.c src/truncate.c src/tsort.c src/tty.c \
-	$(src_uname_SOURCES) src/unexpand.c src/uniq.c src/unlink.c \
-	src/uptime.c src/users.c $(src_vdir_SOURCES) src/wc.c \
-	src/who.c src/whoami.c src/yes.c
+	src/make-prime-list.c $(src_md5sum_SOURCES) \
+	$(src_mkdir_SOURCES) $(src_mkfifo_SOURCES) \
+	$(src_mknod_SOURCES) src/mktemp.c $(src_mv_SOURCES) src/nice.c \
+	src/nl.c src/nohup.c src/nproc.c src/numfmt.c src/od.c \
+	src/paste.c src/pathchk.c src/pinky.c src/pr.c src/printenv.c \
+	src/printf.c src/ptx.c src/pwd.c src/readlink.c \
+	$(src_realpath_SOURCES) $(src_rm_SOURCES) $(src_rmdir_SOURCES) \
+	src/runcon.c src/seq.c src/setuidgid.c $(src_sha1sum_SOURCES) \
+	$(src_sha224sum_SOURCES) $(src_sha256sum_SOURCES) \
+	$(src_sha384sum_SOURCES) $(src_sha512sum_SOURCES) src/shred.c \
+	src/shuf.c src/sleep.c src/sort.c src/split.c \
+	$(src_stat_SOURCES) src/stdbuf.c src/stty.c src/sum.c \
+	src/sync.c src/tac.c src/tail.c src/tee.c src/test.c \
+	$(src_timeout_SOURCES) src/touch.c src/tr.c src/true.c \
+	src/truncate.c src/tsort.c src/tty.c $(src_uname_SOURCES) \
+	src/unexpand.c src/uniq.c src/unlink.c src/uptime.c \
+	src/users.c $(src_vdir_SOURCES) src/wc.c src/who.c \
+	src/whoami.c src/yes.c
 AM_V_DVIPS = $(am__v_DVIPS_@AM_V@)
 am__v_DVIPS_ = $(am__v_DVIPS_@AM_DEFAULT_V@)
 am__v_DVIPS_0 = @echo "  DVIPS   " $@;
@@ -1463,6 +1472,7 @@ am__distuninstallcheck_listfiles = $(dis
   | sed 's|^\./|$(prefix)/|' | grep -v '$(infodir)/dir$$'
 distcleancheck_listfiles = find . -type f -print
 pkglibexecdir = @pkglibexecdir@
+# < PZK
 
 # Use 'ginstall' in the definition of PROGRAMS and in dependencies to avoid
 # confusion with the 'install' target.  The install rule transforms 'ginstall'
@@ -2429,6 +2439,7 @@ NEXT_UNISTD_H = @NEXT_UNISTD_H@
 NEXT_WCHAR_H = @NEXT_WCHAR_H@
 NEXT_WCTYPE_H = @NEXT_WCTYPE_H@
 OBJEXT = @OBJEXT@
+OPENMP_CFLAGS = @OPENMP_CFLAGS@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
@@ -2977,7 +2988,7 @@ gen_progs_lists = $(top_srcdir)/build-au
 ACLOCAL_AMFLAGS = -I m4
 
 # Just prior to distribution, ...
-# transform the automake-generated rule that runs 'rm -f rm > /dev/null 2>&1 || /bin/rm -f rm'.
+# transform the automake-generated rule that runs 'rm -f rm'.
 # On some systems, that command would fail with a diagnostic like
 # "rm: cannot unlink 'rm': Text file busy" when '.' appears so early
 # in the shell's search path that running 'rm' would run the 'rm'
@@ -3245,7 +3256,8 @@ UNUSED_PARAMETER_H = lib/unused-paramete
 WARN_ON_USE_H = lib/warn-on-use.h
 
 # FIXME: once lib/ and gnulib-tests/ are also converted, hoist to Makefile.am
-AM_CFLAGS = $(WERROR_CFLAGS)
+# PZK >
+AM_CFLAGS = $(WERROR_CFLAGS) $(OPENMP_CFLAGS)
 no_install__progs = src/arch src/hostname
 build_if_possible__progs = src/chroot src/df src/hostid \
 	src/libstdbuf.so src/nice src/pinky src/stdbuf src/stty \
@@ -3466,11 +3478,14 @@ selinux_sources = \
   src/selinux.c \
   src/selinux.h
 
+
+# PZK >
 copy_sources = \
   src/copy.c \
   src/cp-hash.c \
   src/extent-scan.c \
-  src/extent-scan.h
+  src/extent-scan.h \
+  src/mutil.c
 
 src_ginstall_SOURCES = src/install.c src/prog-fprintf.c $(copy_sources) \
 		       $(selinux_sources)
@@ -3500,17 +3515,21 @@ src_df_SOURCES = src/df.c src/find-mount
 src_stat_SOURCES = src/stat.c src/find-mount-point.c
 src_uname_SOURCES = src/uname.c src/uname-uname.c
 src_arch_SOURCES = src/uname.c src/uname-arch.c
+
+# PZK >
+src_md5sum_SOURCES = src/md5sum.c src/mutil.c
 src_md5sum_CPPFLAGS = -DHASH_ALGO_MD5=1 $(AM_CPPFLAGS)
-src_sha1sum_SOURCES = src/md5sum.c
+src_sha1sum_SOURCES = src/md5sum.c src/mutil.c
 src_sha1sum_CPPFLAGS = -DHASH_ALGO_SHA1=1 $(AM_CPPFLAGS)
-src_sha224sum_SOURCES = src/md5sum.c
+src_sha224sum_SOURCES = src/md5sum.c src/mutil.c
 src_sha224sum_CPPFLAGS = -DHASH_ALGO_SHA224=1 $(AM_CPPFLAGS)
-src_sha256sum_SOURCES = src/md5sum.c
+src_sha256sum_SOURCES = src/md5sum.c src/mutil.c
 src_sha256sum_CPPFLAGS = -DHASH_ALGO_SHA256=1 $(AM_CPPFLAGS)
-src_sha384sum_SOURCES = src/md5sum.c
+src_sha384sum_SOURCES = src/md5sum.c src/mutil.c
 src_sha384sum_CPPFLAGS = -DHASH_ALGO_SHA384=1 $(AM_CPPFLAGS)
-src_sha512sum_SOURCES = src/md5sum.c
+src_sha512sum_SOURCES = src/md5sum.c src/mutil.c
 src_sha512sum_CPPFLAGS = -DHASH_ALGO_SHA512=1 $(AM_CPPFLAGS)
+# < PZK
 src_ginstall_CPPFLAGS = -DENABLE_MATCHPATHCON=1 $(AM_CPPFLAGS)
 
 # Ensure we don't link against libcoreutils.a as that lib is
@@ -4434,8 +4453,8 @@ $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 $(am__aclocal_m4_deps):
 
 lib/config.h: lib/stamp-h1
-	@if test ! -f $@; then rm -f lib/stamp-h1; else :; fi
-	@if test ! -f $@; then $(MAKE) $(AM_MAKEFLAGS) lib/stamp-h1; else :; fi
+	@test -f $@ || rm -f lib/stamp-h1
+	@test -f $@ || $(MAKE) $(AM_MAKEFLAGS) lib/stamp-h1
 
 lib/stamp-h1: $(top_srcdir)/lib/config.hin $(top_builddir)/config.status
 	@rm -f lib/stamp-h1
@@ -5292,7 +5311,7 @@ uninstall-binPROGRAMS:
 	cd "$(DESTDIR)$(bindir)" && rm -f $$files
 
 clean-binPROGRAMS:
-	-test -z "$(bin_PROGRAMS)" || rm -f $(bin_PROGRAMS) > /dev/null 2>&1 || /bin/rm -f $(bin_PROGRAMS)
+	-test -z "$(bin_PROGRAMS)" || rm -f $(bin_PROGRAMS)
 
 clean-noinstPROGRAMS:
 	-test -z "$(noinst_PROGRAMS)" || rm -f $(noinst_PROGRAMS)
@@ -5412,6 +5431,7 @@ src/cp-hash.$(OBJEXT): src/$(am__dirstam
 	src/$(DEPDIR)/$(am__dirstamp)
 src/extent-scan.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
+src/mutil.$(OBJEXT): src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)
 src/selinux.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
 
@@ -5528,6 +5548,8 @@ src/src_ginstall-cp-hash.$(OBJEXT): src/
 	src/$(DEPDIR)/$(am__dirstamp)
 src/src_ginstall-extent-scan.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
+src/src_ginstall-mutil.$(OBJEXT): src/$(am__dirstamp) \
+	src/$(DEPDIR)/$(am__dirstamp)
 src/src_ginstall-selinux.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
 
@@ -5613,6 +5635,8 @@ src/make-prime-list$(EXEEXT): $(src_make
 	$(AM_V_CCLD)$(LINK) $(src_make_prime_list_OBJECTS) $(src_make_prime_list_LDADD) $(LIBS)
 src/src_md5sum-md5sum.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
+src/src_md5sum-mutil.$(OBJEXT): src/$(am__dirstamp) \
+	src/$(DEPDIR)/$(am__dirstamp)
 
 src/md5sum$(EXEEXT): $(src_md5sum_OBJECTS) $(src_md5sum_DEPENDENCIES) $(EXTRA_src_md5sum_DEPENDENCIES) src/$(am__dirstamp)
 	@rm -f src/md5sum$(EXEEXT)
@@ -5763,30 +5787,40 @@ src/setuidgid$(EXEEXT): $(src_setuidgid_
 	$(AM_V_CCLD)$(LINK) $(src_setuidgid_OBJECTS) $(src_setuidgid_LDADD) $(LIBS)
 src/src_sha1sum-md5sum.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
+src/src_sha1sum-mutil.$(OBJEXT): src/$(am__dirstamp) \
+	src/$(DEPDIR)/$(am__dirstamp)
 
 src/sha1sum$(EXEEXT): $(src_sha1sum_OBJECTS) $(src_sha1sum_DEPENDENCIES) $(EXTRA_src_sha1sum_DEPENDENCIES) src/$(am__dirstamp)
 	@rm -f src/sha1sum$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(src_sha1sum_OBJECTS) $(src_sha1sum_LDADD) $(LIBS)
 src/src_sha224sum-md5sum.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
+src/src_sha224sum-mutil.$(OBJEXT): src/$(am__dirstamp) \
+	src/$(DEPDIR)/$(am__dirstamp)
 
 src/sha224sum$(EXEEXT): $(src_sha224sum_OBJECTS) $(src_sha224sum_DEPENDENCIES) $(EXTRA_src_sha224sum_DEPENDENCIES) src/$(am__dirstamp)
 	@rm -f src/sha224sum$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(src_sha224sum_OBJECTS) $(src_sha224sum_LDADD) $(LIBS)
 src/src_sha256sum-md5sum.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
+src/src_sha256sum-mutil.$(OBJEXT): src/$(am__dirstamp) \
+	src/$(DEPDIR)/$(am__dirstamp)
 
 src/sha256sum$(EXEEXT): $(src_sha256sum_OBJECTS) $(src_sha256sum_DEPENDENCIES) $(EXTRA_src_sha256sum_DEPENDENCIES) src/$(am__dirstamp)
 	@rm -f src/sha256sum$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(src_sha256sum_OBJECTS) $(src_sha256sum_LDADD) $(LIBS)
 src/src_sha384sum-md5sum.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
+src/src_sha384sum-mutil.$(OBJEXT): src/$(am__dirstamp) \
+	src/$(DEPDIR)/$(am__dirstamp)
 
 src/sha384sum$(EXEEXT): $(src_sha384sum_OBJECTS) $(src_sha384sum_DEPENDENCIES) $(EXTRA_src_sha384sum_DEPENDENCIES) src/$(am__dirstamp)
 	@rm -f src/sha384sum$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(src_sha384sum_OBJECTS) $(src_sha384sum_LDADD) $(LIBS)
 src/src_sha512sum-md5sum.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
+src/src_sha512sum-mutil.$(OBJEXT): src/$(am__dirstamp) \
+	src/$(DEPDIR)/$(am__dirstamp)
 
 src/sha512sum$(EXEEXT): $(src_sha512sum_OBJECTS) $(src_sha512sum_DEPENDENCIES) $(EXTRA_src_sha512sum_DEPENDENCIES) src/$(am__dirstamp)
 	@rm -f src/sha512sum$(EXEEXT)
@@ -6429,6 +6463,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/mkfifo.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/mknod.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/mktemp.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/mutil.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/mv.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/nice.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/nl.Po@am__quote@
@@ -6465,15 +6500,22 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_ginstall-cp-hash.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_ginstall-extent-scan.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_ginstall-install.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_ginstall-mutil.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_ginstall-prog-fprintf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_ginstall-selinux.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_libstdbuf_so-libstdbuf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_md5sum-md5sum.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_md5sum-mutil.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_sha1sum-md5sum.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_sha1sum-mutil.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_sha224sum-md5sum.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_sha224sum-mutil.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_sha256sum-md5sum.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_sha256sum-mutil.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_sha384sum-md5sum.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_sha384sum-mutil.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_sha512sum-md5sum.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/src_sha512sum-mutil.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/stat.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/stdbuf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/stty.Po@am__quote@
@@ -6590,6 +6632,20 @@ src/src_ginstall-extent-scan.obj: src/ex
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_ginstall-extent-scan.obj `if test -f 'src/extent-scan.c'; then $(CYGPATH_W) 'src/extent-scan.c'; else $(CYGPATH_W) '$(srcdir)/src/extent-scan.c'; fi`
 
+src/src_ginstall-mutil.o: src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_ginstall-mutil.o -MD -MP -MF src/$(DEPDIR)/src_ginstall-mutil.Tpo -c -o src/src_ginstall-mutil.o `test -f 'src/mutil.c' || echo '$(srcdir)/'`src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_ginstall-mutil.Tpo src/$(DEPDIR)/src_ginstall-mutil.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/mutil.c' object='src/src_ginstall-mutil.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_ginstall-mutil.o `test -f 'src/mutil.c' || echo '$(srcdir)/'`src/mutil.c
+
+src/src_ginstall-mutil.obj: src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_ginstall-mutil.obj -MD -MP -MF src/$(DEPDIR)/src_ginstall-mutil.Tpo -c -o src/src_ginstall-mutil.obj `if test -f 'src/mutil.c'; then $(CYGPATH_W) 'src/mutil.c'; else $(CYGPATH_W) '$(srcdir)/src/mutil.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_ginstall-mutil.Tpo src/$(DEPDIR)/src_ginstall-mutil.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/mutil.c' object='src/src_ginstall-mutil.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_ginstall-mutil.obj `if test -f 'src/mutil.c'; then $(CYGPATH_W) 'src/mutil.c'; else $(CYGPATH_W) '$(srcdir)/src/mutil.c'; fi`
+
 src/src_ginstall-selinux.o: src/selinux.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_ginstall-selinux.o -MD -MP -MF src/$(DEPDIR)/src_ginstall-selinux.Tpo -c -o src/src_ginstall-selinux.o `test -f 'src/selinux.c' || echo '$(srcdir)/'`src/selinux.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_ginstall-selinux.Tpo src/$(DEPDIR)/src_ginstall-selinux.Po
@@ -6632,6 +6688,20 @@ src/src_md5sum-md5sum.obj: src/md5sum.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_md5sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_md5sum-md5sum.obj `if test -f 'src/md5sum.c'; then $(CYGPATH_W) 'src/md5sum.c'; else $(CYGPATH_W) '$(srcdir)/src/md5sum.c'; fi`
 
+src/src_md5sum-mutil.o: src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_md5sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_md5sum-mutil.o -MD -MP -MF src/$(DEPDIR)/src_md5sum-mutil.Tpo -c -o src/src_md5sum-mutil.o `test -f 'src/mutil.c' || echo '$(srcdir)/'`src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_md5sum-mutil.Tpo src/$(DEPDIR)/src_md5sum-mutil.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/mutil.c' object='src/src_md5sum-mutil.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_md5sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_md5sum-mutil.o `test -f 'src/mutil.c' || echo '$(srcdir)/'`src/mutil.c
+
+src/src_md5sum-mutil.obj: src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_md5sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_md5sum-mutil.obj -MD -MP -MF src/$(DEPDIR)/src_md5sum-mutil.Tpo -c -o src/src_md5sum-mutil.obj `if test -f 'src/mutil.c'; then $(CYGPATH_W) 'src/mutil.c'; else $(CYGPATH_W) '$(srcdir)/src/mutil.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_md5sum-mutil.Tpo src/$(DEPDIR)/src_md5sum-mutil.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/mutil.c' object='src/src_md5sum-mutil.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_md5sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_md5sum-mutil.obj `if test -f 'src/mutil.c'; then $(CYGPATH_W) 'src/mutil.c'; else $(CYGPATH_W) '$(srcdir)/src/mutil.c'; fi`
+
 src/src_sha1sum-md5sum.o: src/md5sum.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha1sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_sha1sum-md5sum.o -MD -MP -MF src/$(DEPDIR)/src_sha1sum-md5sum.Tpo -c -o src/src_sha1sum-md5sum.o `test -f 'src/md5sum.c' || echo '$(srcdir)/'`src/md5sum.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_sha1sum-md5sum.Tpo src/$(DEPDIR)/src_sha1sum-md5sum.Po
@@ -6646,6 +6716,20 @@ src/src_sha1sum-md5sum.obj: src/md5sum.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha1sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_sha1sum-md5sum.obj `if test -f 'src/md5sum.c'; then $(CYGPATH_W) 'src/md5sum.c'; else $(CYGPATH_W) '$(srcdir)/src/md5sum.c'; fi`
 
+src/src_sha1sum-mutil.o: src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha1sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_sha1sum-mutil.o -MD -MP -MF src/$(DEPDIR)/src_sha1sum-mutil.Tpo -c -o src/src_sha1sum-mutil.o `test -f 'src/mutil.c' || echo '$(srcdir)/'`src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_sha1sum-mutil.Tpo src/$(DEPDIR)/src_sha1sum-mutil.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/mutil.c' object='src/src_sha1sum-mutil.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha1sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_sha1sum-mutil.o `test -f 'src/mutil.c' || echo '$(srcdir)/'`src/mutil.c
+
+src/src_sha1sum-mutil.obj: src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha1sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_sha1sum-mutil.obj -MD -MP -MF src/$(DEPDIR)/src_sha1sum-mutil.Tpo -c -o src/src_sha1sum-mutil.obj `if test -f 'src/mutil.c'; then $(CYGPATH_W) 'src/mutil.c'; else $(CYGPATH_W) '$(srcdir)/src/mutil.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_sha1sum-mutil.Tpo src/$(DEPDIR)/src_sha1sum-mutil.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/mutil.c' object='src/src_sha1sum-mutil.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha1sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_sha1sum-mutil.obj `if test -f 'src/mutil.c'; then $(CYGPATH_W) 'src/mutil.c'; else $(CYGPATH_W) '$(srcdir)/src/mutil.c'; fi`
+
 src/src_sha224sum-md5sum.o: src/md5sum.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha224sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_sha224sum-md5sum.o -MD -MP -MF src/$(DEPDIR)/src_sha224sum-md5sum.Tpo -c -o src/src_sha224sum-md5sum.o `test -f 'src/md5sum.c' || echo '$(srcdir)/'`src/md5sum.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_sha224sum-md5sum.Tpo src/$(DEPDIR)/src_sha224sum-md5sum.Po
@@ -6660,6 +6744,20 @@ src/src_sha224sum-md5sum.obj: src/md5sum
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha224sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_sha224sum-md5sum.obj `if test -f 'src/md5sum.c'; then $(CYGPATH_W) 'src/md5sum.c'; else $(CYGPATH_W) '$(srcdir)/src/md5sum.c'; fi`
 
+src/src_sha224sum-mutil.o: src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha224sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_sha224sum-mutil.o -MD -MP -MF src/$(DEPDIR)/src_sha224sum-mutil.Tpo -c -o src/src_sha224sum-mutil.o `test -f 'src/mutil.c' || echo '$(srcdir)/'`src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_sha224sum-mutil.Tpo src/$(DEPDIR)/src_sha224sum-mutil.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/mutil.c' object='src/src_sha224sum-mutil.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha224sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_sha224sum-mutil.o `test -f 'src/mutil.c' || echo '$(srcdir)/'`src/mutil.c
+
+src/src_sha224sum-mutil.obj: src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha224sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_sha224sum-mutil.obj -MD -MP -MF src/$(DEPDIR)/src_sha224sum-mutil.Tpo -c -o src/src_sha224sum-mutil.obj `if test -f 'src/mutil.c'; then $(CYGPATH_W) 'src/mutil.c'; else $(CYGPATH_W) '$(srcdir)/src/mutil.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_sha224sum-mutil.Tpo src/$(DEPDIR)/src_sha224sum-mutil.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/mutil.c' object='src/src_sha224sum-mutil.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha224sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_sha224sum-mutil.obj `if test -f 'src/mutil.c'; then $(CYGPATH_W) 'src/mutil.c'; else $(CYGPATH_W) '$(srcdir)/src/mutil.c'; fi`
+
 src/src_sha256sum-md5sum.o: src/md5sum.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha256sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_sha256sum-md5sum.o -MD -MP -MF src/$(DEPDIR)/src_sha256sum-md5sum.Tpo -c -o src/src_sha256sum-md5sum.o `test -f 'src/md5sum.c' || echo '$(srcdir)/'`src/md5sum.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_sha256sum-md5sum.Tpo src/$(DEPDIR)/src_sha256sum-md5sum.Po
@@ -6674,6 +6772,20 @@ src/src_sha256sum-md5sum.obj: src/md5sum
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha256sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_sha256sum-md5sum.obj `if test -f 'src/md5sum.c'; then $(CYGPATH_W) 'src/md5sum.c'; else $(CYGPATH_W) '$(srcdir)/src/md5sum.c'; fi`
 
+src/src_sha256sum-mutil.o: src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha256sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_sha256sum-mutil.o -MD -MP -MF src/$(DEPDIR)/src_sha256sum-mutil.Tpo -c -o src/src_sha256sum-mutil.o `test -f 'src/mutil.c' || echo '$(srcdir)/'`src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_sha256sum-mutil.Tpo src/$(DEPDIR)/src_sha256sum-mutil.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/mutil.c' object='src/src_sha256sum-mutil.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha256sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_sha256sum-mutil.o `test -f 'src/mutil.c' || echo '$(srcdir)/'`src/mutil.c
+
+src/src_sha256sum-mutil.obj: src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha256sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_sha256sum-mutil.obj -MD -MP -MF src/$(DEPDIR)/src_sha256sum-mutil.Tpo -c -o src/src_sha256sum-mutil.obj `if test -f 'src/mutil.c'; then $(CYGPATH_W) 'src/mutil.c'; else $(CYGPATH_W) '$(srcdir)/src/mutil.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_sha256sum-mutil.Tpo src/$(DEPDIR)/src_sha256sum-mutil.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/mutil.c' object='src/src_sha256sum-mutil.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha256sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_sha256sum-mutil.obj `if test -f 'src/mutil.c'; then $(CYGPATH_W) 'src/mutil.c'; else $(CYGPATH_W) '$(srcdir)/src/mutil.c'; fi`
+
 src/src_sha384sum-md5sum.o: src/md5sum.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha384sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_sha384sum-md5sum.o -MD -MP -MF src/$(DEPDIR)/src_sha384sum-md5sum.Tpo -c -o src/src_sha384sum-md5sum.o `test -f 'src/md5sum.c' || echo '$(srcdir)/'`src/md5sum.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_sha384sum-md5sum.Tpo src/$(DEPDIR)/src_sha384sum-md5sum.Po
@@ -6688,6 +6800,20 @@ src/src_sha384sum-md5sum.obj: src/md5sum
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha384sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_sha384sum-md5sum.obj `if test -f 'src/md5sum.c'; then $(CYGPATH_W) 'src/md5sum.c'; else $(CYGPATH_W) '$(srcdir)/src/md5sum.c'; fi`
 
+src/src_sha384sum-mutil.o: src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha384sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_sha384sum-mutil.o -MD -MP -MF src/$(DEPDIR)/src_sha384sum-mutil.Tpo -c -o src/src_sha384sum-mutil.o `test -f 'src/mutil.c' || echo '$(srcdir)/'`src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_sha384sum-mutil.Tpo src/$(DEPDIR)/src_sha384sum-mutil.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/mutil.c' object='src/src_sha384sum-mutil.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha384sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_sha384sum-mutil.o `test -f 'src/mutil.c' || echo '$(srcdir)/'`src/mutil.c
+
+src/src_sha384sum-mutil.obj: src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha384sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_sha384sum-mutil.obj -MD -MP -MF src/$(DEPDIR)/src_sha384sum-mutil.Tpo -c -o src/src_sha384sum-mutil.obj `if test -f 'src/mutil.c'; then $(CYGPATH_W) 'src/mutil.c'; else $(CYGPATH_W) '$(srcdir)/src/mutil.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_sha384sum-mutil.Tpo src/$(DEPDIR)/src_sha384sum-mutil.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/mutil.c' object='src/src_sha384sum-mutil.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha384sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_sha384sum-mutil.obj `if test -f 'src/mutil.c'; then $(CYGPATH_W) 'src/mutil.c'; else $(CYGPATH_W) '$(srcdir)/src/mutil.c'; fi`
+
 src/src_sha512sum-md5sum.o: src/md5sum.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha512sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_sha512sum-md5sum.o -MD -MP -MF src/$(DEPDIR)/src_sha512sum-md5sum.Tpo -c -o src/src_sha512sum-md5sum.o `test -f 'src/md5sum.c' || echo '$(srcdir)/'`src/md5sum.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_sha512sum-md5sum.Tpo src/$(DEPDIR)/src_sha512sum-md5sum.Po
@@ -6702,6 +6828,20 @@ src/src_sha512sum-md5sum.obj: src/md5sum
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha512sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_sha512sum-md5sum.obj `if test -f 'src/md5sum.c'; then $(CYGPATH_W) 'src/md5sum.c'; else $(CYGPATH_W) '$(srcdir)/src/md5sum.c'; fi`
 
+src/src_sha512sum-mutil.o: src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha512sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_sha512sum-mutil.o -MD -MP -MF src/$(DEPDIR)/src_sha512sum-mutil.Tpo -c -o src/src_sha512sum-mutil.o `test -f 'src/mutil.c' || echo '$(srcdir)/'`src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_sha512sum-mutil.Tpo src/$(DEPDIR)/src_sha512sum-mutil.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/mutil.c' object='src/src_sha512sum-mutil.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha512sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_sha512sum-mutil.o `test -f 'src/mutil.c' || echo '$(srcdir)/'`src/mutil.c
+
+src/src_sha512sum-mutil.obj: src/mutil.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha512sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT src/src_sha512sum-mutil.obj -MD -MP -MF src/$(DEPDIR)/src_sha512sum-mutil.Tpo -c -o src/src_sha512sum-mutil.obj `if test -f 'src/mutil.c'; then $(CYGPATH_W) 'src/mutil.c'; else $(CYGPATH_W) '$(srcdir)/src/mutil.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/src_sha512sum-mutil.Tpo src/$(DEPDIR)/src_sha512sum-mutil.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/mutil.c' object='src/src_sha512sum-mutil.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(src_sha512sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/src_sha512sum-mutil.obj `if test -f 'src/mutil.c'; then $(CYGPATH_W) 'src/mutil.c'; else $(CYGPATH_W) '$(srcdir)/src/mutil.c'; fi`
+
 .y.c:
 	$(AM_V_YACC)$(am__skipyacc) $(SHELL) $(YLWRAP) $< y.tab.c $@ y.tab.h `echo $@ | $(am__yacc_c2h)` y.output $*.output -- $(YACCCOMPILE)
 doc/$(am__dirstamp):
@@ -6747,17 +6887,13 @@ doc/coreutils.html: doc/coreutils.texi $
 	$(AM_V_at)if $(MAKEINFOHTML) $(AM_MAKEINFOHTMLFLAGS) $(MAKEINFOFLAGS) -I doc -I $(srcdir)/doc \
 	 -o $(@:.html=.htp) `test -f 'doc/coreutils.texi' || echo '$(srcdir)/'`doc/coreutils.texi; \
 	then \
-	  rm -rf $@; \
-	  if test ! -d $(@:.html=.htp) && test -d $(@:.html=); then \
-	    mv $(@:.html=) $@; else mv $(@:.html=.htp) $@; fi; \
+	  rm -rf $@ && mv $(@:.html=.htp) $@; \
 	else \
-	  if test ! -d $(@:.html=.htp) && test -d $(@:.html=); then \
-	    rm -rf $(@:.html=); else rm -Rf $(@:.html=.htp) $@; fi; \
-	  exit 1; \
+	  rm -rf $(@:.html=.htp); exit 1; \
 	fi
 $(srcdir)/doc/version.texi:  $(srcdir)/doc/stamp-vti
 $(srcdir)/doc/stamp-vti: doc/coreutils.texi $(top_srcdir)/configure
-	test -f doc/$(am__dirstamp) || $(MAKE) $(AM_MAKEFLAGS) doc/$(am__dirstamp)
+	@test -f doc/$(am__dirstamp) || $(MAKE) $(AM_MAKEFLAGS) doc/$(am__dirstamp)
 	@(dir=.; test -f ./doc/coreutils.texi || dir=$(srcdir); \
 	set `$(SHELL) $(top_srcdir)/build-aux/mdate-sh $$dir/doc/coreutils.texi`; \
 	echo "@set UPDATED $$1 $$2 $$3"; \
@@ -7285,10 +7421,16 @@ dist-xz: distdir
 	$(am__post_remove_distdir)
 
 dist-tarZ: distdir
+	@echo WARNING: "Support for shar distribution archives is" \
+	               "deprecated." >&2
+	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
 	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
 	$(am__post_remove_distdir)
 
 dist-shar: distdir
+	@echo WARNING: "Support for distribution archives compressed with" \
+		       "legacy program 'compress' is deprecated." >&2
+	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
 	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
 	$(am__post_remove_distdir)
 
diff -rupN orig/aclocal.m4 new/aclocal.m4
--- orig/aclocal.m4	2013-12-13 06:15:56.000000000 -0800
+++ new/aclocal.m4	2018-01-18 14:44:19.227958842 -0800
@@ -1,4 +1,4 @@
-# generated automatically by aclocal 1.13.4 -*- Autoconf -*-
+# generated automatically by aclocal 1.14 -*- Autoconf -*-
 
 # Copyright (C) 1996-2013 Free Software Foundation, Inc.
 
@@ -32,10 +32,10 @@ To do so, use the procedure documented b
 # generated from the m4 files accompanying Automake X.Y.
 # (This private macro should not be called outside this file.)
 AC_DEFUN([AM_AUTOMAKE_VERSION],
-[am__api_version='1.13'
+[am__api_version='1.14'
 dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
 dnl require some minimum version.  Point them to the right macro.
-m4_if([$1], [1.13.4], [],
+m4_if([$1], [1.14], [],
       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
 ])
 
@@ -51,7 +51,7 @@ m4_define([_AM_AUTOCONF_VERSION], [])
 # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
 # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-[AM_AUTOMAKE_VERSION([1.13.4])dnl
+[AM_AUTOMAKE_VERSION([1.14])dnl
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
 _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
@@ -418,6 +418,12 @@ AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS]
 # This macro actually does too much.  Some checks are only needed if
 # your package does certain things.  But this isn't really a big deal.
 
+dnl Redefine AC_PROG_CC to automatically invoke _AM_PROG_CC_C_O.
+m4_define([AC_PROG_CC],
+m4_defn([AC_PROG_CC])
+[_AM_PROG_CC_C_O
+])
+
 # AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
 # AM_INIT_AUTOMAKE([OPTIONS])
 # -----------------------------------------------
@@ -526,7 +532,48 @@ dnl macro is hooked onto _AC_COMPILER_EX
 AC_CONFIG_COMMANDS_PRE(dnl
 [m4_provide_if([_AM_COMPILER_EXEEXT],
   [AM_CONDITIONAL([am__EXEEXT], [test -n "$EXEEXT"])])])dnl
-])
+
+# POSIX will say in a future version that running "rm -f" with no argument
+# is OK; and we want to be able to make that assumption in our Makefile
+# recipes.  So use an aggressive probe to check that the usage we want is
+# actually supported "in the wild" to an acceptable degree.
+# See automake bug#10828.
+# To make any issue more visible, cause the running configure to be aborted
+# by default if the 'rm' program in use doesn't match our expectations; the
+# user can still override this though.
+if rm -f && rm -fr && rm -rf; then : OK; else
+  cat >&2 <<'END'
+Oops!
+
+Your 'rm' program seems unable to run without file operands specified
+on the command line, even when the '-f' option is present.  This is contrary
+to the behaviour of most rm programs out there, and not conforming with
+the upcoming POSIX standard: <http://austingroupbugs.net/view.php?id=542>
+
+Please tell bug-automake@gnu.org about your system, including the value
+of your $PATH and any error possibly output before this message.  This
+can help us improve future automake versions.
+
+END
+  if test x"$ACCEPT_INFERIOR_RM_PROGRAM" = x"yes"; then
+    echo 'Configuration will proceed anyway, since you have set the' >&2
+    echo 'ACCEPT_INFERIOR_RM_PROGRAM variable to "yes"' >&2
+    echo >&2
+  else
+    cat >&2 <<'END'
+Aborting the configuration process, to ensure you take notice of the issue.
+
+You can download and install GNU coreutils to get an 'rm' implementation
+that behaves properly: <http://www.gnu.org/software/coreutils/>.
+
+If you want to complete the configuration process using your problematic
+'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM
+to "yes", and re-run configure.
+
+END
+    AC_MSG_ERROR([Your 'rm' program is bad, sorry.])
+  fi
+fi])
 
 dnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
 dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further
@@ -534,7 +581,6 @@ dnl mangled by Autoconf and run in a she
 m4_define([_AC_COMPILER_EXEEXT],
 m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])
 
-
 # When config.status generates a header, we must update the stamp-h file.
 # This file resides in the same directory as the config header
 # that is generated.  The stamp files are numbered to have different names.
@@ -646,38 +692,6 @@ AC_MSG_RESULT([$_am_result])
 rm -f confinc confmf
 ])
 
-# Copyright (C) 1999-2013 Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# AM_PROG_CC_C_O
-# --------------
-# Like AC_PROG_CC_C_O, but changed for automake.
-AC_DEFUN([AM_PROG_CC_C_O],
-[AC_REQUIRE([AC_PROG_CC_C_O])dnl
-AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
-AC_REQUIRE_AUX_FILE([compile])dnl
-# FIXME: we rely on the cache variable name because
-# there is no other way.
-set dummy $CC
-am_cc=`echo $[2] | sed ['s/[^a-zA-Z0-9_]/_/g;s/^[0-9]/_/']`
-eval am_t=\$ac_cv_prog_cc_${am_cc}_c_o
-if test "$am_t" != yes; then
-   # Losing compiler, so override with the script.
-   # FIXME: It is wrong to rewrite CC.
-   # But if we don't then we get into trouble of one sort or another.
-   # A longer-term fix would be to have automake use am__CC in this case,
-   # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
-   CC="$am_aux_dir/compile $CC"
-fi
-dnl Make sure AC_PROG_CC is never called again, or it will override our
-dnl setting of CC.
-m4_define([AC_PROG_CC],
-          [m4_fatal([AC_PROG_CC cannot be called after AM_PROG_CC_C_O])])
-])
-
 # Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
 
 # Copyright (C) 1997-2013 Free Software Foundation, Inc.
@@ -748,6 +762,70 @@ AC_DEFUN([_AM_SET_OPTIONS],
 AC_DEFUN([_AM_IF_OPTION],
 [m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
 
+# Copyright (C) 1999-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# _AM_PROG_CC_C_O
+# ---------------
+# Like AC_PROG_CC_C_O, but changed for automake.  We rewrite AC_PROG_CC
+# to automatically call this.
+AC_DEFUN([_AM_PROG_CC_C_O],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+AC_REQUIRE_AUX_FILE([compile])dnl
+AC_LANG_PUSH([C])dnl
+AC_CACHE_CHECK(
+  [whether $CC understands -c and -o together],
+  [am_cv_prog_cc_c_o],
+  [AC_LANG_CONFTEST([AC_LANG_PROGRAM([])])
+  # Make sure it works both with $CC and with simple cc.
+  # Following AC_PROG_CC_C_O, we do the test twice because some
+  # compilers refuse to overwrite an existing .o file with -o,
+  # though they will create one.
+  am_cv_prog_cc_c_o=yes
+  for am_i in 1 2; do
+    if AM_RUN_LOG([$CC -c conftest.$ac_ext -o conftest2.$ac_objext]) \
+         && test -f conftest2.$ac_objext; then
+      : OK
+    else
+      am_cv_prog_cc_c_o=no
+      break
+    fi
+  done
+  rm -f core conftest*
+  unset am_i])
+if test "$am_cv_prog_cc_c_o" != yes; then
+   # Losing compiler, so override with the script.
+   # FIXME: It is wrong to rewrite CC.
+   # But if we don't then we get into trouble of one sort or another.
+   # A longer-term fix would be to have automake use am__CC in this case,
+   # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
+   CC="$am_aux_dir/compile $CC"
+fi
+AC_LANG_POP([C])])
+
+# For backward compatibility.
+AC_DEFUN_ONCE([AM_PROG_CC_C_O], [AC_REQUIRE([AC_PROG_CC])])
+
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_RUN_LOG(COMMAND)
+# -------------------
+# Run COMMAND, save the exit status in ac_status, and log it.
+# (This has been adapted from Autoconf's _AC_RUN_LOG macro.)
+AC_DEFUN([AM_RUN_LOG],
+[{ echo "$as_me:$LINENO: $1" >&AS_MESSAGE_LOG_FD
+   ($1) >&AS_MESSAGE_LOG_FD 2>&AS_MESSAGE_LOG_FD
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&AS_MESSAGE_LOG_FD
+   (exit $ac_status); }])
+
 # Check to make sure that the build environment is sane.    -*- Autoconf -*-
 
 # Copyright (C) 1996-2013 Free Software Foundation, Inc.
@@ -1285,6 +1363,7 @@ m4_include([m4/mpsort.m4])
 m4_include([m4/msvc-inval.m4])
 m4_include([m4/msvc-nothrow.m4])
 m4_include([m4/multiarch.m4])
+m4_include([m4/mutil.m4])
 m4_include([m4/nanosleep.m4])
 m4_include([m4/netdb_h.m4])
 m4_include([m4/netinet_in_h.m4])
diff -rupN orig/configure new/configure
--- orig/configure	2013-12-13 07:05:30.000000000 -0800
+++ new/configure	2018-01-18 14:44:19.271960028 -0800
@@ -1877,6 +1877,7 @@ GL_GENERATE_ALLOCA_H_FALSE
 GL_GENERATE_ALLOCA_H_TRUE
 ALLOCA_H
 ALLOCA
+OPENMP_CFLAGS
 GL_COND_LIBTOOL_FALSE
 GL_COND_LIBTOOL_TRUE
 host_os
@@ -1983,6 +1984,8 @@ enable_silent_rules
 enable_dependency_tracking
 enable_largefile
 enable_threads
+with_static_gcrypt
+enable_openmp
 enable_assert
 with_openssl
 with_gnu_ld
@@ -2646,6 +2649,7 @@ Optional Features:
   --enable-threads={posix|solaris|pth|windows}
                           specify multithreading API
   --disable-threads       build without multithread safety
+  --disable-openmp        do not use OpenMP
   --disable-assert        turn off assertions
   --disable-rpath         do not hardcode runtime library paths
   --disable-acl           do not support ACLs
@@ -2665,6 +2669,8 @@ Optional Features:
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-static-gcrypt    statically compile in gcrypt and dependencies (and
+                          gnutls if available)
   --with-openssl          use libcrypto hash routines. Valid ARGs are: 'yes',
                           'no', 'auto' => use if available, 'optional' => use
                           if available and warn if not available; default is
@@ -4045,7 +4051,7 @@ ac_configure="$SHELL $ac_aux_dir/configu
 ac_config_headers="$ac_config_headers lib/config.h:lib/config.hin"
 
 
-am__api_version='1.13'
+am__api_version='1.14'
 
 # Find a good install program.  We prefer a C program (faster),
 # so one script is as good as another.  But avoid the broken or
@@ -4582,6 +4588,47 @@ am__tar='$${TAR-tar} chof - "$$tardir"'
 
 
 
+# POSIX will say in a future version that running "rm -f" with no argument
+# is OK; and we want to be able to make that assumption in our Makefile
+# recipes.  So use an aggressive probe to check that the usage we want is
+# actually supported "in the wild" to an acceptable degree.
+# See automake bug#10828.
+# To make any issue more visible, cause the running configure to be aborted
+# by default if the 'rm' program in use doesn't match our expectations; the
+# user can still override this though.
+if rm -f && rm -fr && rm -rf; then : OK; else
+  cat >&2 <<'END'
+Oops!
+
+Your 'rm' program seems unable to run without file operands specified
+on the command line, even when the '-f' option is present.  This is contrary
+to the behaviour of most rm programs out there, and not conforming with
+the upcoming POSIX standard: <http://austingroupbugs.net/view.php?id=542>
+
+Please tell bug-automake@gnu.org about your system, including the value
+of your $PATH and any error possibly output before this message.  This
+can help us improve future automake versions.
+
+END
+  if test x"$ACCEPT_INFERIOR_RM_PROGRAM" = x"yes"; then
+    echo 'Configuration will proceed anyway, since you have set the' >&2
+    echo 'ACCEPT_INFERIOR_RM_PROGRAM variable to "yes"' >&2
+    echo >&2
+  else
+    cat >&2 <<'END'
+Aborting the configuration process, to ensure you take notice of the issue.
+
+You can download and install GNU coreutils to get an 'rm' implementation
+that behaves properly: <http://www.gnu.org/software/coreutils/>.
+
+If you want to complete the configuration process using your problematic
+'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM
+to "yes", and re-run configure.
+
+END
+    as_fn_error $? "Your 'rm' program is bad, sorry." "$LINENO" 5
+  fi
+fi
 # Check whether --enable-silent-rules was given.
 if test "${enable_silent_rules+set}" = set; then :
   enableval=$enable_silent_rules;
@@ -5479,6 +5526,65 @@ ac_compile='$CC -c $CFLAGS $CPPFLAGS con
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC understands -c and -o together" >&5
+$as_echo_n "checking whether $CC understands -c and -o together... " >&6; }
+if ${am_cv_prog_cc_c_o+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+  # Make sure it works both with $CC and with simple cc.
+  # Following AC_PROG_CC_C_O, we do the test twice because some
+  # compilers refuse to overwrite an existing .o file with -o,
+  # though they will create one.
+  am_cv_prog_cc_c_o=yes
+  for am_i in 1 2; do
+    if { echo "$as_me:$LINENO: $CC -c conftest.$ac_ext -o conftest2.$ac_objext" >&5
+   ($CC -c conftest.$ac_ext -o conftest2.$ac_objext) >&5 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); } \
+         && test -f conftest2.$ac_objext; then
+      : OK
+    else
+      am_cv_prog_cc_c_o=no
+      break
+    fi
+  done
+  rm -f core conftest*
+  unset am_i
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_prog_cc_c_o" >&5
+$as_echo "$am_cv_prog_cc_c_o" >&6; }
+if test "$am_cv_prog_cc_c_o" != yes; then
+   # Losing compiler, so override with the script.
+   # FIXME: It is wrong to rewrite CC.
+   # But if we don't then we get into trouble of one sort or another.
+   # A longer-term fix would be to have automake use am__CC in this case,
+   # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
+   CC="$am_aux_dir/compile $CC"
+fi
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
 depcc="$CC"   am_compiler_list=
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
@@ -5899,131 +6005,6 @@ $as_echo "none needed" >&6; } ;; #(
 $as_echo "$ac_cv_prog_cc_stdc" >&6; } ;;
 esac
 
-if test "x$CC" != xcc; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC and cc understand -c and -o together" >&5
-$as_echo_n "checking whether $CC and cc understand -c and -o together... " >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether cc understands -c and -o together" >&5
-$as_echo_n "checking whether cc understands -c and -o together... " >&6; }
-fi
-set dummy $CC; ac_cc=`$as_echo "$2" |
-		      sed 's/[^a-zA-Z0-9_]/_/g;s/^[0-9]/_/'`
-if eval \${ac_cv_prog_cc_${ac_cc}_c_o+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-# Make sure it works both with $CC and with simple cc.
-# We do the test twice because some compilers refuse to overwrite an
-# existing .o file with -o, though they will create one.
-ac_try='$CC -c conftest.$ac_ext -o conftest2.$ac_objext >&5'
-rm -f conftest2.*
-if { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } &&
-   test -f conftest2.$ac_objext && { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; };
-then
-  eval ac_cv_prog_cc_${ac_cc}_c_o=yes
-  if test "x$CC" != xcc; then
-    # Test first that cc exists at all.
-    if { ac_try='cc -c conftest.$ac_ext >&5'
-  { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; }; then
-      ac_try='cc -c conftest.$ac_ext -o conftest2.$ac_objext >&5'
-      rm -f conftest2.*
-      if { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } &&
-	 test -f conftest2.$ac_objext && { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; };
-      then
-	# cc works too.
-	:
-      else
-	# cc exists but doesn't like -o.
-	eval ac_cv_prog_cc_${ac_cc}_c_o=no
-      fi
-    fi
-  fi
-else
-  eval ac_cv_prog_cc_${ac_cc}_c_o=no
-fi
-rm -f core conftest*
-
-fi
-if eval test \$ac_cv_prog_cc_${ac_cc}_c_o = yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-$as_echo "#define NO_MINUS_C_MINUS_O 1" >>confdefs.h
-
-fi
-
-# FIXME: we rely on the cache variable name because
-# there is no other way.
-set dummy $CC
-am_cc=`echo $2 | sed 's/[^a-zA-Z0-9_]/_/g;s/^[0-9]/_/'`
-eval am_t=\$ac_cv_prog_cc_${am_cc}_c_o
-if test "$am_t" != yes; then
-   # Losing compiler, so override with the script.
-   # FIXME: It is wrong to rewrite CC.
-   # But if we don't then we get into trouble of one sort or another.
-   # A longer-term fix would be to have automake use am__CC in this case,
-   # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
-   CC="$am_aux_dir/compile $CC"
-fi
-
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
@@ -8167,6 +8148,689 @@ $as_echo "$as_me: autobuild timestamp...
           LIBC_FATAL_STDERR_=1
   export LIBC_FATAL_STDERR_
 
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pow in -lm" >&5
+$as_echo_n "checking for pow in -lm... " >&6; }
+if ${ac_cv_lib_m_pow+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lm  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char pow ();
+int
+main ()
+{
+return pow ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_m_pow=yes
+else
+  ac_cv_lib_m_pow=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_m_pow" >&5
+$as_echo "$ac_cv_lib_m_pow" >&6; }
+if test "x$ac_cv_lib_m_pow" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBM 1
+_ACEOF
+
+  LIBS="-lm $LIBS"
+
+fi
+
+
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for clock_gettime in -lrt" >&5
+$as_echo_n "checking for clock_gettime in -lrt... " >&6; }
+if ${ac_cv_lib_rt_clock_gettime+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lrt  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char clock_gettime ();
+int
+main ()
+{
+return clock_gettime ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_rt_clock_gettime=yes
+else
+  ac_cv_lib_rt_clock_gettime=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_rt_clock_gettime" >&5
+$as_echo "$ac_cv_lib_rt_clock_gettime" >&6; }
+if test "x$ac_cv_lib_rt_clock_gettime" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBRT 1
+_ACEOF
+
+  LIBS="-lrt $LIBS"
+
+fi
+
+
+
+    for ac_header in gcrypt.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "gcrypt.h" "ac_cv_header_gcrypt_h" "$ac_includes_default"
+if test "x$ac_cv_header_gcrypt_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_GCRYPT_H 1
+_ACEOF
+
+fi
+
+done
+
+
+# Check whether --with-static-gcrypt was given.
+if test "${with_static_gcrypt+set}" = set; then :
+  withval=$with_static_gcrypt; MUTIL_STATIC_GCRYPT=$withval
+else
+  MUTIL_STATIC_GCRYPT=auto
+fi
+
+    if test $MUTIL_STATIC_GCRYPT = yes; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gcry_md_open in -lgcrypt" >&5
+$as_echo_n "checking for gcry_md_open in -lgcrypt... " >&6; }
+if ${ac_cv_lib_gcrypt_gcry_md_open+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgcrypt  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gcry_md_open ();
+int
+main ()
+{
+return gcry_md_open ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_gcrypt_gcry_md_open=yes
+else
+  ac_cv_lib_gcrypt_gcry_md_open=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gcrypt_gcry_md_open" >&5
+$as_echo "$ac_cv_lib_gcrypt_gcry_md_open" >&6; }
+if test "x$ac_cv_lib_gcrypt_gcry_md_open" = xyes; then :
+
+            LIBS="$LIBS -Wl,-Bstatic -lgcrypt -Wl,-Bdynamic"
+
+$as_echo "#define HAVE_LIBGCRYPT 1" >>confdefs.h
+
+
+fi
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gpg_err_init in -lgpg-error" >&5
+$as_echo_n "checking for gpg_err_init in -lgpg-error... " >&6; }
+if ${ac_cv_lib_gpg_error_gpg_err_init+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgpg-error  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gpg_err_init ();
+int
+main ()
+{
+return gpg_err_init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_gpg_error_gpg_err_init=yes
+else
+  ac_cv_lib_gpg_error_gpg_err_init=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gpg_error_gpg_err_init" >&5
+$as_echo "$ac_cv_lib_gpg_error_gpg_err_init" >&6; }
+if test "x$ac_cv_lib_gpg_error_gpg_err_init" = xyes; then :
+
+            LIBS="$LIBS -Wl,-Bstatic -lgpg-error -Wl,-Bdynamic"
+
+$as_echo "#define HAVE_LIBGPG_ERROR 1" >>confdefs.h
+
+
+fi
+
+    else
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gcry_md_open in -lgcrypt" >&5
+$as_echo_n "checking for gcry_md_open in -lgcrypt... " >&6; }
+if ${ac_cv_lib_gcrypt_gcry_md_open+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgcrypt  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gcry_md_open ();
+int
+main ()
+{
+return gcry_md_open ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_gcrypt_gcry_md_open=yes
+else
+  ac_cv_lib_gcrypt_gcry_md_open=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gcrypt_gcry_md_open" >&5
+$as_echo "$ac_cv_lib_gcrypt_gcry_md_open" >&6; }
+if test "x$ac_cv_lib_gcrypt_gcry_md_open" = xyes; then :
+
+            LIBS="$LIBS -lgcrypt"
+
+$as_echo "#define HAVE_LIBGCRYPT 1" >>confdefs.h
+
+
+fi
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gpg_err_init in -lgpg-error" >&5
+$as_echo_n "checking for gpg_err_init in -lgpg-error... " >&6; }
+if ${ac_cv_lib_gpg_error_gpg_err_init+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgpg-error  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gpg_err_init ();
+int
+main ()
+{
+return gpg_err_init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_gpg_error_gpg_err_init=yes
+else
+  ac_cv_lib_gpg_error_gpg_err_init=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gpg_error_gpg_err_init" >&5
+$as_echo "$ac_cv_lib_gpg_error_gpg_err_init" >&6; }
+if test "x$ac_cv_lib_gpg_error_gpg_err_init" = xyes; then :
+
+            LIBS="$LIBS -lgpg-error"
+
+$as_echo "#define HAVE_LIBGPG_ERROR 1" >>confdefs.h
+
+
+fi
+
+    fi
+
+
+
+    for ac_header in gnutls/gnutls.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "gnutls/gnutls.h" "ac_cv_header_gnutls_gnutls_h" "$ac_includes_default"
+if test "x$ac_cv_header_gnutls_gnutls_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_GNUTLS_GNUTLS_H 1
+_ACEOF
+
+fi
+
+done
+
+    if test $MUTIL_STATIC_GCRYPT = yes; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gnutls_srp_verifier in -lgnutls" >&5
+$as_echo_n "checking for gnutls_srp_verifier in -lgnutls... " >&6; }
+if ${ac_cv_lib_gnutls_gnutls_srp_verifier+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgnutls  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gnutls_srp_verifier ();
+int
+main ()
+{
+return gnutls_srp_verifier ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_gnutls_gnutls_srp_verifier=yes
+else
+  ac_cv_lib_gnutls_gnutls_srp_verifier=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gnutls_gnutls_srp_verifier" >&5
+$as_echo "$ac_cv_lib_gnutls_gnutls_srp_verifier" >&6; }
+if test "x$ac_cv_lib_gnutls_gnutls_srp_verifier" = xyes; then :
+
+            LIBS="$LIBS -Wl,-Bstatic -lgnutls -Wl,-Bdynamic"
+
+$as_echo "#define HAVE_LIBGNUTLS 1" >>confdefs.h
+
+
+fi
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for zlibVersion in -lz" >&5
+$as_echo_n "checking for zlibVersion in -lz... " >&6; }
+if ${ac_cv_lib_z_zlibVersion+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lz  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char zlibVersion ();
+int
+main ()
+{
+return zlibVersion ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_z_zlibVersion=yes
+else
+  ac_cv_lib_z_zlibVersion=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_z_zlibVersion" >&5
+$as_echo "$ac_cv_lib_z_zlibVersion" >&6; }
+if test "x$ac_cv_lib_z_zlibVersion" = xyes; then :
+
+            LIBS="$LIBS -Wl,-Bstatic -lz -Wl,-Bdynamic"
+
+$as_echo "#define HAVE_LIBZ 1" >>confdefs.h
+
+
+fi
+
+    else
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gnutls_srp_verifier in -lgnutls" >&5
+$as_echo_n "checking for gnutls_srp_verifier in -lgnutls... " >&6; }
+if ${ac_cv_lib_gnutls_gnutls_srp_verifier+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgnutls  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gnutls_srp_verifier ();
+int
+main ()
+{
+return gnutls_srp_verifier ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_gnutls_gnutls_srp_verifier=yes
+else
+  ac_cv_lib_gnutls_gnutls_srp_verifier=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gnutls_gnutls_srp_verifier" >&5
+$as_echo "$ac_cv_lib_gnutls_gnutls_srp_verifier" >&6; }
+if test "x$ac_cv_lib_gnutls_gnutls_srp_verifier" = xyes; then :
+
+            LIBS="$LIBS -lgnutls"
+
+$as_echo "#define HAVE_LIBGNUTLS 1" >>confdefs.h
+
+
+fi
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for zlibVersion in -lz" >&5
+$as_echo_n "checking for zlibVersion in -lz... " >&6; }
+if ${ac_cv_lib_z_zlibVersion+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lz  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char zlibVersion ();
+int
+main ()
+{
+return zlibVersion ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_z_zlibVersion=yes
+else
+  ac_cv_lib_z_zlibVersion=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_z_zlibVersion" >&5
+$as_echo "$ac_cv_lib_z_zlibVersion" >&6; }
+if test "x$ac_cv_lib_z_zlibVersion" = xyes; then :
+
+            LIBS="$LIBS -lz"
+
+$as_echo "#define HAVE_LIBZ 1" >>confdefs.h
+
+
+fi
+
+    fi
+
+
+    for ac_header in lustre/lustreapi.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "lustre/lustreapi.h" "ac_cv_header_lustre_lustreapi_h" "$ac_includes_default"
+if test "x$ac_cv_header_lustre_lustreapi_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LUSTRE_LUSTREAPI_H 1
+_ACEOF
+
+fi
+
+done
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for llapi_file_get_stripe in -llustreapi" >&5
+$as_echo_n "checking for llapi_file_get_stripe in -llustreapi... " >&6; }
+if ${ac_cv_lib_lustreapi_llapi_file_get_stripe+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-llustreapi  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char llapi_file_get_stripe ();
+int
+main ()
+{
+return llapi_file_get_stripe ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_lustreapi_llapi_file_get_stripe=yes
+else
+  ac_cv_lib_lustreapi_llapi_file_get_stripe=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_lustreapi_llapi_file_get_stripe" >&5
+$as_echo "$ac_cv_lib_lustreapi_llapi_file_get_stripe" >&6; }
+if test "x$ac_cv_lib_lustreapi_llapi_file_get_stripe" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBLUSTREAPI 1
+_ACEOF
+
+  LIBS="-llustreapi $LIBS"
+
+fi
+
+
+
+    for ac_header in mpi.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "mpi.h" "ac_cv_header_mpi_h" "$ac_includes_default"
+if test "x$ac_cv_header_mpi_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_MPI_H 1
+_ACEOF
+
+fi
+
+done
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for MPI_Init in -lmpi" >&5
+$as_echo_n "checking for MPI_Init in -lmpi... " >&6; }
+if ${ac_cv_lib_mpi_MPI_Init+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lmpi  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char MPI_Init ();
+int
+main ()
+{
+return MPI_Init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_mpi_MPI_Init=yes
+else
+  ac_cv_lib_mpi_MPI_Init=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_mpi_MPI_Init" >&5
+$as_echo "$ac_cv_lib_mpi_MPI_Init" >&6; }
+if test "x$ac_cv_lib_mpi_MPI_Init" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBMPI 1
+_ACEOF
+
+  LIBS="-lmpi $LIBS"
+
+fi
+
+
+
+
+  OPENMP_CFLAGS=
+  # Check whether --enable-openmp was given.
+if test "${enable_openmp+set}" = set; then :
+  enableval=$enable_openmp;
+fi
+
+  if test "$enable_openmp" != no; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to support OpenMP" >&5
+$as_echo_n "checking for $CC option to support OpenMP... " >&6; }
+if ${ac_cv_prog_c_openmp+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifndef _OPENMP
+ choke me
+#endif
+#include <omp.h>
+int main () { return omp_get_num_threads (); }
+
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_prog_c_openmp='none needed'
+else
+  ac_cv_prog_c_openmp='unsupported'
+	  	  	  	  	  	  	                                	  	  	  	  	  	  for ac_option in -fopenmp -xopenmp -openmp -mp -omp -qsmp=omp -homp \
+                           -Popenmp --openmp; do
+	    ac_save_CFLAGS=$CFLAGS
+	    CFLAGS="$CFLAGS $ac_option"
+	    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifndef _OPENMP
+ choke me
+#endif
+#include <omp.h>
+int main () { return omp_get_num_threads (); }
+
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_prog_c_openmp=$ac_option
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+	    CFLAGS=$ac_save_CFLAGS
+	    if test "$ac_cv_prog_c_openmp" != unsupported; then
+	      break
+	    fi
+	  done
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_c_openmp" >&5
+$as_echo "$ac_cv_prog_c_openmp" >&6; }
+    case $ac_cv_prog_c_openmp in #(
+      "none needed" | unsupported)
+	;; #(
+      *)
+	OPENMP_CFLAGS=$ac_cv_prog_c_openmp ;;
+    esac
+  fi
+
+
+
 ac_fn_c_check_type "$LINENO" "size_t" "ac_cv_type_size_t" "$ac_includes_default"
 if test "x$ac_cv_type_size_t" = xyes; then :
 
@@ -24695,6 +25359,13 @@ fi
 
 
 
+
+
+
+
+
+
+
   gl_source_base='lib'
 
 
@@ -54319,6 +54990,13 @@ done
 
 
 
+
+
+
+
+
+
+
 
 
 
diff -rupN orig/gnulib-tests/Makefile.in new/gnulib-tests/Makefile.in
--- orig/gnulib-tests/Makefile.in	2013-12-13 06:16:05.000000000 -0800
+++ new/gnulib-tests/Makefile.in	2018-01-18 14:44:20.699998516 -0800
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.13.4 from Makefile.am.
+# Makefile.in generated by automake 1.14 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994-2013 Free Software Foundation, Inc.
@@ -500,8 +500,8 @@ am__aclocal_m4_deps = $(top_srcdir)/m4/0
 	$(top_srcdir)/m4/modechange.m4 $(top_srcdir)/m4/mountlist.m4 \
 	$(top_srcdir)/m4/mpsort.m4 $(top_srcdir)/m4/msvc-inval.m4 \
 	$(top_srcdir)/m4/msvc-nothrow.m4 $(top_srcdir)/m4/multiarch.m4 \
-	$(top_srcdir)/m4/nanosleep.m4 $(top_srcdir)/m4/netdb_h.m4 \
-	$(top_srcdir)/m4/netinet_in_h.m4 \
+	$(top_srcdir)/m4/mutil.m4 $(top_srcdir)/m4/nanosleep.m4 \
+	$(top_srcdir)/m4/netdb_h.m4 $(top_srcdir)/m4/netinet_in_h.m4 \
 	$(top_srcdir)/m4/nl_langinfo.m4 $(top_srcdir)/m4/nls.m4 \
 	$(top_srcdir)/m4/nocrash.m4 \
 	$(top_srcdir)/m4/non-recursive-gnulib-prefix-hack.m4 \
@@ -3347,6 +3347,7 @@ NEXT_UNISTD_H = @NEXT_UNISTD_H@
 NEXT_WCHAR_H = @NEXT_WCHAR_H@
 NEXT_WCTYPE_H = @NEXT_WCTYPE_H@
 OBJEXT = @OBJEXT@
+OPENMP_CFLAGS = @OPENMP_CFLAGS@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
diff -rupN orig/lib/config.hin new/lib/config.hin
--- orig/lib/config.hin	2013-12-13 06:16:02.000000000 -0800
+++ new/lib/config.hin	2018-01-18 14:44:19.183957656 -0800
@@ -1435,6 +1435,9 @@
 /* Define to 1 if you have the `futimesat' function. */
 #undef HAVE_FUTIMESAT
 
+/* Define to 1 if you have the <gcrypt.h> header file. */
+#undef HAVE_GCRYPT_H
+
 /* Define to 1 if you have the `getacl' function. */
 #undef HAVE_GETACL
 
@@ -1513,6 +1516,9 @@
 /* Define to 1 if you have the <gmp.h> header file. */
 #undef HAVE_GMP_H
 
+/* Define to 1 if you have the <gnutls/gnutls.h> header file. */
+#undef HAVE_GNUTLS_GNUTLS_H
+
 /* Define to 1 if you have the <grp.h> header file. */
 #undef HAVE_GRP_H
 
@@ -1627,21 +1633,45 @@
 /* Define to 1 if you have the `dgc' library (-ldgc). */
 #undef HAVE_LIBDGC
 
+/* Define to 1 if you have the 'gcrypt' library ('lgcrypt') */
+#undef HAVE_LIBGCRYPT
+
 /* Define to 1 if you have the <libgen.h> header file. */
 #undef HAVE_LIBGEN_H
 
+/* Define to 1 if you have the 'gnutls' library ('lgnutls') */
+#undef HAVE_LIBGNUTLS
+
+/* Define to 1 if you have the 'gpg-error' library ('lgpg-error') */
+#undef HAVE_LIBGPG_ERROR
+
 /* Define to 1 if you have the <libintl.h> header file. */
 #undef HAVE_LIBINTL_H
 
 /* Define to 1 if you have the `kstat' library (-lkstat). */
 #undef HAVE_LIBKSTAT
 
+/* Define to 1 if you have the `lustreapi' library (-llustreapi). */
+#undef HAVE_LIBLUSTREAPI
+
+/* Define to 1 if you have the `m' library (-lm). */
+#undef HAVE_LIBM
+
+/* Define to 1 if you have the `mpi' library (-lmpi). */
+#undef HAVE_LIBMPI
+
 /* Define to 1 if you have the `os' library (-los). */
 #undef HAVE_LIBOS
 
 /* Define to 1 if you have the `perfstat' library (-lperfstat). */
 #undef HAVE_LIBPERFSTAT
 
+/* Define to 1 if you have the `rt' library (-lrt). */
+#undef HAVE_LIBRT
+
+/* Define to 1 if you have the 'z' library ('lz') */
+#undef HAVE_LIBZ
+
 /* Define to 1 if you have the `link' function. */
 #undef HAVE_LINK
 
@@ -1663,6 +1693,9 @@
 /* Define to 1 if you have the `lstat' function. */
 #undef HAVE_LSTAT
 
+/* Define to 1 if you have the <lustre/lustreapi.h> header file. */
+#undef HAVE_LUSTRE_LUSTREAPI_H
+
 /* Define to 1 if you have the `lutimes' function. */
 #undef HAVE_LUTIMES
 
@@ -1741,6 +1774,9 @@
 /* Define to 1 if you have the `mode_to_security_class' function. */
 #undef HAVE_MODE_TO_SECURITY_CLASS
 
+/* Define to 1 if you have the <mpi.h> header file. */
+#undef HAVE_MPI_H
+
 /* Define to 1 if you have the `mprotect' function. */
 #undef HAVE_MPROTECT
 
@@ -2767,9 +2803,6 @@
    large precisions without arbitrary bounds. */
 #undef NEED_PRINTF_UNBOUNDED_PRECISION
 
-/* Define to 1 if your C compiler doesn't accept -c and -o together. */
-#undef NO_MINUS_C_MINUS_O
-
 /* Define to 1 if the nlist n_name member is a pointer */
 #undef N_NAME_POINTER
 
diff -rupN orig/m4/gnulib-common.m4 new/m4/gnulib-common.m4
--- orig/m4/gnulib-common.m4	2013-12-04 06:53:33.000000000 -0800
+++ new/m4/gnulib-common.m4	2018-01-18 14:44:16.179876693 -0800
@@ -10,6 +10,15 @@ AC_DEFUN([gl_COMMON], [
   dnl Use AC_REQUIRE here, so that the code is expanded once only.
   AC_REQUIRE([gl_00GNULIB])
   AC_REQUIRE([gl_COMMON_BODY])
+dnl PZK >
+  AC_REQUIRE([mutil_LIBM])
+  AC_REQUIRE([mutil_LIBRT])
+  AC_REQUIRE([mutil_LIBGNUTLS])
+  AC_REQUIRE([mutil_LIBGCRYPT])
+  AC_REQUIRE([mutil_LIBLUSTREAPI])
+  AC_REQUIRE([mutil_LIBMPI])
+  AC_REQUIRE([mutil_LIBOMP])
+dnl < PZK
 ])
 AC_DEFUN([gl_COMMON_BODY], [
   AH_VERBATIM([_Noreturn],
diff -rupN orig/m4/mutil.m4 new/m4/mutil.m4
--- orig/m4/mutil.m4	1969-12-31 16:00:00.000000000 -0800
+++ new/m4/mutil.m4	2018-01-18 14:44:17.079900948 -0800
@@ -0,0 +1,101 @@
+dnl PZK >
+# mutil.m4 serial 1
+
+dnl Copyright 2010 United States Government National Aeronautics and
+dnl Space Administration (NASA).  No copyright is claimed in the United
+dnl States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+dnl Written by Paul Kolano.
+
+AC_DEFUN([mutil_LIBM], [
+    AC_CHECK_LIB([m], [pow])
+])
+
+AC_DEFUN([mutil_LIBRT], [
+    AC_CHECK_LIB([rt], [clock_gettime])
+])
+
+AC_DEFUN([mutil_LIBGNUTLS], [
+    AC_REQUIRE([mutil_LIBGCRYPT])
+    AC_CHECK_HEADERS([gnutls/gnutls.h])
+    if test $MUTIL_STATIC_GCRYPT = yes; then
+        AC_CHECK_LIB([gnutls], [gnutls_srp_verifier], [
+            LIBS="$LIBS -Wl,-Bstatic -lgnutls -Wl,-Bdynamic"
+            AC_DEFINE([HAVE_LIBGNUTLS], [1], [
+                Define to 1 if you have the 'gnutls' library ('lgnutls')
+            ])
+        ])
+        AC_CHECK_LIB([z], [zlibVersion], [
+            LIBS="$LIBS -Wl,-Bstatic -lz -Wl,-Bdynamic"
+            AC_DEFINE([HAVE_LIBZ], [1], [
+                Define to 1 if you have the 'z' library ('lz')
+            ])
+        ])
+    else
+        AC_CHECK_LIB([gnutls], [gnutls_srp_verifier], [
+            LIBS="$LIBS -lgnutls"
+            AC_DEFINE([HAVE_LIBGNUTLS], [1], [
+                Define to 1 if you have the 'gnutls' library ('lgnutls')
+            ])
+        ])
+        AC_CHECK_LIB([z], [zlibVersion], [
+            LIBS="$LIBS -lz"
+            AC_DEFINE([HAVE_LIBZ], [1], [
+                Define to 1 if you have the 'z' library ('lz')
+            ])
+        ])
+    fi
+])
+
+AC_DEFUN([mutil_LIBGCRYPT], [
+    AC_CHECK_HEADERS([gcrypt.h])
+    AC_ARG_WITH([static-gcrypt],
+        AS_HELP_STRING([--with-static-gcrypt], [
+            statically compile in gcrypt and dependencies
+            (and gnutls if available)
+        ]), [MUTIL_STATIC_GCRYPT=$withval], [MUTIL_STATIC_GCRYPT=auto])
+    if test $MUTIL_STATIC_GCRYPT = yes; then
+        AC_CHECK_LIB([gcrypt], [gcry_md_open], [
+            LIBS="$LIBS -Wl,-Bstatic -lgcrypt -Wl,-Bdynamic"
+            AC_DEFINE([HAVE_LIBGCRYPT], [1], [
+                Define to 1 if you have the 'gcrypt' library ('lgcrypt')
+            ])
+        ])
+        AC_CHECK_LIB([gpg-error], [gpg_err_init], [
+            LIBS="$LIBS -Wl,-Bstatic -lgpg-error -Wl,-Bdynamic"
+            AC_DEFINE([HAVE_LIBGPG_ERROR], [1], [
+                Define to 1 if you have the 'gpg-error' library ('lgpg-error')
+            ])
+        ])
+    else
+        AC_CHECK_LIB([gcrypt], [gcry_md_open], [
+            LIBS="$LIBS -lgcrypt"
+            AC_DEFINE([HAVE_LIBGCRYPT], [1], [
+                Define to 1 if you have the 'gcrypt' library ('lgcrypt')
+            ])
+        ])
+        AC_CHECK_LIB([gpg-error], [gpg_err_init], [
+            LIBS="$LIBS -lgpg-error"
+            AC_DEFINE([HAVE_LIBGPG_ERROR], [1], [
+                Define to 1 if you have the 'gpg-error' library ('lgpg-error')
+            ])
+        ])
+    fi
+])
+
+AC_DEFUN([mutil_LIBLUSTREAPI], [
+    AC_CHECK_HEADERS([lustre/lustreapi.h])
+    AC_CHECK_LIB([lustreapi], [llapi_file_get_stripe])
+])
+
+AC_DEFUN([mutil_LIBMPI], [
+    AC_CHECK_HEADERS([mpi.h])
+    AC_CHECK_LIB([mpi], [MPI_Init])
+])
+
+AC_DEFUN([mutil_LIBOMP], [
+    AC_OPENMP
+])
+
+dnl < PZK
+
diff -rupN orig/src/copy.c new/src/copy.c
--- orig/src/copy.c	2013-12-04 16:59:36.000000000 -0800
+++ new/src/copy.c	2018-01-18 14:44:17.935924020 -0800
@@ -14,7 +14,69 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
-/* Extracted from cp.c and librarified by Jim Meyering.  */
+// PZK >
+/* Extracted from cp.c and librarified by Jim Meyering.
+   High performance multi-threaded modifications by Paul Kolano. */
+
+/* Additional Terms per Section 7 of GNU General Public License Version 3
+
+1.  DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION
+
+    No Warranty: NASA PROVIDES THE COVERED WORKS "AS IS" WITHOUT ANY
+    WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
+    INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE COVERED WORKS
+    WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
+    INFRINGEMENT, ANY WARRANTY THAT THE COVERED WORKS WILL BE ERROR
+    FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
+    TO THE COVERED WORKS. THIS AGREEMENT DOES NOT, IN ANY MANNER,
+    CONSTITUTE AN ENDORSEMENT BY NASA OR ANY OTHER RECIPIENT OF ANY
+    RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER
+    APPLICATIONS RESULTING FROM USE OF THE COVERED WORKS.  FURTHER, NASA
+    DISCLAIMS ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY
+    SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT
+    "AS IS."
+
+    Waiver and Indemnity: YOU AGREE TO WAIVE ANY AND ALL CLAIMS
+    AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
+    SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT.  IF YOUR USE OF THE
+    COVERED WORKS RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES
+    OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM PRODUCTS
+    BASED ON, OR RESULTING FROM, YOUR USE OF THE COVERED WORKS, YOU
+    SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS
+    CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT, TO
+    THE EXTENT PERMITTED BY LAW.  YOUR SOLE REMEDY FOR ANY SUCH MATTER
+    SHALL BE THE IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
+
+2.  You must ensure that the following copyright notice appears
+    prominently in the covered works:
+
+        Copyright 2010 United States Government National Aeronautics and
+        Space Administration (NASA).  No copyright is claimed in the United
+        States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+3.  You must characterize Your alteration of the covered works as a
+    Modification or Contribution and must identify Yourself as the
+    originator of Your Modification or Contribution in a manner that
+    reasonably allows subsequent Recipients to identify the originator
+    of the Modification or Contribution.  In fulfillment of these
+    requirements, You must include a file (e.g., a change log file) that
+    describes the alterations made and the date of the alterations,
+    identifies You as originator of the alterations, and consents to
+    characterization of the alterations as a Modification or
+    Contribution, for example, by including a statement that the
+    Modification or Contribution is derived, directly or indirectly,
+    from covered work provided by NASA. Once consent is granted, it may
+    not thereafter be revoked.
+
+4.  You may not make any representation in the covered works or in any
+    promotional, advertising or other material that may be construed as
+    an endorsement by NASA or by any other Recipient of any product or
+    service provided by You, or that may seek to obtain commercial
+    advantage of NASA's or any other Recipient's participation in this
+    License.
+*/
+// < PZK
 
 #include <config.h>
 #include <stdio.h>
@@ -70,6 +132,60 @@
 # include "verror.h"
 #endif
 
+// PZK >
+#ifdef __linux__
+# include <linux/falloc.h>
+
+# ifndef SYNC_FILE_RANGE_WRITE
+#  define SYNC_FILE_RANGE_WAIT_BEFORE     1
+#  define SYNC_FILE_RANGE_WRITE           2
+#  define SYNC_FILE_RANGE_WAIT_AFTER      4
+
+#  ifdef __i386__
+#   define NR_sync_file_range 314
+#  endif
+
+#  ifdef __x86_64__
+#   define NR_sync_file_range 277
+#  endif
+
+#  ifdef __ia64__
+#   define NR_sync_file_range 1300
+#  endif
+
+#  include <unistd.h>
+static inline int sync_file_range(
+        int fd, loff_t offset, loff_t nbytes, int flags) {
+    return syscall(NR_sync_file_range, fd, offset, nbytes, flags);
+}
+# endif
+#endif
+
+#if HAVE_LIBLUSTREAPI
+# include <libgen.h>
+# include <lustre/lustreapi.h>
+# include <sys/statfs.h>
+# define MAX_OSTS 1024
+# define LOV_EA_SIZE(lum, num) (sizeof(*lum) + num * sizeof(*lum->lmm_objects))
+# define LOV_EA_MAX(lum) LOV_EA_SIZE(lum, MAX_OSTS)
+//TODO: llapi is still messed up when max above 160 (could be our env
+//      with mix of lustre versions)
+#  define MUTIL_MAX_STRIPE_COUNT 160
+//# endif
+#endif
+
+#include "mutil.h"
+#include <aio.h>
+
+#if HAVE_LIBGCRYPT
+# include <gcrypt.h>
+#endif
+
+#ifndef DEFAULT_LUSTRE_STRIPES
+# define DEFAULT_LUSTRE_STRIPES 1
+#endif
+// < PZK
+
 #ifndef HAVE_FCHOWN
 # define HAVE_FCHOWN false
 # define fchown(fd, uid, gid) (-1)
@@ -149,36 +265,186 @@ utimens_symlink (char const *file, struc
    DEST_FD introduced a hole.  Set *TOTAL_N_READ to the number of
    bytes read.  */
 static bool
-sparse_copy (int src_fd, int dest_fd, char *buf, size_t buf_size,
-             bool make_holes,
-             char const *src_name, char const *dst_name,
-             uintmax_t max_n_read, off_t *total_n_read,
-             bool *last_write_made_hole)
+// PZK >
+sparse_copy (copy_reg_t *crt, struct cp_options *co, char *buf[],
+            size_t buf_size, off_t src_total_size, bool make_holes,
+            off_t start_offset, off_t dst_offset, uintmax_t max_n_read,
+            off_t *total_n_read, bool *last_write_made_hole
+#if HAVE_LIBGCRYPT
+             , gcry_md_hd_t *ctx, hash_tree_t *htt
+#endif
+            )
+// < PZK
 {
   *last_write_made_hole = false;
   *total_n_read = 0;
 
+// PZK >
+  struct timespec rts[2], wts[2];
+  struct aiocb raio, waio;
+  struct aiocb *raiol[1], *waiol[1];
+  raiol[0] = NULL;
+  waiol[0] = NULL;
+  int aio_buf = 0;
+
+  if (co->read_mode) {
+    // turn direct i/o back on in case it was turned off
+    int old_flags = fcntl(crt->src_fd, F_GETFL);
+    if (!(old_flags & O_DIRECT) &&
+        fcntl(crt->src_fd, F_SETFL, old_flags | O_DIRECT) != 0)
+            error(0, errno, _("failed to turn on O_DIRECT: %s"),
+                quote(crt->src_name));
+  }
+  // special handling for non-empty size zero files
+  if (!src_total_size) max_n_read = buf_size;
+// < PZK
+
   while (max_n_read)
     {
       bool make_hole = false;
+// PZK >
+      if (src_total_size && *total_n_read >= crt->stop_offset - start_offset) break;
+
+      ssize_t n_read;
+      if (raiol[0] != NULL) {
+          // this will be skipped during the first double buffer iteration
+          // wait for previous asynchronous read to complete
+          while (aio_suspend((const struct aiocb * const *) raiol, 1, NULL) && errno == EINTR);
+          if (co->print_stats) clock_gettime(0, &rts[1]);
+          if (waiol[0] != NULL) {
+              while (1) {
+                // wait for previous asynchronous write to complete
+                while (aio_suspend((const struct aiocb * const *) waiol, 1, NULL) && errno == EINTR);
+                ssize_t n_write = aio_return(waiol[0]);
+                if (n_write < 0 && errno == EINTR ||
+                        n_write >= 0 && n_write < waiol[0]->aio_nbytes) {
+                    // retry if write interrupted or short write
+                    if (aio_write(waiol[0]) < 0) {
+                        error (0, errno, _("failed to initiate aio_write: %s"),
+                            quote (crt->dst_name));
+                        return false;
+                    }
+                    continue;
+                } else if (n_write < 0) {
+                    // abort if write error
+                    error (0, errno, _("writing %s"), quote (crt->dst_name));
+                    return false;
+                }
+                break;
+              }
+              if (co->print_stats) {
+                clock_gettime(0, &wts[1]);
+                crt->write_time += (double) (
+                    (double) wts[1].tv_sec +
+                        (double) wts[1].tv_nsec / (double) 1.0e9 -
+                    (double) wts[0].tv_sec -
+                        (double) wts[0].tv_nsec / (double) 1.0e9);
+              }
+          }
+          n_read = aio_return(raiol[0]);
+      } else {
+          off_t to_read = MIN(max_n_read,
+            MIN(buf_size, crt->stop_offset - start_offset - *total_n_read));
+          // special handling for non-empty size zero files
+          if (!src_total_size) to_read = buf_size;
+          // align offset for direct i/o and better performance when buffered
+          off_t align_read = (start_offset + *total_n_read) % 4096;
+          if (align_read != 0 && to_read > 4096) to_read = 4096 - align_read;
+          if (co->read_mode && to_read < buf_size) {
+              // turn off direct i/o if going to read unaligned block
+              int old_flags = fcntl(crt->src_fd, F_GETFL);
+              if (fcntl(crt->src_fd, F_SETFL, old_flags & ~O_DIRECT) != 0)
+                  error(0, errno, _("failed to turn off O_DIRECT: %s"),
+                      quote(crt->src_name));
+          }
+
+          if (co->print_stats) clock_gettime(0, &rts[0]);
+          n_read = read (crt->src_fd, buf[aio_buf], to_read);
+          if (co->print_stats) clock_gettime(0, &rts[1]);
+
+          if (co->read_mode && align_read != 0) {
+            // turn direct i/o back on in case it was turned off
+            int old_flags = fcntl(crt->src_fd, F_GETFL);
+            if (!(old_flags & O_DIRECT) &&
+                fcntl(crt->src_fd, F_SETFL, old_flags | O_DIRECT) != 0)
+                    error(0, errno, _("failed to turn on O_DIRECT: %s"),
+                        quote(crt->src_name));
+          }
+      }
+
+      if (co->print_stats) {
+        crt->read_time += (double) (
+            (double) rts[1].tv_sec +
+                (double) rts[1].tv_nsec / (double) 1.0e9 -
+            (double) rts[0].tv_sec -
+                (double) rts[0].tv_nsec / (double) 1.0e9);
+      }
+// < PZK
 
-      ssize_t n_read = read (src_fd, buf, MIN (max_n_read, buf_size));
       if (n_read < 0)
         {
           if (errno == EINTR)
             continue;
-          error (0, errno, _("error reading %s"), quote (src_name));
+// PZK >
+          error (0, errno, _("error reading %s"), quote (crt->src_name));
+// < PZK
           return false;
         }
       if (n_read == 0)
         break;
       max_n_read -= n_read;
+
+// PZK >
+#ifdef POSIX_FADV_DONTNEED
+      if (co->fadvise_read) {
+          // indicate done with read data
+          posix_fadvise(crt->src_fd, start_offset + *total_n_read,
+              n_read, POSIX_FADV_DONTNEED);
+      }
+      if (co->fadvise_write && *total_n_read >= buf_size) {
+          sync_file_range(crt->dst_fd, dst_offset + *total_n_read - buf_size,
+              buf_size, SYNC_FILE_RANGE_WRITE|SYNC_FILE_RANGE_WAIT_AFTER);
+           posix_fadvise(crt->dst_fd, dst_offset + *total_n_read - buf_size,
+              buf_size, POSIX_FADV_DONTNEED);
+      }
+#endif
+
       *total_n_read += n_read;
 
+      off_t to_read = MIN(max_n_read,
+        MIN(buf_size, crt->stop_offset - start_offset - *total_n_read));
+      // special handling for non-empty size zero files
+      if (!src_total_size) to_read = buf_size;
+      if (co->double_buffer && to_read > 0) {
+        if (co->read_mode && to_read < buf_size) {
+            // turn off direct i/o if going to read unaligned block
+            int old_flags = fcntl(crt->src_fd, F_GETFL);
+            if (fcntl(crt->src_fd, F_SETFL, old_flags & ~O_DIRECT) != 0)
+                error(0, errno, _("failed to turn off O_DIRECT: %s"),
+                    quote(crt->src_name));
+        }
+
+        if (co->print_stats) clock_gettime(0, &rts[0]);
+        memset(&raio, 0, sizeof(struct aiocb));
+        raio.aio_fildes = crt->src_fd;
+        raio.aio_offset = start_offset + *total_n_read;
+        raio.aio_buf = buf[!aio_buf];
+        raio.aio_nbytes = to_read;
+        raiol[0] = &raio;
+        if (aio_read(&raio) < 0) {
+            error (0, errno, _("failed to initiate aio_read: %s"),
+                quote (crt->src_name));
+            return false;
+        }
+      }
+// < PZK
+
       if (make_holes)
         {
           /* Sentinel required by is_nul().  */
-          buf[n_read] = '\1';
+// PZK >
+          buf[aio_buf][n_read] = '\1';
+// < PZK
 #ifdef lint
           typedef uintptr_t word;
           /* Usually, buf[n_read] is not the byte just before a "word"
@@ -187,14 +453,19 @@ sparse_copy (int src_fd, int dest_fd, ch
              after the sentinel.  To avoid false-positive reports about
              this condition (e.g., from a tool like valgrind), set the
              remaining bytes -- to any value.  */
-          memset (buf + n_read + 1, 0, sizeof (word) - 1);
+// PZK >
+          memset (buf[aio_buf] + n_read + 1, 0, sizeof (word) - 1);
+// < PZK
 #endif
 
-          if ((make_hole = is_nul (buf, n_read)))
+// PZK >
+          if ((make_hole = is_nul (buf[aio_buf], n_read)))
             {
-              if (lseek (dest_fd, n_read, SEEK_CUR) < 0)
+              if (lseek (crt->dst_fd, n_read, SEEK_CUR) < 0)
                 {
-                  error (0, errno, _("cannot lseek %s"), quote (dst_name));
+                  error (0, errno, _("cannot lseek %s"), quote (crt->dst_name));
+                  if (co->double_buffer) aio_cancel(raio.aio_fildes, &raio);
+// < PZK
                   return false;
                 }
             }
@@ -203,9 +474,43 @@ sparse_copy (int src_fd, int dest_fd, ch
       if (!make_hole)
         {
           size_t n = n_read;
-          if (full_write (dest_fd, buf, n) != n)
+// PZK >
+          if (n < buf_size && co->write_mode) {
+            int old_flags = fcntl (crt->dst_fd, F_GETFL);
+            if (fcntl (crt->dst_fd, F_SETFL, old_flags & ~O_DIRECT) != 0)
+                error (0, errno, _("failed to turn off O_DIRECT: %s"),
+                    quote (crt->dst_name));
+          }
+          if (co->print_stats) clock_gettime(0, &wts[0]);
+          ssize_t n_write;
+          if (co->double_buffer) {
+            memset(&waio, 0, sizeof(struct aiocb));
+            waio.aio_fildes = crt->dst_fd;
+            waio.aio_offset = dst_offset + *total_n_read - n;
+            waio.aio_buf = buf[aio_buf];
+            waio.aio_nbytes = n;
+            waiol[0] = &waio;
+            if (aio_write(&waio) < 0) {
+                error (0, errno, _("failed to initiate aio_write: %s"),
+                    quote (crt->dst_name));
+                return false;
+            }
+          } else {
+            n_write = full_write (crt->dst_fd, buf[aio_buf], n);
+            if (co->print_stats) {
+                clock_gettime(0, &wts[1]);
+                crt->write_time += (double) (
+                    (double) wts[1].tv_sec +
+                        (double) wts[1].tv_nsec / (double) 1.0e9 -
+                    (double) wts[0].tv_sec -
+                        (double) wts[0].tv_nsec / (double) 1.0e9);
+            }
+          }
+
+          if (!co->double_buffer && n_write != n)
             {
-              error (0, errno, _("error writing %s"), quote (dst_name));
+              error (0, errno, _("writing %s"), quote (crt->dst_name));
+// < PZK
               return false;
             }
 
@@ -216,8 +521,51 @@ sparse_copy (int src_fd, int dest_fd, ch
         }
 
       *last_write_made_hole = make_hole;
+// PZK >
+#if HAVE_LIBGCRYPT
+      if (co->print_hash && crt->nsplits == 1)
+        gcry_md_write(*ctx, buf[aio_buf], n_read);
+       if (co->print_hash && crt->nsplits > 1)
+        hash_tree(htt, crt, co, buf[aio_buf],
+            start_offset - crt->start_offset + *total_n_read);
+#endif
+      if (co->double_buffer) aio_buf = !aio_buf;
     }
 
+  if (waiol[0] != NULL) {
+    while (1) {
+        // wait for final asynchronous write to complete
+        while (aio_suspend((const struct aiocb * const *) waiol, 1, NULL) && errno == EINTR);
+        ssize_t n_write = aio_return(waiol[0]);
+        if (n_write < 0 && errno == EINTR ||
+                n_write >= 0 && n_write < waiol[0]->aio_nbytes) {
+            // retry if write interrupted or short write
+            if (aio_write(waiol[0]) < 0) {
+                error (0, errno, _("failed to initiate aio_write: %s"),
+                    quote (crt->dst_name));
+                return false;
+            }
+            continue;
+        } else if (n_write < 0) {
+            // abort if write error
+            error (0, errno, _("writing %s"), quote (crt->dst_name));
+            return false;
+        }
+        break;
+    }
+#ifdef POSIX_FADV_DONTNEED
+    if (co->fadvise_write) {
+# ifdef __linux__
+        sync_file_range(crt->dst_fd, waiol[0]->aio_offset, waiol[0]->aio_nbytes,
+            SYNC_FILE_RANGE_WRITE|SYNC_FILE_RANGE_WAIT_AFTER);
+# endif
+        posix_fadvise(crt->dst_fd, waiol[0]->aio_offset, waiol[0]->aio_nbytes,
+            POSIX_FADV_DONTNEED);
+    }
+#endif
+  }
+// < PZK
+
   return true;
 }
 
@@ -281,20 +629,31 @@ write_zeros (int fd, uint64_t n_bytes)
    Upon any other failure, set *NORMAL_COPY_REQUIRED to false and
    return false.  */
 static bool
-extent_copy (int src_fd, int dest_fd, char *buf, size_t buf_size,
-             off_t src_total_size, enum Sparse_type sparse_mode,
-             char const *src_name, char const *dst_name,
-             bool *require_normal_copy)
+// PZK >
+extent_copy (copy_reg_t *crt, struct cp_options *co,
+             char *buf[], size_t buf_size, off_t src_total_size,
+             enum Sparse_type sparse_mode, bool *require_normal_copy
+#if HAVE_LIBGCRYPT
+             , gcry_md_hd_t *ctx, hash_tree_t *htt
+#endif
+            )
+// < PZK
 {
   struct extent_scan scan;
-  off_t last_ext_start = 0;
+// PZK >
+  off_t last_ext_start = crt->start_offset;
+// < PZK
   uint64_t last_ext_len = 0;
 
   /* Keep track of the output position.
      We may need this at the end, for a final ftruncate.  */
-  off_t dest_pos = 0;
-
-  extent_scan_init (src_fd, &scan);
+// PZK >
+  // note that dest_pos is relative to start_offset and not dst_offset
+  off_t dest_pos = crt->start_offset;
+
+  extent_scan_init (crt->src_fd, &scan, crt->start_offset,
+    crt->stop_offset);
+// < PZK
 
   *require_normal_copy = false;
   bool wrote_hole_at_eof = true;
@@ -313,7 +672,9 @@ extent_copy (int src_fd, int dest_fd, ch
             }
 
           error (0, errno, _("%s: failed to get extents info"),
-                 quote (src_name));
+// PZK >
+                 quote (crt->src_name));
+// < PZK
           return false;
         }
 
@@ -337,15 +698,26 @@ extent_copy (int src_fd, int dest_fd, ch
               ext_len = 0;
             }
 
+// PZK >
+          if (ext_start + ext_len > crt->stop_offset) {
+            ext_len = crt->stop_offset - ext_start;
+          }
+          if (ext_start < crt->start_offset) {
+            ext_len -= crt->start_offset - ext_start;
+            ext_start = crt->start_offset;
+          }
+// < PZK
           hole_size = ext_start - last_ext_start - last_ext_len;
 
           wrote_hole_at_eof = false;
 
           if (hole_size)
             {
-              if (lseek (src_fd, ext_start, SEEK_SET) < 0)
+// PZK >
+              if (lseek (crt->src_fd, ext_start, SEEK_SET) < 0)
                 {
-                  error (0, errno, _("cannot lseek %s"), quote (src_name));
+                  error (0, errno, _("cannot lseek %s"), quote (crt->src_name));
+// < PZK
                 fail:
                   extent_scan_free (&scan);
                   return false;
@@ -354,9 +726,12 @@ extent_copy (int src_fd, int dest_fd, ch
               if ((empty_extent && sparse_mode == SPARSE_ALWAYS)
                   || (!empty_extent && sparse_mode != SPARSE_NEVER))
                 {
-                  if (lseek (dest_fd, ext_start, SEEK_SET) < 0)
+// PZK >
+                  if (lseek (crt->dst_fd, crt->dst_offset - crt->start_offset +
+                            ext_start, SEEK_SET) < 0)
                     {
-                      error (0, errno, _("cannot lseek %s"), quote (dst_name));
+                      error (0, errno, _("cannot lseek %s"), quote (crt->dst_name));
+// < PZK
                       goto fail;
                     }
                   wrote_hole_at_eof = true;
@@ -368,16 +743,39 @@ extent_copy (int src_fd, int dest_fd, ch
                      current one, write zeros to the destination file.  */
                   off_t nzeros = hole_size;
                   if (empty_extent)
-                    nzeros = MIN (src_total_size - dest_pos, hole_size);
-
-                  if (! write_zeros (dest_fd, nzeros))
+// PZK >
+                    nzeros = MIN (crt->stop_offset - dest_pos, hole_size);
+                    // when double buffering, dst_fd may not even be set
+                    if (co->double_buffer && lseek(crt->dst_fd,
+                            crt->dst_offset - crt->start_offset +
+                            crt->stop_offset - nzeros, SEEK_SET) < 0L) {
+                        error (0, errno, _("cannot lseek %s"), quote (crt->dst_name));
+                        goto fail;
+                    }
+                  if (! write_zeros (crt->dst_fd, nzeros))
                     {
-                      error (0, errno, _("%s: write failed"), quote (dst_name));
+                      error (0, errno, _("%s: write failed"), quote (crt->dst_name));
+// < PZK
                       goto fail;
                     }
 
                   dest_pos = MIN (src_total_size, ext_start);
                 }
+// PZK >
+#if HAVE_LIBGCRYPT
+              off_t nzeros = hole_size;
+              memset(buf[0], 0, buf_size);
+              while (nzeros > 0) {
+                if (co->print_hash && crt->nsplits == 1)
+                    gcry_md_write(*ctx, buf[0], MIN(buf_size, nzeros));
+                if (co->print_hash && crt->nsplits > 1)
+                    hash_tree(htt, crt, co, buf[0],
+                        ext_start - crt->start_offset - nzeros +
+                        MIN(buf_size, nzeros));
+                nzeros -= buf_size;
+              }
+#endif
+// < PZK
             }
 
           last_ext_start = ext_start;
@@ -401,10 +799,16 @@ extent_copy (int src_fd, int dest_fd, ch
               empty_extent = false;
               last_ext_len = ext_len;
 
-              if ( ! sparse_copy (src_fd, dest_fd, buf, buf_size,
-                                  sparse_mode == SPARSE_ALWAYS,
-                                  src_name, dst_name, ext_len, &n_read,
-                                  &wrote_hole_at_eof))
+// PZK >
+              if ( ! sparse_copy (crt, co, buf, buf_size, src_total_size,
+                                  sparse_mode == SPARSE_ALWAYS, ext_start,
+                                  crt->dst_offset + ext_start - crt->start_offset,
+                                  ext_len, &n_read, &wrote_hole_at_eof
+#if HAVE_LIBGCRYPT
+                                  , ctx, htt
+#endif
+                                 ))
+// < PZK
                 goto fail;
 
               dest_pos = ext_start + n_read;
@@ -436,14 +840,49 @@ extent_copy (int src_fd, int dest_fd, ch
      In addition, if the final extent was a block of zeros at EOF and we've
      just converted them to a hole in the destination, we must call ftruncate
      here in order to record the proper length in the destination.  */
-  if ((dest_pos < src_total_size || wrote_hole_at_eof)
-      && (sparse_mode != SPARSE_NEVER
-          ? ftruncate (dest_fd, src_total_size)
-          : ! write_zeros (dest_fd, src_total_size - dest_pos)))
-    {
-      error (0, errno, _("failed to extend %s"), quote (dst_name));
-      return false;
+
+// PZK >
+  if (wrote_hole_at_eof || dest_pos < crt->stop_offset) {
+    if (sparse_mode == SPARSE_NEVER) {
+        if (lseek (crt->dst_fd, crt->dst_offset - crt->start_offset +
+                dest_pos, SEEK_SET) < 0L ||
+                !write_zeros(crt->dst_fd, crt->stop_offset - dest_pos)) {
+            error (0, errno, _("%s: write failed"), quote (crt->dst_name));
+            return false;
+        }
+    } else if (crt->dst_offset == 0 && crt->stop_offset == src_total_size) {
+        if (ftruncate(crt->dst_fd, src_total_size)) {
+            error (0, errno, _("failed to extend %s"), quote (crt->dst_name));
+            return false;
+        }
+    } else if (crt->split + 1 == crt->nsplits) {
+        if (lseek (crt->dst_fd, crt->dst_offset - crt->start_offset +
+                crt->stop_offset - 1, SEEK_SET) < 0L ||
+                co->write_mode && fcntl (crt->dst_fd, F_SETFL,
+                    fcntl (crt->dst_fd, F_GETFL) & ~O_DIRECT) ||
+                full_write (crt->dst_fd, "", 1) != 1) {
+            error (0, errno, _("%s: write failed"), quote (crt->dst_name));
+            return false;
+        }
     }
+  }
+
+#if HAVE_LIBGCRYPT
+  if (dest_pos < crt->stop_offset) {
+    off_t nzeros = crt->stop_offset - dest_pos;
+    memset(buf[0], 0, buf_size);
+    while (nzeros > 0) {
+        if (co->print_hash && crt->nsplits == 1)
+            gcry_md_write(*ctx, buf[0], MIN(buf_size, nzeros));
+        if (co->print_hash && crt->nsplits > 1)
+            hash_tree(htt, crt, co, buf[0],
+                crt->stop_offset - crt->start_offset - nzeros +
+                MIN(buf_size, nzeros));
+        nzeros -= buf_size;
+    }
+  }
+#endif
+// < PZK
 
   return true;
 }
@@ -872,6 +1311,236 @@ is_probably_sparse (struct stat const *s
           && ST_NBLOCKS (*sb) < sb->st_size / ST_NBLOCKSIZE);
 }
 
+// PZK >
+extern bool
+copy_reg_task (copy_reg_t *crt, struct cp_options *co)
+{
+  char *buf[2];
+  char *buf_alloc[2];
+  buf_alloc[0] = NULL;
+  buf_alloc[1] = NULL;
+  struct stat src_open_sb;
+  bool return_val = true;
+
+#if HAVE_LIBGCRYPT
+  hash_tree_t htt;
+#endif
+
+  if (fstat (crt->src_fd, &src_open_sb) != 0)
+    {
+      error (0, errno, _("cannot fstat %s"), quote (crt->src_name));
+      return_val = false;
+      goto task_close_src_and_dst_desc;
+    }
+
+    typedef uintptr_t word;
+
+    /* Choose a suitable buffer size; it may be adjusted later.  */
+    size_t buf_alignment = lcm (getpagesize (), sizeof (word));
+    size_t buf_alignment_slop = sizeof (word) + buf_alignment - 1;
+    size_t buf_size = crt->dst_blksize;
+
+    /* Deal with sparse files.  */
+    bool make_holes = false;
+    bool sparse_src = false;
+
+    if (S_ISREG (crt->dst_mode))
+      {
+        /* Even with --sparse=always, try to create holes only
+           if the destination is a regular file.  */
+        if (co->sparse_mode == SPARSE_ALWAYS)
+          make_holes = true;
+
+        /* Use a heuristic to determine whether SRC_NAME contains any sparse
+           blocks.  If the file has fewer blocks than would normally be
+           needed for a file of its size, then at least one of the blocks in
+           the file is a hole.  */
+        sparse_src = is_probably_sparse (&src_open_sb);
+        if (co->sparse_mode == SPARSE_AUTO && sparse_src)
+          make_holes = true;
+      }
+
+    /* If not making a sparse file, try to use a more-efficient
+       buffer size.  */
+    if (! make_holes)
+      {
+        /* Compute the least common multiple of the input and output
+           buffer sizes, adjusting for outlandish values.  */
+        size_t blcm_max = MIN (SIZE_MAX, SSIZE_MAX) - buf_alignment_slop;
+        size_t blcm = buffer_lcm (io_blksize (src_open_sb), buf_size,
+                                  blcm_max);
+// PZK >
+        blcm = co->buffer_size;
+        if (co->read_mode || co->write_mode)
+          blcm = buffer_lcm (blcm, 4096, blcm_max);
+// < PZK
+
+        /* Do not bother with a buffer larger than the input file, plus one
+           byte to make sure the file has not grown while reading it.  */
+        if (S_ISREG (src_open_sb.st_mode) && src_open_sb.st_size < buf_size)
+          buf_size = src_open_sb.st_size + 1;
+
+        /* However, stick with a block size that is a positive multiple of
+           blcm, overriding the above adjustments.  Watch out for
+           overflow.  */
+        buf_size += blcm - 1;
+        buf_size -= buf_size % blcm;
+        if (buf_size == 0 || blcm_max < buf_size)
+          buf_size = blcm;
+      }
+
+    /* Make a buffer with space for a sentinel at the end.  */
+    buf_alloc[0] = xmalloc (buf_size + buf_alignment_slop);
+    buf[0] = ptr_align (buf_alloc[0], buf_alignment);
+    if (co->double_buffer) {
+      buf_alloc[1] = xmalloc (buf_size + buf_alignment_slop);
+      buf[1] = ptr_align (buf_alloc[1], buf_alignment);
+    }
+
+#if HAVE_LIBGCRYPT
+    gcry_md_hd_t ctx;
+    if (co->print_hash) {
+      gcry_md_open(&ctx, co->hash_type, 0);
+      if (crt->nsplits > 1) {
+          htt.total_n_hash = 0;
+          htt.hash_ctx = &ctx;
+          htt.hash_ctx_len = 0;
+          htt.stack_len = 0;
+
+          // compute approximate height of split sub-tree
+          off_t leafs = (crt->stop_offset - crt->start_offset) /
+              co->hash_leaf_size + 1;
+          ssize_t n = 1;
+          while (leafs >>= 1) n++;
+          // stack needs space for at most height of tree hashes
+          htt.stack = xmalloc(n * co->hash_size);
+      }
+    }
+#endif
+
+    if (sparse_src)
+      {
+        bool normal_copy_required;
+
+        /* Perform an efficient extent-based copy, falling back to the
+           standard copy only if the initial extent scan fails.  If the
+           '--sparse=never' option is specified, write all data but use
+           any extents to read more efficiently.  */
+        if (extent_copy (crt, co, buf, buf_size, src_open_sb.st_size,
+                         S_ISREG (src_open_sb.st_mode) ?
+                              co->sparse_mode : SPARSE_NEVER,
+                         &normal_copy_required
+#if HAVE_LIBGCRYPT
+                         , &ctx, &htt
+#endif
+                        ))
+          goto task_preserve_metadata;
+
+        if (! normal_copy_required)
+          {
+            return_val = false;
+            goto task_close_src_and_dst_desc;
+          }
+      }
+
+    off_t n_read;
+    bool wrote_hole_at_eof;
+    bool copy_ok = sparse_copy (crt, co, buf, buf_size, src_open_sb.st_size,
+                        make_holes, crt->start_offset, crt->dst_offset,
+                        UINTMAX_MAX, &n_read, &wrote_hole_at_eof
+#if HAVE_LIBGCRYPT
+                         , &ctx, &htt
+#endif
+                       );
+// PZK >
+    off_t dest_pos = crt->start_offset + n_read;
+    if (copy_ok && (wrote_hole_at_eof || dest_pos < crt->stop_offset)) {
+        if (co->sparse_mode == SPARSE_NEVER) {
+            if (lseek (crt->dst_fd, crt->dst_offset - crt->start_offset +
+                    dest_pos, SEEK_SET) < 0L ||
+                    !write_zeros(crt->dst_fd, crt->stop_offset - dest_pos)) {
+                error (0, errno, _("%s: write failed"), quote (crt->dst_name));
+                return_val = false;
+                goto task_close_src_and_dst_desc;
+            }
+        } else if (crt->dst_offset == 0 && crt->stop_offset == src_open_sb.st_size) {
+            if (ftruncate(crt->dst_fd, src_open_sb.st_size)) {
+                error (0, errno, _("failed to extend %s"), quote (crt->dst_name));
+                return_val = false;
+                goto task_close_src_and_dst_desc;
+            }
+        } else if (crt->split + 1 == crt->nsplits) {
+            if (lseek (crt->dst_fd, crt->dst_offset - crt->start_offset +
+                    crt->stop_offset - 1, SEEK_SET) < 0L ||
+                    co->write_mode && fcntl (crt->dst_fd, F_SETFL,
+                        fcntl (crt->dst_fd, F_GETFL) & ~O_DIRECT) ||
+                    full_write (crt->dst_fd, "", 1) != 1) {
+                error (0, errno, _("%s: write failed"), quote (crt->dst_name));
+                return_val = false;
+                goto task_close_src_and_dst_desc;
+            }
+        }
+    }
+// < PZK
+
+task_preserve_metadata:
+  if (co->preserve_timestamps)
+    {
+      struct timespec timespec[2];
+      timespec[0] = crt->src_atime;
+      timespec[1] = crt->src_mtime;
+
+      if (fdutimens (crt->dst_fd, crt->dst_name, timespec) != 0)
+        {
+          error (0, errno, _("preserving times for %s"), quote (crt->dst_name));
+          if (co->require_preserve)
+            {
+              return_val = false;
+              goto task_close_src_and_dst_desc;
+            }
+        }
+    }
+
+task_close_src_and_dst_desc:
+  if (close (crt->dst_fd) < 0)
+     {
+      error (0, errno, _("closing %s"), quote (crt->dst_name));
+      return_val = false;
+    }
+  if (close (crt->src_fd) < 0)
+    {
+      error (0, errno, _("closing %s"), quote (crt->src_name));
+      return_val = false;
+    }
+
+  free (buf_alloc[0]);
+  free (buf_alloc[1]);
+  if (!return_val) {
+    error (0, 0, _("%s: FAILED open or read"), quote (crt->src_name));
+#if HAVE_LIBGCRYPT
+  } else if (co->print_hash) {
+    // copy final hash onto crt hash stack
+    if (crt->nsplits > 1) {
+        memcpy(crt->hash_stack, htt.stack, co->hash_size);
+    } else {
+        memcpy(crt->hash_stack, gcry_md_read(ctx, 0), co->hash_size);
+    }
+#endif
+  }
+
+#if HAVE_LIBGCRYPT
+  if (buf_alloc[0] != NULL && co->print_hash) {
+    gcry_md_close(ctx);
+    if (crt->nsplits > 1) {
+        free(htt.stack);
+    }
+  }
+#endif
+
+  return return_val;
+}
+// < PZK
+
 
 /* Copy a regular file from SRC_NAME to DST_NAME.
    If the source file contains holes, copies holes and blocks of zeros
@@ -902,10 +1571,21 @@ copy_reg (char const *src_name, char con
   struct stat src_open_sb;
   bool return_val = true;
   bool data_copy_required = x->data_copy_required;
+// PZK >
+  mode_t wdst_mode = dst_mode | S_IWUSR;
+// < PZK
 
   source_desc = open (src_name,
                       (O_RDONLY | O_BINARY
+// PZK >
+                       | x->read_mode
+// < PZK
                        | (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));
+// PZK >
+  if (source_desc < 0 && x->read_mode)
+    source_desc = open (src_name, (O_RDONLY | O_BINARY
+                       | (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));
+// < PZK
   if (source_desc < 0)
     {
       error (0, errno, _("cannot open %s for reading"), quote (src_name));
@@ -934,9 +1614,14 @@ copy_reg (char const *src_name, char con
      by the specs for both cp and mv.  */
   if (! *new_dst)
     {
-      int open_flags =
-        O_WRONLY | O_BINARY | (x->data_copy_required ? O_TRUNC : 0);
-      dest_desc = open (dst_name, open_flags);
+// PZK >
+      if (x->offset || x->length >= 0)
+        // do not truncate when doing partial copy
+        dest_desc = open (dst_name, O_WRONLY | O_BINARY | x->write_mode);
+      else
+        dest_desc = open (dst_name, O_WRONLY | O_BINARY |
+            (data_copy_required ? O_TRUNC : 0) | x->write_mode);
+// < PZK
       dest_errno = errno;
 
       /* When using cp --preserve=context to copy to an existing destination,
@@ -992,9 +1677,62 @@ copy_reg (char const *src_name, char con
     {
     open_with_O_CREAT:;
 
-      int open_flags = O_WRONLY | O_CREAT | O_BINARY;
+// PZK >
+      int open_flags = O_WRONLY | O_CREAT | O_BINARY | x->write_mode;
+#if HAVE_LIBLUSTREAPI
+      // check if dst is lustre
+      struct statfs sfs;
+      char *dir = xstrdup(dst_name);
+      int rc = statfs(dirname(dir), &sfs);
+      free(dir);
+      if (!rc && sfs.f_type == LL_SUPER_MAGIC && x->stripe_count > 0) {
+        // dst is lustre
+        int scount = 0;
+        int ssize = 0;
+        struct lov_user_md *lum = xmalloc(LOV_EA_MAX(lum));
+        // check if src is lustre
+        if (x->stripe_ratio == 0 && !fstatfs(source_desc, &sfs) &&
+                sfs.f_type == LL_SUPER_MAGIC) {
+            // src is lustre and no striping specified so preserve src striping
+            if (!llapi_file_get_stripe(src_name, lum)) {
+                scount = lum->lmm_stripe_count;
+                ssize = lum->lmm_stripe_size;
+                // restripe to # of GBs if stripe count is the default
+                if (scount == DEFAULT_LUSTRE_STRIPES) {
+                    int scount0 = scount;
+                    scount = src_sb->st_size / 1000000000 + 1;
+                    if (x->print_stripe)
+                        error(0, 0, _("note: stripe count of %s has been adjusted from %d to %d"),
+                            quote(dst_name), scount0, scount);
+                }
+            }
+        } else {
+            // src is not lustre or striping specified
+            if (x->stripe_ratio == 'l') {
+                scount = x->length / 1000000000 * x->stripe_count + 1;
+            } else if (x->stripe_ratio == 'a') {
+                scount = x->stripe_count;
+            } else {
+                scount = src_sb->st_size / 1000000000 * x->stripe_count + 1;
+            }
+        }
+        if (scount > MUTIL_MAX_STRIPE_COUNT) scount = MUTIL_MAX_STRIPE_COUNT;
+        dest_desc = llapi_file_open(dst_name, open_flags,
+                wdst_mode & ~omitted_permissions, ssize, -1, scount, 0);
+        if (dest_desc > 0 && !llapi_file_get_stripe(dst_name, lum) &&
+                lum->lmm_stripe_count != scount) {
+            //TODO: this probably shouldn't be printed for every
+            //      file, especially when physical OST counts differ
+            //      between file systems
+            error(0, 0, _("warning: allocated stripe count of %s does not match original stripe count of %s"),
+                quote_n(0, dst_name), quote_n(1, src_name));
+        }
+        free(lum);
+      } else
+#endif
       dest_desc = open (dst_name, open_flags | O_EXCL,
-                        dst_mode & ~omitted_permissions);
+                        wdst_mode & ~omitted_permissions);
+// < PZK
       dest_errno = errno;
 
       /* When trying to copy through a dangling destination symlink,
@@ -1016,7 +1754,9 @@ copy_reg (char const *src_name, char con
               if (x->open_dangling_dest_symlink)
                 {
                   dest_desc = open (dst_name, open_flags,
-                                    dst_mode & ~omitted_permissions);
+// PZK >
+                                    wdst_mode & ~omitted_permissions);
+// < PZK
                   dest_errno = errno;
                 }
               else
@@ -1089,6 +1829,9 @@ copy_reg (char const *src_name, char con
         }
     }
 
+// PZK >
+#if 0
+// < PZK
   if (data_copy_required)
     {
       typedef uintptr_t word;
@@ -1183,6 +1926,83 @@ copy_reg (char const *src_name, char con
           goto close_src_and_dst_desc;
         }
     }
+// PZK >
+#endif
+#ifdef _OPENMP
+    if (data_copy_required) {
+        off_t pos = 0;
+        if (x->offset && x->offset > src_sb->st_size) pos = src_sb->st_size;
+        else if (x->offset) pos = x->offset;
+        off_t orig_offset = pos + x->dst_offset;
+        off_t end = src_sb->st_size;
+        if (x->length >= 0 && pos + x->length < end) end = pos + x->length;
+# ifdef __linux__
+        // preallocate space for file without changing size
+        if (x->preallocate >= 0 && 1 - 512.0 * (float) src_sb->st_blocks /
+                (float) src_sb->st_size < (float) x->preallocate / 100.0)
+            fallocate(dest_desc, FALLOC_FL_KEEP_SIZE,
+                pos + x->dst_offset - x->offset, end - pos);
+# endif
+
+        size_t nsplits = 1, split = 0;
+        if (x->split_size > 0 && end - pos > 0)
+            nsplits = (end - pos) / x->split_size +
+                ((end - pos) % x->split_size ? 1 : 0);
+        while (nsplits == 1 || pos < end) {
+            copy_reg_t *crt = xmalloc(sizeof(copy_reg_t));
+            crt->src_name = xstrdup(src_name);
+            crt->dst_name = xstrdup(dst_name);
+            crt->dst_mode = sb.st_mode;
+            crt->src_atime = get_stat_atime(src_sb);
+            crt->src_mtime = get_stat_mtime(src_sb);
+            crt->dst_blksize = io_blksize(sb);
+            crt->read_time = 0;
+            crt->write_time = 0;
+            crt->copy_time = 0;
+            crt->nsplits = nsplits;
+            crt->split = split++;
+            crt->start_offset = pos;
+            // do not seek dst when pos less than original offset
+            crt->dst_offset = pos >= x->offset ?
+                pos + x->dst_offset - x->offset : 0;
+            crt->orig_offset = orig_offset;
+            crt->partial = x->offset || x->length >= 0 ||
+                end < src_sb->st_size ? true : false;
+            crt->hash_stack = xmalloc(x->hash_size);
+            if (x->print_stats || x->print_hash)
+                *x->hash_stat_tasks += 1;
+            pos += x->split_size;
+            if (nsplits > 1) {
+                // stop after split size bytes
+                crt->stop_offset = MIN(pos, end);
+                if (crt->start_offset == x->offset && x->print_hash) {
+                    copy_reg_t *crtcp = xmalloc(sizeof(copy_reg_t));
+                    crtcp->nsplits = nsplits;
+                    crtcp->split = nsplits;
+                    crtcp->start_offset = x->offset;
+                    crtcp->stop_offset = end;
+                    crtcp->orig_offset = orig_offset;
+                    crtcp->dst_offset = x->dst_offset;
+                    crtcp->partial = crt->partial;
+                    crtcp->src_name = xstrdup(src_name);
+                    crtcp->dst_name = xstrdup(dst_name);
+                    crtcp->hash_stack = xmalloc(nsplits * x->hash_size);
+                    // send crt copy to hash handler
+                    sem_q_push(x->send_q, crtcp);
+                }
+            } else {
+                // stop at end of file
+                crt->stop_offset = end;
+            }
+            sem_q_push(x->task_q, crt);
+            // wait until file has been opened
+             //TODO: to be reliable probably need timeout here
+            sem_q_pop(x->open_q);
+            if (nsplits == 1) break;
+        }
+    }
+#endif
+// < PZK
 
 preserve_metadata:
   if (x->preserve_timestamps)
@@ -1254,10 +2074,15 @@ preserve_metadata:
       if (set_acl (dst_name, dest_desc, 0666 & ~cached_umask ()) != 0)
         return_val = false;
     }
-  else if (omitted_permissions)
+// PZK >
+  else if (omitted_permissions || dst_mode != wdst_mode)
+// < PZK
     {
       omitted_permissions &= ~ cached_umask ();
-      if (omitted_permissions
+// PZK >
+      if ((omitted_permissions || dst_mode != wdst_mode)
+          && !x->skip_chmod
+// < PZK
           && fchmod_or_lchmod (dest_desc, dst_name, dst_mode) != 0)
         {
           error (0, errno, _("preserving permissions for %s"),
@@ -2367,6 +3192,38 @@ copy_internal (char const *src_name, cha
                      quote (dst_name));
               goto un_backup;
             }
+// PZK >
+#if HAVE_LIBLUSTREAPI
+          else {
+            // check if dst is lustre
+            struct statfs sfs;
+            if (x->stripe_count > 0 &&
+                    !statfs(dst_name, &sfs) && sfs.f_type == LL_SUPER_MAGIC) {
+                // dst is lustre
+                // check if src is lustre
+                if (!statfs(src_name, &sfs) && sfs.f_type == LL_SUPER_MAGIC) {
+                    // src is lustre so get current src striping
+                    struct lov_user_md *lum = xmalloc(LOV_EA_MAX(lum));
+                    if (!llapi_file_get_stripe(src_name, lum)) {
+                        int scount = lum->lmm_stripe_count;
+                        int ssize = lum->lmm_stripe_size;
+                        // restripe to 0 if stripe count is the default
+                        if (scount == DEFAULT_LUSTRE_STRIPES) {
+                            if (x->print_stripe)
+                                error(0, 0, _("note: stripe count of %s has been adjusted from %d to 0"),
+                                    quote(dst_name), scount);
+                            scount = 0;
+                        }
+                        if (llapi_file_create(dst_name, ssize, -1, scount, 0))
+                            error(0, 0, _("warning: unable to set stripe count of %s"),
+                                quote(dst_name));
+                    }
+                    free(lum);
+                }
+            }
+          }
+#endif
+// < PZK
 
           /* We need search and write permissions to the new directory
              for writing the directory's contents. Check if these
diff -rupN orig/src/copy.h new/src/copy.h
--- orig/src/copy.h	2013-12-04 06:48:30.000000000 -0800
+++ new/src/copy.h	2018-01-18 14:44:17.931923912 -0800
@@ -14,7 +14,69 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
-/* Extracted from cp.c and librarified by Jim Meyering.  */
+// PZK >
+/* Extracted from cp.c and librarified by Jim Meyering.
+   High performance multi-threaded modifications by Paul Kolano.  */
+
+/* Additional Terms per Section 7 of GNU General Public License Version 3
+
+1.  DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION
+
+    No Warranty: NASA PROVIDES THE COVERED WORKS "AS IS" WITHOUT ANY
+    WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
+    INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE COVERED WORKS
+    WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
+    INFRINGEMENT, ANY WARRANTY THAT THE COVERED WORKS WILL BE ERROR
+    FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
+    TO THE COVERED WORKS. THIS AGREEMENT DOES NOT, IN ANY MANNER,
+    CONSTITUTE AN ENDORSEMENT BY NASA OR ANY OTHER RECIPIENT OF ANY
+    RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER
+    APPLICATIONS RESULTING FROM USE OF THE COVERED WORKS.  FURTHER, NASA
+    DISCLAIMS ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY
+    SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT
+    "AS IS."
+
+    Waiver and Indemnity: YOU AGREE TO WAIVE ANY AND ALL CLAIMS
+    AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
+    SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT.  IF YOUR USE OF THE
+    COVERED WORKS RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES
+    OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM PRODUCTS
+    BASED ON, OR RESULTING FROM, YOUR USE OF THE COVERED WORKS, YOU
+    SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS
+    CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT, TO
+    THE EXTENT PERMITTED BY LAW.  YOUR SOLE REMEDY FOR ANY SUCH MATTER
+    SHALL BE THE IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
+
+2.  You must ensure that the following copyright notice appears
+    prominently in the covered works:
+
+        Copyright 2010 United States Government National Aeronautics and
+        Space Administration (NASA).  No copyright is claimed in the United
+        States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+3.  You must characterize Your alteration of the covered works as a
+    Modification or Contribution and must identify Yourself as the
+    originator of Your Modification or Contribution in a manner that
+    reasonably allows subsequent Recipients to identify the originator
+    of the Modification or Contribution.  In fulfillment of these
+    requirements, You must include a file (e.g., a change log file) that
+    describes the alterations made and the date of the alterations,
+    identifies You as originator of the alterations, and consents to
+    characterization of the alterations as a Modification or
+    Contribution, for example, by including a statement that the
+    Modification or Contribution is derived, directly or indirectly,
+    from covered work provided by NASA. Once consent is granted, it may
+    not thereafter be revoked.
+
+4.  You may not make any representation in the covered works or in any
+    promotional, advertising or other material that may be construed as
+    an endorsement by NASA or by any other Recipient of any product or
+    service provided by You, or that may seek to obtain commercial
+    advantage of NASA's or any other Recipient's participation in this
+    License.
+*/
+// < PZK
 
 #ifndef COPY_H
 # define COPY_H
@@ -22,6 +84,16 @@
 # include <stdbool.h>
 # include "hash.h"
 
+// PZK >
+# include <stdlib.h>
+# include <sys/stat.h>
+# include <time.h>
+# include <netinet/in.h>
+
+# include "backupfile.h"
+# include "mutil-q.h"
+// < PZK
+
 /* Control creation of sparse files (files with holes).  */
 enum Sparse_type
 {
@@ -97,6 +169,45 @@ enum Dereference_symlink
    mv.c, cp.c, and install.c.  */
 struct cp_options
 {
+// PZK >
+  size_t buffer_size;
+  bool check_tree;
+  bool double_buffer;
+  off_t dst_offset;
+  bool fadvise_read;
+  bool fadvise_write;
+  off_t hash_leaf_size;
+  unsigned int hash_size;
+  long long *hash_stat_tasks;
+  int hash_type;
+  off_t length;
+  in_port_t listen_port;
+  struct addrinfo *mgr_ai;
+  char *mg_file;
+  in_port_t mgr_port;
+  bool mpi;
+  off_t offset;
+  sem_q_t *open_q;
+  char *pass;
+  int preallocate;
+  bool print_hash;
+  bool print_src;
+  bool print_stats;
+  bool print_stripe;
+  char *pw_file;
+  int read_mode;
+  bool read_stdin;
+  sem_q_t *send_q;
+  bool skip_chmod;
+  off_t split_size;
+  float stripe_count;
+  char stripe_ratio;
+  sem_q_t *task_q;
+  int threads;
+  char *user;
+  int write_mode;
+// < PZK
+
   enum backup_type backup_type;
 
   /* How to handle symlinks in the source.  */
@@ -289,4 +400,30 @@ void cp_options_default (struct cp_optio
 bool chown_failure_ok (struct cp_options const *) _GL_ATTRIBUTE_PURE;
 mode_t cached_umask (void);
 
+// PZK >
+typedef struct {
+    double copy_time;
+    size_t dst_blksize;
+    int dst_fd;
+    off_t dst_offset;
+    mode_t dst_mode;
+    char *dst_name;
+    unsigned char *hash_stack;
+    bool partial;
+    size_t nsplits;
+    off_t orig_offset;
+    double read_time;
+    size_t split;
+    struct timespec src_atime;
+    int src_fd;
+    struct timespec src_mtime;
+    char *src_name;
+    off_t start_offset;
+    off_t stop_offset;
+    double write_time;
+} copy_reg_t;
+
+bool copy_reg_task(copy_reg_t *crt, struct cp_options *co);
+// < PZK
+
 #endif
diff -rupN orig/src/cp.c new/src/cp.c
--- orig/src/cp.c	2013-12-04 16:59:36.000000000 -0800
+++ new/src/cp.c	2018-01-18 14:44:17.939924128 -0800
@@ -14,7 +14,69 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-   Written by Torbjorn Granlund, David MacKenzie, and Jim Meyering. */
+// PZK >
+   Written by Torbjorn Granlund, David MacKenzie, and Jim Meyering.
+   High performance multi-threaded modifications by Paul Kolano. */
+
+/* Additional Terms per Section 7 of GNU General Public License Version 3
+
+1.  DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION
+
+    No Warranty: NASA PROVIDES THE COVERED WORKS "AS IS" WITHOUT ANY
+    WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
+    INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE COVERED WORKS
+    WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
+    INFRINGEMENT, ANY WARRANTY THAT THE COVERED WORKS WILL BE ERROR
+    FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
+    TO THE COVERED WORKS. THIS AGREEMENT DOES NOT, IN ANY MANNER,
+    CONSTITUTE AN ENDORSEMENT BY NASA OR ANY OTHER RECIPIENT OF ANY
+    RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER
+    APPLICATIONS RESULTING FROM USE OF THE COVERED WORKS.  FURTHER, NASA
+    DISCLAIMS ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY
+    SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT
+    "AS IS."
+
+    Waiver and Indemnity: YOU AGREE TO WAIVE ANY AND ALL CLAIMS
+    AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
+    SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT.  IF YOUR USE OF THE
+    COVERED WORKS RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES
+    OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM PRODUCTS
+    BASED ON, OR RESULTING FROM, YOUR USE OF THE COVERED WORKS, YOU
+    SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS
+    CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT, TO
+    THE EXTENT PERMITTED BY LAW.  YOUR SOLE REMEDY FOR ANY SUCH MATTER
+    SHALL BE THE IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
+
+2.  You must ensure that the following copyright notice appears
+    prominently in the covered works:
+
+        Copyright 2010 United States Government National Aeronautics and
+        Space Administration (NASA).  No copyright is claimed in the United
+        States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+3.  You must characterize Your alteration of the covered works as a
+    Modification or Contribution and must identify Yourself as the
+    originator of Your Modification or Contribution in a manner that
+    reasonably allows subsequent Recipients to identify the originator
+    of the Modification or Contribution.  In fulfillment of these
+    requirements, You must include a file (e.g., a change log file) that
+    describes the alterations made and the date of the alterations,
+    identifies You as originator of the alterations, and consents to
+    characterization of the alterations as a Modification or
+    Contribution, for example, by including a statement that the
+    Modification or Contribution is derived, directly or indirectly,
+    from covered work provided by NASA. Once consent is granted, it may
+    not thereafter be revoked.
+
+4.  You may not make any representation in the covered works or in any
+    promotional, advertising or other material that may be construed as
+    an endorsement by NASA or by any other Recipient of any product or
+    service provided by You, or that may seek to obtain commercial
+    advantage of NASA's or any other Recipient's participation in this
+    License.
+*/
+// < PZK
 
 #include <config.h>
 #include <stdio.h>
@@ -22,6 +84,36 @@
 #include <getopt.h>
 #include <selinux/selinux.h>
 
+// PZK >
+#include "mutil.h"
+#include "mkancesdirs.h"
+#include "savewd.h"
+#include <ctype.h>
+
+#if HAVE_LIBGCRYPT
+# include <gcrypt.h>
+# ifdef _OPENMP
+#  include <errno.h>
+#  include <pthread.h>
+GCRY_THREAD_OPTION_PTHREAD_IMPL;
+# endif
+#endif
+
+#if HAVE_LIBMPI && defined(_OPENMP)
+# include "mpi.h"
+#endif
+
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+# include <arpa/inet.h>
+# include <gnutls/gnutls.h>
+# include <netdb.h>
+# include <poll.h>
+# include <pthread.h>
+# include <pwd.h>
+# include <sys/socket.h>
+#endif
+// < PZK
+
 #include "system.h"
 #include "argmatch.h"
 #include "backupfile.h"
@@ -50,12 +142,43 @@
   while (0)
 
 /* The official name of this program (e.g., no 'g' prefix).  */
-#define PROGRAM_NAME "cp"
+// PZK >
+#define PROGRAM_NAME "mcp 1.822.5"
 
 #define AUTHORS \
   proper_name_utf8 ("Torbjorn Granlund", "Torbj\303\266rn Granlund"), \
   proper_name ("David MacKenzie"), \
-  proper_name ("Jim Meyering")
+  proper_name ("Jim Meyering"), \
+  proper_name ("Paul Kolano")
+
+#ifndef DEFAULT_BUFFER_SIZE
+# define DEFAULT_BUFFER_SIZE 4
+#endif
+#ifndef DEFAULT_DIRECT_READ
+# define DEFAULT_DIRECT_READ 0
+#endif
+#ifndef DEFAULT_DIRECT_WRITE
+# define DEFAULT_DIRECT_WRITE 0
+#endif
+#ifndef DEFAULT_DOUBLE_BUFFER
+# define DEFAULT_DOUBLE_BUFFER 0
+#endif
+#ifndef DEFAULT_FADVISE_READ
+# define DEFAULT_FADVISE_READ 0
+#endif
+#ifndef DEFAULT_FADVISE_WRITE
+# define DEFAULT_FADVISE_WRITE 0
+#endif
+#if !defined(DEFAULT_HASH_TYPE) && HAVE_LIBGCRYPT
+# define DEFAULT_HASH_TYPE GCRY_MD_MD5
+#endif
+#ifndef DEFAULT_SPLIT_SIZE
+# define DEFAULT_SPLIT_SIZE 0
+#endif
+#ifndef DEFAULT_THREADS
+# define DEFAULT_THREADS 4
+#endif
+// < PZK
 
 /* Used by do_copy, make_dir_parents_private, and re_protect
    to keep a list of leading directories whose protections
@@ -73,6 +196,54 @@ struct dir_attr
 enum
 {
   ATTRIBUTES_ONLY_OPTION = CHAR_MAX + 1,
+// PZK >
+  BUFFER_SIZE_OPTION,
+  DIRECT_READ_OPTION,
+  DIRECT_WRITE_OPTION,
+  DOUBLE_BUFFER_OPTION,
+  DST_OFFSET_OPTION,
+  LENGTH_OPTION,
+  NO_DIRECT_READ_OPTION,
+  NO_DIRECT_WRITE_OPTION,
+  NO_DOUBLE_BUFFER_OPTION,
+  OFFSET_OPTION,
+  READ_STDIN_OPTION,
+  SKIP_CHMOD_OPTION,
+#ifdef POSIX_FADV_DONTNEED
+  FADVISE_READ_OPTION,
+  FADVISE_WRITE_OPTION,
+  NO_FADVISE_READ_OPTION,
+  NO_FADVISE_WRITE_OPTION,
+#endif
+#ifdef __linux__
+  PREALLOCATE_OPTION,
+#endif
+#ifdef _OPENMP
+  PRINT_SRC_OPTION,
+  PRINT_STATS_OPTION,
+  SPLIT_SIZE_OPTION,
+  THREADS_OPTION,
+#endif
+#if HAVE_LIBLUSTREAPI
+  PRINT_STRIPE_OPTION,
+  STRIPE_COUNT_OPTION,
+#endif
+#if HAVE_LIBGCRYPT
+  CHECK_TREE_OPTION,
+  HASH_LEAF_SIZE_OPTION,
+  HASH_TYPE_OPTION,
+  PRINT_HASH_OPTION,
+#endif
+#if HAVE_LIBMPI && defined(_OPENMP)
+  MPI_OPTION,
+#endif
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+  LISTEN_PORT_OPTION,
+  MANAGER_HOST_OPTION,
+  MANAGER_PORT_OPTION,
+  PASSWORD_FILE_OPTION,
+#endif
+// < PZK
   COPY_CONTENTS_OPTION,
   NO_PRESERVE_ATTRIBUTES_OPTION,
   PARENTS_OPTION,
@@ -115,6 +286,54 @@ ARGMATCH_VERIFY (reflink_type_string, re
 
 static struct option const long_opts[] =
 {
+// PZK >
+  {"buffer-size", required_argument, NULL, BUFFER_SIZE_OPTION},
+  {"direct-read", no_argument, NULL, DIRECT_READ_OPTION},
+  {"direct-write", no_argument, NULL, DIRECT_WRITE_OPTION},
+  {"double-buffer", no_argument, NULL, DOUBLE_BUFFER_OPTION},
+  {"dst-offset", required_argument, NULL, DST_OFFSET_OPTION},
+  {"length", required_argument, NULL, LENGTH_OPTION},
+  {"no-direct-read", no_argument, NULL, NO_DIRECT_READ_OPTION},
+  {"no-direct-write", no_argument, NULL, NO_DIRECT_WRITE_OPTION},
+  {"no-double-buffer", no_argument, NULL, NO_DOUBLE_BUFFER_OPTION},
+  {"offset", required_argument, NULL, OFFSET_OPTION},
+  {"read-stdin", no_argument, NULL, READ_STDIN_OPTION},
+  {"skip-chmod", no_argument, NULL, SKIP_CHMOD_OPTION},
+#ifdef POSIX_FADV_DONTNEED
+  {"fadvise-read", no_argument, NULL, FADVISE_READ_OPTION},
+  {"fadvise-write", no_argument, NULL, FADVISE_WRITE_OPTION},
+  {"no-fadvise-read", no_argument, NULL, NO_FADVISE_READ_OPTION},
+  {"no-fadvise-write", no_argument, NULL, NO_FADVISE_WRITE_OPTION},
+#endif
+#ifdef __linux__
+  {"preallocate", required_argument, NULL, PREALLOCATE_OPTION},
+#endif
+#ifdef _OPENMP
+  {"print-src", no_argument, NULL, PRINT_SRC_OPTION},
+  {"print-stats", no_argument, NULL, PRINT_STATS_OPTION},
+  {"split-size", required_argument, NULL, SPLIT_SIZE_OPTION},
+  {"threads", required_argument, NULL, THREADS_OPTION},
+#endif
+#if HAVE_LIBLUSTREAPI
+  {"print-stripe", no_argument, NULL, PRINT_STRIPE_OPTION},
+  {"stripe-count", required_argument, NULL, STRIPE_COUNT_OPTION},
+#endif
+#if HAVE_LIBGCRYPT
+  {"check-tree", no_argument, NULL, CHECK_TREE_OPTION},
+  {"hash-leaf-size", required_argument, NULL, HASH_LEAF_SIZE_OPTION},
+  {"hash-type", required_argument, NULL, HASH_TYPE_OPTION},
+  {"print-hash", no_argument, NULL, PRINT_HASH_OPTION},
+#endif
+#if HAVE_LIBMPI && defined(_OPENMP)
+  {"mpi", no_argument, NULL, MPI_OPTION},
+#endif
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+  {"listen-port", required_argument, NULL, LISTEN_PORT_OPTION},
+  {"manager-host", required_argument, NULL, MANAGER_HOST_OPTION},
+  {"manager-port", required_argument, NULL, MANAGER_PORT_OPTION},
+  {"password-file", required_argument, NULL, PASSWORD_FILE_OPTION},
+#endif
+// < PZK
   {"archive", no_argument, NULL, 'a'},
   {"attributes-only", no_argument, NULL, ATTRIBUTES_ONLY_OPTION},
   {"backup", optional_argument, NULL, 'b'},
@@ -166,6 +385,176 @@ Copy SOURCE to DEST, or multiple SOURCE(
 
       emit_mandatory_arg_note ();
 
+// PZK >
+      fputs (_("Mcp-specific options (defaults in brackets):\n"), stdout);
+      fprintf (stdout, _("\
+      --buffer-size=MBYTES     read/write buffer size [%d]\n"),
+        DEFAULT_BUFFER_SIZE);
+#if HAVE_LIBGCRYPT
+      fputs (_("\
+      --check-tree             print hash subtrees to pinpoint corruption\n\
+"), stdout);
+#endif
+#if !DEFAULT_DIRECT_READ
+      fputs (_("\
+      --direct-read            enable use of direct I/O for reads\n\
+"), stdout);
+#endif
+#if !DEFAULT_DIRECT_WRITE
+      fputs (_("\
+      --direct-write           enable use of direct I/O for writes\n\
+"), stdout);
+#endif
+#if !DEFAULT_DOUBLE_BUFFER
+      fputs (_("\
+      --double-buffer          enable use of double buffering during file I/O\n\
+"), stdout);
+#endif
+      fputs (_("\
+      --dst-offset=POS         copy to destination file beginning at POS\n\
+"), stdout);
+#ifdef POSIX_FADV_DONTNEED
+# if !DEFAULT_FADVISE_READ
+      fputs (_("\
+      --fadvise-read           enable use of posix_fadvise during reads\n\
+"), stdout);
+# endif
+# if !DEFAULT_FADVISE_WRITE
+      fputs (_("\
+      --fadvise-write          enable use of posix_fadvise during writes\n\
+"), stdout);
+# endif
+#endif
+#if HAVE_LIBGCRYPT
+      fprintf (stdout, _("\
+      --hash-leaf-size=KBYTES  granularity of hash tree [%d]\n\
+      --hash-type=TYPE         hash type [%s], with TYPE one of:\n\
+                                 "),
+        DEFAULT_SPLIT_SIZE * 1024, gcry_md_algo_name(DEFAULT_HASH_TYPE));
+      int n = 33;
+      // 400 taken from libgcrypt benchmark code
+      for (int i = 1; i < 400; i++) {
+        if (gcry_md_test_algo(i)) continue;
+        const char *name = gcry_md_algo_name(i);
+        if (n + strlen(name) > 78) {
+            fputs (_("\n                                 "), stdout);
+            n = 33;
+        }
+        n += strlen(name);
+        while (*name) fputc(tolower(*name++), stdout);
+        fputc(' ', stdout);
+      }
+      fputs(_("\n"), stdout);
+#endif
+      fputs (_("\
+      --length=LEN             copy LEN bytes beginning at --offset\n\
+                                 (or from 0 if --offset not specified)\n\
+"), stdout);
+#if HAVE_LIBGNUTLS
+      fputs (_("\
+      --listen-port=PORT       listen on port PORT for requests from\n\
+                                 cooperating hosts\n\
+      --manager-host=HOST      host name or IP address of management thread\n\
+                                 for multi-node/multi-host copies\n\
+      --manager-port=PORT      port on which to contact management thread\n\
+"), stdout);
+#endif
+#if HAVE_LIBMPI && defined(_OPENMP)
+      fputs (_("\
+      --mpi                    enable use of MPI for multi-node copies\n\
+"), stdout);
+#endif
+#if DEFAULT_DIRECT_READ
+      fputs (_("\
+      --no-direct-read         disable use of direct I/O for reads\n\
+"), stdout);
+#endif
+#if DEFAULT_DIRECT_WRITE
+      fputs (_("\
+      --no-direct-write        disable use of direct I/O for writes\n\
+"), stdout);
+#endif
+#if DEFAULT_DOUBLE_BUFFER
+      fputs (_("\
+      --no-double-buffer       disable use of double buffering during file I/O\n\
+"), stdout);
+#endif
+#ifdef POSIX_FADV_DONTNEED
+# if DEFAULT_FADVISE_READ
+      fputs (_("\
+      --no-fadvise-read        disable use of posix_fadvise during reads\n\
+"), stdout);
+# endif
+# if DEFAULT_FADVISE_WRITE
+      fputs (_("\
+      --no-fadvise-write       disable use of posix_fadvise during writes\n\
+"), stdout);
+# endif
+#endif
+      fputs (_("\
+      --offset=POS             copy --length bytes beginning at POS\n\
+                                 (or to end if --length not specified)\n\
+"), stdout);
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+      fputs (_("\
+      --password-file=FILE     file to use for passwords (will be created\n\
+                                 if does not exist)\n\
+"), stdout);
+#endif
+#ifdef __linux__
+      fputs (_("\
+      --preallocate=PCT        preallocate dst when sparsity under PCT percent\n\
+"), stdout);
+#endif
+#if HAVE_LIBGCRYPT
+      fputs (_("\
+      --print-hash             print hash of each file to stdout similar to\n\
+                                 md5sum, with sum of the src file computed,\n\
+                                 but dst file name printed so that md5sum -c\n\
+                                 can be used on the output to check that the\n\
+                                 data written to disk was what was read\n\
+"), stdout);
+#endif
+#ifdef _OPENMP
+      fputs (_("\
+      --print-src              print src instead of dst in --print-{hash,stats}\n\
+      --print-stats            print performance per file to stderr\n\
+"), stdout);
+#endif
+#if HAVE_LIBLUSTREAPI
+      fputs (_("\
+      --print-stripe           print striping changes to stderr\n\
+"), stdout);
+#endif
+#ifdef _OPENMP
+      fputs (_("\
+      --read-stdin             perform a batch of operations read over stdin\n\
+                                 in the form 'SRC DST RANGES' where SRC and DST\n\
+                                 must be URI-escaped (RFC 3986) file names and\n\
+                                 RANGES is zero or more comma-separated ranges of\n\
+                                 the form 'START-END' for 0 <= START < END\n\
+      --skip-chmod             retain temporary permissions used during copy\n\
+"), stdout);
+      fprintf (stdout, _("\
+      --split-size=MBYTES      size to split files for parallelization [%d]\n\
+"), DEFAULT_SPLIT_SIZE);
+#if HAVE_LIBLUSTREAPI
+      fputs (_("\
+      --stripe-count=COUNT     absolute number of stripes, stripes per src GBs\n\
+                                 when followed by 's', or stripes per --length\n\
+                                 GBs when followed by 'l' [1s]\n\
+"), stdout);
+#endif
+      fprintf (stdout, _("\
+      --threads=NUMBER         number of OpenMP worker threads to use [%d]\n\
+\n\
+"), DEFAULT_THREADS);
+#endif
+      fputs (_("\
+Standard options (mandatory arguments to long options are mandatory\n\
+                  for short options too):\n\
+"), stdout);
+// < PZK
       fputs (_("\
   -a, --archive                same as -dR --preserve=all\n\
       --attributes-only        don't copy the file data, just the attributes\n\
@@ -578,6 +967,134 @@ target_directory_operand (char const *fi
   return is_a_dir;
 }
 
+// PZK >
+void print_hash(const struct cp_options *x, copy_reg_t *crt)
+{
+    size_t i;
+    char *file = x->print_src ? crt->src_name : crt->dst_name;
+
+    // put non-standard output in comments
+    if (crt->nsplits > 1 || crt->partial) {
+        printf("#mutil#");
+        if (crt->partial)
+            printf("%lld-%lld", crt->start_offset, crt->stop_offset);
+        printf("#");
+    }
+
+    /* Output a leading backslash if the file name contains
+       a newline or backslash.  */
+    if (strchr(file, '\n') || strchr(file, '\\'))
+        putchar ('\\');
+
+    size_t bytes = x->hash_size;
+    if (x->check_tree) bytes *= crt->nsplits;
+
+    for (size_t i = 0; i < bytes; ++i)
+        printf ("%02x", crt->hash_stack[i]);
+
+    putchar (' ');
+/*TODO: do something with this binary stuff
+    if (file_is_binary)
+      putchar ('*');
+    else
+*/
+      putchar (' ');
+
+    /* Translate each NEWLINE byte to the string, "\\n",
+       and each backslash to "\\\\".  */
+    for (i = 0; i < strlen(file); ++i) {
+        switch (file[i]) {
+        case '\n':
+            fputs("\\n", stdout);
+            break;
+        case '\\':
+            fputs("\\\\", stdout);
+            break;
+        default:
+            putchar(file[i]);
+            break;
+        }
+    }
+    putchar ('\n');
+}
+
+/* Make ancestor directory DIR, whose last file name component is
+   COMPONENT, with options OPTIONS.  Assume the working directory is
+   COMPONENT's parent.  */
+
+static int
+make_ancestor (char const *dir, char const *component, void *options)
+{
+  return mkdir (component, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
+}
+
+/* unescape() based on curl_easy_escape() to which the following applies
+COPYRIGHT AND PERMISSION NOTICE
+
+Copyright (c) 1996 - 2009, Daniel Stenberg, <daniel@haxx.se>.
+
+All rights reserved.
+
+Permission to use, copy, modify, and distribute this software for any purpose
+with or without fee is hereby granted, provided that the above copyright
+notice and this permission notice appear in all copies.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN
+NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
+OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of a copyright holder shall not
+be used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization of the copyright holder.
+*/
+
+/*
+ * Unescapes the given URL escaped string of given length. Returns a
+ * pointer to a malloced string.
+ * If length == 0, the length is assumed to be strlen(string).
+ */
+char *unescape(const char *string, int length)
+{
+  int alloc = (length?length:(int)strlen(string))+1;
+  char *ns = xmalloc(alloc);
+  unsigned char in;
+  int strindex=0;
+  long hex;
+
+  if( !ns )
+    return NULL;
+
+  while(--alloc > 0) {
+    in = *string;
+    if(('%' == in) && isxdigit(string[1]) && isxdigit(string[2])) {
+      /* this is two hexadecimal digits following a '%' */
+      char hexstr[3];
+      char *ptr;
+      hexstr[0] = string[1];
+      hexstr[1] = string[2];
+      hexstr[2] = 0;
+
+      hex = strtol(hexstr, &ptr, 16);
+
+      in = (unsigned char)hex; /* this long is never bigger than 255 anyway */
+
+      string+=2;
+      alloc-=2;
+    }
+
+    ns[strindex++] = in;
+    string++;
+  }
+  ns[strindex]=0; /* terminate it */
+
+  return ns;
+}
+// < PZK
+
 /* Scan the arguments, and copy each by calling copy.
    Return true if successful.  */
 
@@ -589,7 +1106,9 @@ do_copy (int n_files, char **file, const
   bool new_dst = false;
   bool ok = true;
 
-  if (n_files <= !target_directory)
+// PZK >
+  if (!x->mgr_port && !x->read_stdin && n_files <= !target_directory)
+// < PZK
     {
       if (n_files <= 0)
         error (0, 0, _("missing file operand"));
@@ -599,7 +1118,9 @@ do_copy (int n_files, char **file, const
       usage (EXIT_FAILURE);
     }
 
-  if (no_target_directory)
+// PZK >
+  if (!x->mgr_port && !x->read_stdin && no_target_directory)
+// < PZK
     {
       if (target_directory)
         error (EXIT_FAILURE, 0,
@@ -613,7 +1134,9 @@ do_copy (int n_files, char **file, const
       /* Update NEW_DST and SB, which may be checked below.  */
       ignore_value (target_directory_operand (file[n_files -1], &sb, &new_dst));
     }
-  else if (!target_directory)
+// PZK >
+  else if (!x->mgr_port && !x->read_stdin && !target_directory)
+// < PZK
     {
       if (2 <= n_files
           && target_directory_operand (file[n_files - 1], &sb, &new_dst))
@@ -623,6 +1146,757 @@ do_copy (int n_files, char **file, const
                quote (file[n_files - 1]));
     }
 
+// PZK >
+#ifdef _OPENMP
+  int pid = 0, procs = 1;
+  int hash_stat_done = 1;
+  int main_done = 0;
+# if HAVE_LIBMPI
+  if (x->mpi) {
+    MPI_Init(NULL, NULL);
+    MPI_Comm_rank(MPI_COMM_WORLD, &pid);
+    MPI_Comm_size(MPI_COMM_WORLD, &procs);
+    // add a thread for MPI handler on main node
+    if (pid == 0) x->threads++;
+  }
+# endif
+  // add a thread for TCP handler on main node
+  if (x->listen_port) x->threads++;
+  // add a thread for file/TCP-MPI handler on main/other nodes
+  x->threads++;
+  // add a thread for stat/hash handler on main node
+  if (!x->mgr_port && pid == 0 && (x->print_stats || x->print_hash)) {
+    x->threads++;
+    hash_stat_done = 0;
+  }
+
+  omp_set_num_threads(x->threads);
+  bool oks[x->threads];
+  sem_q_t task_q;
+  sem_q_init(&task_q, x->threads, sizeof(copy_reg_t));
+  x->task_q = &task_q;
+  sem_q_t open_q;
+  sem_q_init(&open_q, x->threads, sizeof(void *));
+  x->open_q = &open_q;
+  sem_q_t send_q;
+  sem_q_init(&send_q, x->threads, sizeof(void *));
+  x->send_q = &send_q;
+
+# if HAVE_LIBGCRYPT
+  gcry_control(GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);
+  if (!gcry_check_version(GCRYPT_VERSION))
+    error (EXIT_FAILURE, 0, _("libgcrypt version mismatch"));
+  gcry_control(GCRYCTL_DISABLE_SECMEM, 0);
+  gcry_control(GCRYCTL_ENABLE_M_GUARD, 0);
+  gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);
+# endif
+# if HAVE_LIBGNUTLS
+  if (x->listen_port || x->mgr_port) {
+    gnutls_global_init();
+  }
+# endif
+
+# pragma omp parallel
+{
+  int tid = omp_get_thread_num();
+  oks[tid] = true;
+  if (!x->mgr_port && pid == 0 && tid == 2 &&
+        (x->print_stats || x->print_hash)) {
+    ////////////////////////////////////
+    // stat/hash handler on main node //
+    ////////////////////////////////////
+    struct timespec tts[2];
+    if (x->print_stats) {
+      fprintf(stderr, _("      size        rd_mbs  wt_mbs  cp_mbs  %s\n"),
+        x->print_src ? "src" : "dst");
+      fprintf(stderr, _("      ----        ------  ------  ------  ---\n"));
+      clock_gettime(0, &tts[0]);
+    }
+    off_t tsize = 0;
+    int maxcrts = 128;
+    copy_reg_t **crts = xcalloc(maxcrts, sizeof(copy_reg_t *));
+    int ncrts = 0;
+    long long done_tasks = 0;
+    while (!main_done || *x->hash_stat_tasks > done_tasks) {
+      copy_reg_t *crt = sem_q_pop(&send_q);
+      if (crt != NULL && crt->split != crt->nsplits) done_tasks++;
+      if (crt == NULL || crt->dst_name == NULL) {
+        //TODO: do something with error?
+        continue;
+      }
+      if (x->print_stats && crt->split != crt->nsplits) {
+        tsize += crt->stop_offset - crt->start_offset;
+        double mb = (crt->stop_offset - crt->start_offset) / 1000.0 / 1000.0;
+        fprintf(stderr, _("%16lld  %6.1f  %6.1f  %6.1f  %s"),
+            crt->stop_offset - crt->start_offset, mb / crt->read_time,
+            mb / crt->write_time, mb / crt->copy_time,
+            x->print_src ? crt->src_name : crt->dst_name);
+        if (crt->nsplits > 1)
+            fprintf(stderr, _(" (%lu/%lu)"), crt->split + 1, crt->nsplits);
+        fprintf(stderr, _("\n"));
+      }
+
+      if (x->print_hash && crt->nsplits == 1) {
+        print_hash(x, crt);
+      }
+
+      if (!x->print_hash || crt->nsplits <= 1) {
+        free(crt->src_name);
+        free(crt->dst_name);
+        free(crt->hash_stack);
+        free(crt);
+        continue;
+      }
+
+      int index;
+      int empty = -1;
+      // find existing entry and/or free slot
+      for (index = 0; index < maxcrts; index++) {
+          if (crts[index] == NULL) {
+              if (empty < 0) empty = index;
+              continue;
+          }
+          if (!strcmp(crt->dst_name, crts[index]->dst_name) &&
+              crt->orig_offset == crts[index]->orig_offset) break;
+      }
+      if (index >= maxcrts) {
+          // this is the first split received
+          if (empty == -1) {
+              // no free slot found so expand array
+              maxcrts *= 2;
+              //TODO: should probably error out if array gets too big
+              xrealloc(crts, maxcrts * sizeof(copy_reg_t *));
+              bzero(&crts[maxcrts / 2], maxcrts / 2 * sizeof(copy_reg_t *));
+              empty = index;
+          }
+          // first crt has special field values including
+          //   split = nsplits, stop_offset = file size,
+          //   dst_fd = open fd, and hash_stack of size nsplits * hash size
+          crts[empty] = crt;
+      } else {
+# if HAVE_LIBGCRYPT
+        // copy final hash onto shared hash stack
+        memcpy(&crts[index]->hash_stack[crt->split * x->hash_size],
+            crt->hash_stack, x->hash_size);
+        free(crt->hash_stack);
+# endif
+        free(crt->src_name);
+        free(crt->dst_name);
+        free(crt);
+        crt = crts[index];
+        // this works because split will be nsplits in first crt received
+        if (--crt->split == 0) {
+# if HAVE_LIBGCRYPT
+            // finalize hash if last
+            gcry_md_hd_t ctx;
+            gcry_md_open(&ctx, x->hash_type, 0);
+            hash_tree_t htt;
+            htt.total_n_hash = 0;
+            htt.hash_ctx = &ctx;
+            htt.hash_ctx_len = 0;
+            htt.stack_len = 0;
+            // don't compute root of tree when printing subtrees
+            if (!x->check_tree) hash_final(&htt, crt, x, 0, crt->nsplits);
+            // print hash
+            if (x->print_hash) {
+                print_hash(x, crt);
+            }
+            // clean up
+            gcry_md_close(ctx);
+            free(crt->hash_stack);
+# endif
+            free(crt->src_name);
+            free(crt->dst_name);
+            free(crt);
+            crts[index] = NULL;
+            //TODO: if last, then set done for tcp, etc.
+        }
+      }
+    }
+    if (x->print_stats) {
+        clock_gettime(0, &tts[1]);
+        double tt = (double) (
+            (double) tts[1].tv_sec + (double) tts[1].tv_nsec / (double) 1.0e9 -
+            (double) tts[0].tv_sec - (double) tts[0].tv_nsec / (double) 1.0e9);
+        double mb = tsize / 1000.0 / 1000.0;
+        fprintf(stderr, _("      ----        ------  ------  ------  ----\n"));
+        fprintf(stderr, _("%16lld                  %6.1f  total\n"),
+            tsize, mb / tt);
+    }
+    hash_stat_done = 1;
+# if HAVE_LIBMPI
+    if (x->mpi) {
+        // send message to MPI handler on main node to break out of
+        // a final receive called just before hash_stat_done is set
+        long long sz = -1;
+        MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+    }
+# endif
+# if HAVE_LIBGNUTLS
+  } else if (x->mgr_port && tid == 0) {
+    ////////////////////////////////
+    // TCP handler on other nodes //
+    ////////////////////////////////
+    // initialize tls/srp
+    gnutls_session_t tls_sess;
+    gnutls_srp_client_credentials_t srp_cred;
+    gnutls_srp_allocate_client_credentials(&srp_cred);
+    gnutls_srp_set_client_credentials(srp_cred, x->user, x->pass);
+
+    int nulls = 0;
+    int null_task = 0;
+    int nonnull_task = 0;
+
+    while (nulls < x->threads - 1) {
+      copy_reg_t *crt = sem_q_pop(&send_q);
+      if (crt == NULL && null_task) {
+        nulls++;
+        sem_q_push(&task_q, NULL);
+        continue;
+      } else if (crt != NULL) {
+        nonnull_task = 1;
+      }
+
+      int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+      if (sock < 0)
+        error(EXIT_FAILURE, 0, _("unable to create socket"));
+
+      size_t src_size = 0, dst_size;
+      ssize_t rc = connect(sock, x->mgr_ai->ai_addr, sizeof(struct sockaddr_in));
+      if (!rc) {
+        // initialize tls session
+        gnutls_init(&tls_sess, GNUTLS_CLIENT);
+        gnutls_priority_set_direct(tls_sess, "NORMAL:+SRP", NULL);
+        gnutls_credentials_set(tls_sess, GNUTLS_CRD_SRP, srp_cred);
+        gnutls_transport_set_ptr(tls_sess,
+            (gnutls_transport_ptr_t)(uintptr_t) sock);
+        if (gnutls_handshake(tls_sess) < 0) {
+            error(0, 0, _("unable to authenticate to server"));
+            //TODO: can this cause deadlocK?
+            sem_q_push(&send_q, crt);
+            continue;
+        }
+      } else {
+        if (nonnull_task) {
+            nulls++;
+            sem_q_push(&task_q, NULL);
+            continue;
+        }
+        error(0, errno, _("connect failed...sleeping"));
+        fflush(stderr);
+        // wait until server starts
+        sleep(1);
+        //TODO: can this cause deadlocK?
+        sem_q_push(&send_q, crt);
+        // probably want some check so don't loop forever
+        continue;
+      }
+
+      if (crt != NULL) {
+        // send final status with times and hash
+        src_size = strlen(crt->src_name) + 1;
+        dst_size = strlen(crt->dst_name) + 1;
+        rc |= gnutls_record_send(tls_sess, &src_size, sizeof(src_size));
+        rc |= gnutls_record_send(tls_sess, &dst_size, sizeof(dst_size));
+        rc |= gnutls_record_send(tls_sess, crt->src_name, src_size);
+        rc |= gnutls_record_send(tls_sess, crt->dst_name, dst_size);
+        rc |= gnutls_record_send(tls_sess, crt->hash_stack, x->hash_size);
+        rc |= gnutls_record_send(tls_sess, crt, sizeof(copy_reg_t));
+        if (rc < 0)
+            error(0, 0, _("unable to send final status to server"));
+            //TODO: do something else like requeue crt?
+        free(crt->src_name);
+        free(crt->dst_name);
+        free(crt->hash_stack);
+        free(crt);
+      } else {
+        // send task request
+        src_size = 0;
+        rc |= gnutls_record_send(tls_sess, &src_size, sizeof(src_size));
+
+        // receive task request
+        rc |= gnutls_record_recv(tls_sess, &src_size, sizeof(src_size));
+        if (rc < 0 || src_size == 0) {
+          null_task = 1;
+          nulls++;
+          sem_q_push(&task_q, NULL);
+        } else {
+          rc |= gnutls_record_recv(tls_sess, &dst_size, sizeof(dst_size));
+          if (rc > 0) {
+              char *src_tmp = xmalloc(src_size);
+              char *dst_tmp = xmalloc(dst_size);
+              crt = xmalloc(sizeof(copy_reg_t));
+              rc |= gnutls_record_recv(tls_sess, src_tmp, src_size);
+              rc |= gnutls_record_recv(tls_sess, dst_tmp, dst_size);
+              rc |= gnutls_record_recv(tls_sess, crt, sizeof(copy_reg_t));
+              //TODO: this section still needs work??
+              if (rc > 0) {
+                  crt->src_name = src_tmp;
+                  crt->dst_name = dst_tmp;
+                  crt->hash_stack = xmalloc(x->hash_size);
+                  sem_q_push(&task_q, crt);
+                  sem_q_pop(&open_q);
+                  if (gnutls_record_send(tls_sess, &rc, sizeof(rc)) <= 0)
+                      error(EXIT_FAILURE, 0,
+                          _("unable to send open status to server"));
+              } else {
+                  free(src_tmp);
+                  free(dst_tmp);
+                  free(crt);
+              }
+          }
+        }
+      }
+      if (rc >= 0 || src_size > 0) {
+        // shutdown tls session
+        gnutls_bye(tls_sess, GNUTLS_SHUT_RDWR);
+        shutdown(sock, SHUT_RDWR);
+        gnutls_deinit(tls_sess);
+      }
+    }
+    // free tls/srp resources
+    gnutls_srp_free_client_credentials(srp_cred);
+    gnutls_global_deinit();
+  } else if (x->listen_port && tid == 1) {
+    //////////////////////////////
+    // TCP handler on main node //
+    //////////////////////////////
+    // initialize tls/srp
+    gnutls_srp_server_credentials_t srp_cred;
+    gnutls_srp_allocate_server_credentials(&srp_cred);
+    gnutls_srp_set_server_credentials_file(srp_cred, x->pw_file, x->mg_file);
+
+    int server_sock, client_sock;
+    struct sockaddr_in server_sa, client_sa;
+    socklen_t client_len = sizeof(client_sa);
+
+    server_sa.sin_family = AF_INET;
+    server_sa.sin_addr.s_addr = htonl(INADDR_ANY);
+    server_sa.sin_port = htons(x->listen_port);
+
+    server_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+    if (server_sock < 0)
+        error(EXIT_FAILURE, 0, _("unable to create socket"));
+    if (fcntl(server_sock, F_SETFL, O_NONBLOCK) < 0)
+        error(EXIT_FAILURE, 0, _("unable to set socket option"));
+    if (bind(server_sock, (struct sockaddr *) &server_sa, sizeof(server_sa)) < 0)
+        error(EXIT_FAILURE, 0, _("unable to bind to socket"));
+    if (listen(server_sock, SOMAXCONN) < 0)
+        error(EXIT_FAILURE, 0, _("unable to listen on socket"));
+
+    struct pollfd sfds[1];
+    sfds[0].fd = server_sock;
+    sfds[0].events = POLLIN;
+
+    int null_task = 0;
+
+    while (!main_done || !hash_stat_done) {
+        if (poll(sfds, 1, 1000) <= 0) continue;
+
+        gnutls_session_t tls_sess;
+        gnutls_init(&tls_sess, GNUTLS_SERVER);
+        gnutls_priority_set_direct(tls_sess, "NORMAL:+SRP", NULL);
+        gnutls_credentials_set(tls_sess, GNUTLS_CRD_SRP, srp_cred);
+
+        client_sock =
+            accept(server_sock, (struct sockaddr *) &client_sa, &client_len);
+        if (client_sock < 0) continue;
+        gnutls_transport_set_ptr(tls_sess,
+            (gnutls_transport_ptr_t)(uintptr_t) client_sock);
+        if (gnutls_handshake(tls_sess) < 0) {
+            close(client_sock);
+            gnutls_deinit(tls_sess);
+            error(0, 0, _("warning: failed authentication attempt from %s:%d"),
+                inet_ntoa(client_sa.sin_addr), ntohs(client_sa.sin_port));
+            continue;
+        }
+
+        size_t src_size, dst_size;
+        ssize_t rc = 0;
+        copy_reg_t *crt;
+        //TODO: need timeouts throughout here
+        if (gnutls_record_recv(tls_sess, &src_size, sizeof(src_size)) < 0) continue;
+        if (src_size > 0) {
+          if (gnutls_record_recv(tls_sess, &dst_size, sizeof(dst_size)) > 0) {
+              char *src_tmp = xmalloc(src_size);
+              char *dst_tmp = xmalloc(dst_size);
+              unsigned char *hash_tmp = xmalloc(x->hash_size);
+              crt = xmalloc(sizeof(copy_reg_t));
+              rc |= gnutls_record_recv(tls_sess, src_tmp, src_size);
+              rc |= gnutls_record_recv(tls_sess, dst_tmp, dst_size);
+              rc |= gnutls_record_recv(tls_sess, hash_tmp, x->hash_size);
+              rc |= gnutls_record_recv(tls_sess, crt, sizeof(copy_reg_t));
+              //TODO: this section still needs work??
+              if (rc > 0) {
+                  crt->src_name = src_tmp;
+                  crt->dst_name = dst_tmp;
+                  crt->hash_stack = hash_tmp;
+                  sem_q_push(&send_q, crt);
+              } else {
+                  free(src_tmp);
+                  free(dst_tmp);
+                  free(hash_tmp);
+                  crt->dst_name = NULL;
+                  // indicate error with null dst
+                  sem_q_push(&send_q, crt);
+                  //TODO: see if this technique can be used elsewhere
+              }
+          }
+        } else {
+            crt = null_task ? NULL : sem_q_pop(&task_q);
+            if (crt == NULL) {
+                null_task = 1;
+                src_size = 0;
+                rc |= gnutls_record_send(tls_sess, &src_size, sizeof(src_size));
+            } else {
+                // this assumes same arch on client/server
+                src_size = strlen(crt->src_name) + 1;
+                dst_size = strlen(crt->dst_name) + 1;
+                rc |= gnutls_record_send(tls_sess, &src_size, sizeof(src_size));
+                rc |= gnutls_record_send(tls_sess, &dst_size, sizeof(dst_size));
+                rc |= gnutls_record_send(tls_sess, crt->src_name, src_size);
+                rc |= gnutls_record_send(tls_sess, crt->dst_name, dst_size);
+                rc |= gnutls_record_send(tls_sess, crt, sizeof(copy_reg_t));
+                if (rc <= 0) {
+                    sem_q_push(&task_q, crt);
+                    error(0, 0, _("warning: failure responding to client (will retry)"));
+                } else {
+                    // wait for message indicating open
+                    //TODO: need timeout here
+                    gnutls_record_recv(tls_sess, &rc, sizeof(rc));
+                    // indicate that file has been opened to local master
+                    sem_q_push(&open_q, NULL);
+                    free(crt->src_name);
+                    free(crt->dst_name);
+                    free(crt->hash_stack);
+                    free(crt);
+                }
+            }
+        }
+        gnutls_bye(tls_sess, GNUTLS_SHUT_WR);
+        close(client_sock);
+        gnutls_deinit(tls_sess);
+    }
+    close(server_sock);
+    gnutls_srp_free_server_credentials(srp_cred);
+    gnutls_global_deinit();
+# endif
+# if HAVE_LIBMPI
+  } else if (pid != 0 && tid == 0) {
+    ////////////////////////////////
+    // MPI handler on other nodes //
+    ////////////////////////////////
+    int nulls = 0;
+    int null_task = 0;
+    int nonnull_task = 0;
+
+    while (nulls < x->threads - 1) {
+      copy_reg_t *crt = sem_q_pop(&send_q);
+      if (crt == NULL && null_task) {
+          nulls++;
+          sem_q_push(&task_q, NULL);
+          continue;
+      } else if (crt != NULL) {
+          nonnull_task = 1;
+      }
+
+      size_t src_size, dst_size;
+      long long sz;
+      int pos = 0;
+
+      if (crt != NULL) {
+        // send final status with times and hash
+        src_size = strlen(crt->src_name) + 1;
+        dst_size = strlen(crt->dst_name) + 1;
+        sz = src_size + dst_size + x->hash_size + sizeof(copy_reg_t);
+        MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+
+        // pack crt into one big byte array
+        char pack[sz];
+        // this assumes same arch on client/server
+        MPI_Pack(&src_size, sizeof(src_size),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&dst_size, sizeof(dst_size),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(crt->src_name, src_size,
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(crt->dst_name, dst_size,
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        if (x->hash_size)
+            MPI_Pack(crt->hash_stack, x->hash_size,
+                MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->dst_mode, sizeof(crt->dst_mode),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->src_atime, sizeof(crt->src_atime),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->src_mtime, sizeof(crt->src_mtime),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->dst_blksize, sizeof(crt->dst_blksize),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->read_time, sizeof(crt->read_time),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->write_time, sizeof(crt->write_time),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->copy_time, sizeof(crt->copy_time),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->start_offset, sizeof(crt->start_offset),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->stop_offset, sizeof(crt->stop_offset),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->dst_offset, sizeof(crt->dst_offset),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->nsplits, sizeof(crt->nsplits),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->split, sizeof(crt->split),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+
+        MPI_Send(pack, pos, MPI_PACKED, 0, 1, MPI_COMM_WORLD);
+
+        free(crt->src_name);
+        free(crt->dst_name);
+        free(crt->hash_stack);
+        free(crt);
+      } else {
+        // send task request
+        sz = 0;
+        MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+
+        // receive task request
+        MPI_Status stat;
+        int rc = MPI_Recv(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD, &stat);
+        if (rc || sz == 0) {
+            null_task = 1;
+            nulls++;
+            sem_q_push(&task_q, NULL);
+        } else {
+            // unpack crt from one big byte array
+            char pack[sz];
+            MPI_Recv(pack, sz, MPI_PACKED, 0, 1, MPI_COMM_WORLD, &stat);
+            // this assumes same arch on client/server
+            MPI_Unpack(pack, sz, &pos, &src_size, sizeof(src_size),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &dst_size, sizeof(dst_size),
+                MPI_BYTE, MPI_COMM_WORLD);
+
+            crt = xmalloc(sizeof(copy_reg_t));
+            crt->src_name = xmalloc(src_size);
+            crt->dst_name = xmalloc(dst_size);
+            crt->hash_stack = xmalloc(x->hash_size);
+            MPI_Unpack(pack, sz, &pos, crt->src_name, src_size,
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, crt->dst_name, dst_size,
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->dst_mode, sizeof(crt->dst_mode),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->src_atime, sizeof(crt->src_atime),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->src_mtime, sizeof(crt->src_mtime),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->dst_blksize, sizeof(crt->dst_blksize),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->read_time, sizeof(crt->read_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->write_time, sizeof(crt->write_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->copy_time, sizeof(crt->copy_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->start_offset, sizeof(crt->start_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->stop_offset, sizeof(crt->stop_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->dst_offset, sizeof(crt->dst_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->nsplits, sizeof(crt->nsplits),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->split, sizeof(crt->split),
+                MPI_BYTE, MPI_COMM_WORLD);
+
+            sem_q_push(&task_q, crt);
+            sem_q_pop(&open_q);
+            sz = 0;
+            MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+        }
+      }
+    }
+  } else if (x->mpi && pid == 0 && tid == 1) {
+    //////////////////////////////
+    // MPI handler on main node //
+    //////////////////////////////
+    int null_task = 0;
+    MPI_Status stat;
+    long long sz;
+    int mpi_recv = 0;
+
+    while (!main_done || !hash_stat_done || x->mpi && mpi_recv < 2) {
+        if (MPI_Recv(&sz, 1, MPI_LONG_LONG, MPI_ANY_SOURCE, MPI_ANY_TAG,
+                MPI_COMM_WORLD, &stat)) break;
+
+        size_t src_size, dst_size;
+        copy_reg_t *crt;
+        int pos = 0;
+
+        if (sz > 0) {
+            // unpack crt from one big byte array
+            char pack[sz];
+            if (MPI_Recv(pack, sz, MPI_PACKED, stat.MPI_SOURCE,
+                    stat.MPI_TAG, MPI_COMM_WORLD, &stat)) continue;
+            // this assumes same arch on client/server
+            MPI_Unpack(pack, sz, &pos, &src_size, sizeof(src_size),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &dst_size, sizeof(dst_size),
+                MPI_BYTE, MPI_COMM_WORLD);
+
+            crt = xmalloc(sizeof(copy_reg_t));
+            crt->src_name = xmalloc(src_size);
+            crt->dst_name = xmalloc(dst_size);
+            crt->hash_stack = xmalloc(x->hash_size);
+            MPI_Unpack(pack, sz, &pos, crt->src_name, src_size,
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, crt->dst_name, dst_size,
+                MPI_BYTE, MPI_COMM_WORLD);
+            if (x->hash_size)
+                MPI_Unpack(pack, sz, &pos, crt->hash_stack, x->hash_size,
+                    MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->dst_mode, sizeof(crt->dst_mode),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->src_atime, sizeof(crt->src_atime),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->src_mtime, sizeof(crt->src_mtime),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->dst_blksize, sizeof(crt->dst_blksize),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->read_time, sizeof(crt->read_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->write_time, sizeof(crt->write_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->copy_time, sizeof(crt->copy_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->start_offset, sizeof(crt->start_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->stop_offset, sizeof(crt->stop_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->dst_offset, sizeof(crt->dst_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->nsplits, sizeof(crt->nsplits),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->split, sizeof(crt->split),
+                MPI_BYTE, MPI_COMM_WORLD);
+
+            sem_q_push(&send_q, crt);
+        } else if (sz == 0) {
+            crt = null_task ? NULL : sem_q_pop(&task_q);
+            if (crt == NULL) {
+                null_task = 1;
+                sz = 0;
+                MPI_Send(&sz, 1, MPI_LONG_LONG, stat.MPI_SOURCE,
+                    stat.MPI_TAG, MPI_COMM_WORLD);
+            } else {
+                src_size = strlen(crt->src_name) + 1;
+                dst_size = strlen(crt->dst_name) + 1;
+                sz = src_size + dst_size + sizeof(copy_reg_t);
+                MPI_Send(&sz, 1, MPI_LONG_LONG, stat.MPI_SOURCE,
+                    stat.MPI_TAG, MPI_COMM_WORLD);
+                // pack crt into one big byte array
+                char pack[sz];
+                // this assumes same arch on client/server
+                MPI_Pack(&src_size, sizeof(src_size),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&dst_size, sizeof(dst_size),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(crt->src_name, src_size,
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(crt->dst_name, dst_size,
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->dst_mode, sizeof(crt->dst_mode),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->src_atime, sizeof(crt->src_atime),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->src_mtime, sizeof(crt->src_mtime),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->dst_blksize, sizeof(crt->dst_blksize),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->read_time, sizeof(crt->read_time),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->write_time, sizeof(crt->write_time),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->copy_time, sizeof(crt->copy_time),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->start_offset, sizeof(crt->start_offset),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->stop_offset, sizeof(crt->stop_offset),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->dst_offset, sizeof(crt->dst_offset),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->nsplits, sizeof(crt->nsplits),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->split, sizeof(crt->split),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+
+                MPI_Send(pack, pos, MPI_PACKED, stat.MPI_SOURCE, stat.MPI_TAG,
+                    MPI_COMM_WORLD);
+                // wait for message indicating open
+                //TODO: need timeout here
+                MPI_Recv(&sz, 1, MPI_LONG_LONG, stat.MPI_SOURCE, stat.MPI_TAG,
+                    MPI_COMM_WORLD, &stat);
+                // indicate that file has been opened to local master
+                sem_q_push(&open_q, NULL);
+                free(crt->src_name);
+                free(crt->dst_name);
+                free(crt->hash_stack);
+                free(crt);
+            }
+        } else {
+            // main and hash/stat done message to prevent deadlock
+            mpi_recv++;
+        }
+    }
+# endif
+  } else if (tid != 0) {
+    ///////////////////////////////
+    // copy handler on all nodes //
+    ///////////////////////////////
+    // indicate ready for request on other nodes
+    if (x->mgr_port || pid != 0) sem_q_push(&send_q, NULL);
+    copy_reg_t *crt;
+    while ((crt = sem_q_pop(&task_q)) != NULL) {
+      crt->src_fd = open(crt->src_name, (O_RDONLY | O_BINARY | x->read_mode |
+          (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));
+      if (crt->src_fd < 0)
+        error(0, errno, _("warning: unable to open %s for read"), quote(crt->src_name));
+      crt->dst_fd = open(crt->dst_name, O_WRONLY | O_BINARY | x->write_mode);
+      if (crt->dst_fd < 0)
+        error(0, errno, _("warning: unable to open %s for write"), quote(crt->dst_name));
+      if (lseek(crt->src_fd, crt->start_offset, SEEK_SET) < 0)
+        error(0, errno, _("warning: unable to seek in %s"), quote(crt->src_name));
+      if (lseek(crt->dst_fd, crt->dst_offset, SEEK_SET) < 0)
+        error(0, errno, _("warning: unable to seek in %s"), quote(crt->dst_name));
+      //TODO: additional error handling if can't open or seek?
+      // indicate that file has been opened
+      sem_q_push(&open_q, NULL);
+      struct timespec ts[2];
+      if (x->print_stats) clock_gettime(0, &ts[0]);
+      oks[tid] &= copy_reg_task(crt, x);
+      if (x->print_stats) {
+        clock_gettime(0, &ts[1]);
+        crt->copy_time = (double) (
+          (double) ts[1].tv_sec + (double) ts[1].tv_nsec / (double) 1.0e9 -
+          (double) ts[0].tv_sec - (double) ts[0].tv_nsec / (double) 1.0e9);
+      }
+      if (x->print_stats || x->print_hash) {
+        sem_q_push(&send_q, crt);
+      } else {
+        free(crt->src_name);
+        free(crt->dst_name);
+        free(crt->hash_stack);
+        free(crt);
+      }
+      // indicate ready for request on other nodes
+      if (x->mgr_port || pid != 0) sem_q_push(&send_q, NULL);
+    }
+  } else {
+#endif
+// < PZK
+
   if (target_directory)
     {
       /* cp file1...filen edir
@@ -720,6 +1994,132 @@ do_copy (int n_files, char **file, const
           free (dst_name);
         }
     }
+// PZK >
+  else if (x->read_stdin)
+    {
+      char *buf = NULL;
+      size_t buf_max = 0;
+
+      char *new_dest;
+      char *source;
+      char *dest;
+      bool unused;
+
+      while (getline(&buf, &buf_max, stdin) > 0) {
+        buf[strcspn(buf, "\n")] = '\0';
+        size_t ifile2 = strcspn(buf, " ");
+        if (buf[ifile2] == '\0') continue;
+        buf[ifile2++] = '\0';
+        size_t irange = strcspn(&buf[ifile2], " ");
+        if (buf[ifile2 + irange] == '\0') {
+            irange = 0;
+        } else {
+            irange = ifile2 + irange;
+            buf[irange++] = '\0';
+        }
+        size_t idoff = strcspn(&buf[irange], " ");
+        if (!irange || buf[irange + idoff] == '\0') {
+            idoff = 0;
+        } else {
+            idoff = irange + idoff;
+            buf[idoff++] = '\0';
+        }
+        source = unescape(buf, 0);
+        dest = unescape(&buf[ifile2], 0);
+        if (source == NULL || dest == NULL) {
+            //TODO: error handling if can't unescape
+            continue;
+        }
+
+        /* When the force and backup options have been specified and
+           the source and destination are the same name for an existing
+           regular file, convert the user's command, e.g.,
+           `cp --force --backup foo foo' to `cp --force foo fooSUFFIX'
+           where SUFFIX is determined by any version control options used.  */
+
+        if (x->unlink_dest_after_failed_open
+            && x->backup_type != no_backups
+            && STREQ (source, dest)
+            && !new_dst && S_ISREG (sb.st_mode))
+          {
+            static struct cp_options x_tmp;
+
+            new_dest = find_backup_file_name (dest, x->backup_type);
+            /* Set x->backup_type to `no_backups' so that the normal backup
+               mechanism is not used when performing the actual copy.
+               backup_type must be set to `no_backups' only *after* the above
+               call to find_backup_file_name -- that function uses
+               backup_type to determine the suffix it applies.  */
+            x_tmp = *x;
+            x_tmp.backup_type = no_backups;
+            x = &x_tmp;
+          }
+        else
+          {
+            new_dest = dest;
+          }
+
+        bool save_working_directory =
+          ! (IS_ABSOLUTE_FILE_NAME (source) && IS_ABSOLUTE_FILE_NAME (new_dest));
+        int status = EXIT_SUCCESS;
+
+        struct savewd wd;
+        savewd_init (&wd);
+        if (! save_working_directory)
+            savewd_finish (&wd);
+
+        // PZK: save copy of dest as it is modified by mkancesdirs
+        char *save_dest = xstrdup(new_dest);
+        if (mkancesdirs (new_dest, &wd, make_ancestor, x) == -1)
+          {
+            // PZK: silently restore new_dest with error reported on original
+            free(dest);
+            dest = save_dest;
+            new_dest = save_dest;
+          } else {
+            free(save_dest);
+          }
+
+        if (save_working_directory)
+          {
+            int restore_result = savewd_restore (&wd, status);
+            int restore_errno = errno;
+            savewd_finish (&wd);
+            if (EXIT_SUCCESS < restore_result)
+                //TODO: error handling?
+                continue;
+            if (restore_result < 0 && status == EXIT_SUCCESS)
+              {
+                error (0, restore_errno, _("cannot create directory %s"), new_dest);
+                //TODO: error handling?
+                continue;
+              }
+          }
+
+        if (irange > 0) {
+            off_t dst_shift = 0;
+            if (idoff > 0) dst_shift = strtoll(&buf[idoff], (char **) NULL, 10);
+            off_t x1, x2;
+            while (sscanf(&buf[irange], "%lld-%lld", &x1, &x2) == 2) {
+                x->offset = x1;
+                x->length = x2 - x1;
+                x->dst_offset = x->offset + dst_shift;
+                ok &= copy (source, new_dest, 0, x, &unused, NULL);
+                irange += strcspn(&buf[irange], ",");
+                if (buf[irange] == ',') irange++;
+            }
+        } else {
+            x->offset = 0;
+            x->length = -1;
+            x->dst_offset = 0;
+            ok = copy (source, new_dest, 0, x, &unused, NULL);
+        }
+        free(source);
+        free(dest);
+      }
+      free(buf);
+    }
+// < PZK
   else /* !target_directory */
     {
       char const *new_dest;
@@ -764,6 +2164,41 @@ do_copy (int n_files, char **file, const
 
       ok = copy (source, new_dest, 0, x, &unused, NULL);
     }
+// PZK >
+#ifdef _OPENMP
+    // indicate that main thread is done traversing file system
+    main_done = 1;
+    // send terminating NULL task to stat/hash thread
+    sem_q_push(&send_q, NULL);
+    // send terminating NULL task to all worker threads
+    for (int i = 0; i < x->threads - 1; i++)
+        sem_q_push(&task_q, NULL);
+# if HAVE_LIBMPI
+    if (x->mpi) {
+        // send message to MPI handler on main node to break out of
+        // a final receive called just before main_done is set
+        long long sz = -1;
+        MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+    }
+# endif
+  }
+}
+
+# if HAVE_LIBMPI
+  if (x->mpi) MPI_Finalize();
+# endif
+
+  // destroy all queues
+  sem_q_destroy(&send_q);
+  sem_q_destroy(&open_q);
+  sem_q_destroy(&task_q);
+
+  //TODO: this no longer works with mpi/tcp
+  // reduce oks array to single value
+  for (int i = 0; i < x->threads; i++)
+    ok &= oks[i];
+#endif
+// < PZK
 
   return ok;
 }
@@ -772,6 +2207,66 @@ static void
 cp_option_init (struct cp_options *x)
 {
   cp_options_default (x);
+// PZK >
+  x->buffer_size = DEFAULT_BUFFER_SIZE * 1024 * 1024;
+  x->check_tree = false;
+#if DEFAULT_DOUBLE_BUFFER
+  x->double_buffer = true;
+#else
+  x->double_buffer = false;
+#endif
+  x->dst_offset = 0;
+#if DEFAULT_FADVISE_READ
+  x->fadvise_read = true;
+#else
+  x->fadvise_read = false;
+#endif
+#if DEFAULT_FADVISE_WRITE
+  x->fadvise_write = true;
+#else
+  x->fadvise_write = false;
+#endif
+  x->hash_size = 0;
+  x->hash_stat_tasks = xcalloc(1, sizeof(long long));
+#if HAVE_LIBGCRYPT
+  x->hash_type = DEFAULT_HASH_TYPE;
+#endif
+  x->length = -1;
+  x->listen_port = 0;
+  x->mg_file = 0;
+  x->mgr_ai = NULL;
+  x->mgr_port = 0;
+  x->mpi = false;
+  x->offset = 0;
+  x->open_q = NULL;
+  x->pass = NULL;
+#ifdef __linux__
+  x->preallocate = -1;
+#endif
+  x->print_hash = false;
+  x->print_stats = false;
+  x->print_stripe = false;
+  x->pw_file = 0;
+#if DEFAULT_DIRECT_READ
+  x->read_mode = O_DIRECT;
+#else
+  x->read_mode = 0;
+#endif
+  x->read_stdin = false;
+  x->skip_chmod = false;
+  x->split_size = DEFAULT_SPLIT_SIZE * 1024 * 1024;
+  x->hash_leaf_size = x->split_size; // this must follow split_size
+  x->stripe_count = 1;
+  x->stripe_ratio = 0;
+  x->task_q = NULL;
+  x->threads = DEFAULT_THREADS;
+  x->user = NULL;
+#if DEFAULT_DIRECT_WRITE
+  x->write_mode = O_DIRECT;
+#else
+  x->write_mode = 0;
+#endif
+// < PZK
   x->copy_as_regular = true;
   x->dereference = DEREF_UNDEFINED;
   x->unlink_dest_before_opening = false;
@@ -925,6 +2420,9 @@ main (int argc, char **argv)
   char *target_directory = NULL;
   bool no_target_directory = false;
   security_context_t scontext = NULL;
+// PZK >
+  bool dst_offset = false;
+// < PZK
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -947,6 +2445,172 @@ main (int argc, char **argv)
     {
       switch (c)
         {
+// PZK >
+        case BUFFER_SIZE_OPTION:
+          x.buffer_size = (int) strtol(optarg, (char **) NULL, 10);
+          if (x.buffer_size < 1 || x.buffer_size > 128)
+            error (EXIT_FAILURE, 0, _("invalid buffer size"));
+          size_t tmp_bs = x.buffer_size;
+          size_t new_bs = 1;
+          while (tmp_bs >>= 1) new_bs <<= 1;
+          if (x.buffer_size != new_bs)
+            error(0, 0, _("note: buffer size has been adjusted to %lld"), new_bs);
+          x.buffer_size = new_bs * 1024 * 1024;
+          break;
+        case DIRECT_READ_OPTION:
+          x.read_mode = O_DIRECT;
+          break;
+        case DIRECT_WRITE_OPTION:
+          x.write_mode = O_DIRECT;
+          break;
+        case DOUBLE_BUFFER_OPTION:
+          x.double_buffer = true;
+          break;
+        case DST_OFFSET_OPTION:
+          x.dst_offset = strtoll(optarg, (char **) NULL, 10);
+          if (x.dst_offset < 0)
+            error (EXIT_FAILURE, 0, _("invalid destination offset"));
+          dst_offset = true;
+          break;
+        case LENGTH_OPTION:
+          x.length = strtoll(optarg, (char **) NULL, 10);
+          if (x.length < 0)
+            error (EXIT_FAILURE, 0, _("invalid length"));
+          break;
+        case NO_DIRECT_READ_OPTION:
+          x.read_mode = 0;
+          break;
+        case NO_DIRECT_WRITE_OPTION:
+          x.write_mode = 0;
+          break;
+        case NO_DOUBLE_BUFFER_OPTION:
+          x.double_buffer = false;
+          break;
+        case OFFSET_OPTION:
+          x.offset = strtoll(optarg, (char **) NULL, 10);
+          if (x.offset < 0)
+            error (EXIT_FAILURE, 0, _("invalid offset"));
+          break;
+        case READ_STDIN_OPTION:
+          x.read_stdin = true;
+          break;
+        case SKIP_CHMOD_OPTION:
+          x.skip_chmod = true;
+          break;
+#ifdef POSIX_FADV_DONTNEED
+        case FADVISE_READ_OPTION:
+          x.fadvise_read = true;
+          break;
+        case FADVISE_WRITE_OPTION:
+          x.fadvise_write = true;
+          break;
+        case NO_FADVISE_READ_OPTION:
+          x.fadvise_read = false;
+          break;
+        case NO_FADVISE_WRITE_OPTION:
+          x.fadvise_write = false;
+          break;
+#endif
+#ifdef __linux__
+        case PREALLOCATE_OPTION:
+          x.preallocate = (int) strtol(optarg, (char **) NULL, 10);
+          break;
+#endif
+#ifdef _OPENMP
+        case PRINT_SRC_OPTION:
+          x.print_src = true;
+          break;
+        case PRINT_STATS_OPTION:
+          x.print_stats = true;
+          break;
+        case SPLIT_SIZE_OPTION:
+          x.split_size = strtoll(optarg, (char **) NULL, 10);
+          if (x.split_size < 0)
+            error (EXIT_FAILURE, 0, _("invalid split size"));
+          if (x.split_size > 0) {
+            off_t tmp_ss = x.split_size;
+            off_t new_ss = 1;
+            while (tmp_ss >>= 1) new_ss <<= 1;
+            if (x.split_size != new_ss)
+              error(0, 0, _("note: split size has been adjusted to %lld"), new_ss);
+            x.split_size = new_ss * 1024 * 1024;
+          }
+          break;
+        case THREADS_OPTION:
+          x.threads = (int) strtol(optarg, (char **) NULL, 10);
+          if (x.threads < 1 || x.threads > 512)
+            error (EXIT_FAILURE, 0, _("invalid number of threads"));
+          break;
+#endif
+#if HAVE_LIBLUSTREAPI
+        case PRINT_STRIPE_OPTION:
+          x.print_stripe = true;
+          break;
+        case STRIPE_COUNT_OPTION:
+          1;
+          char tmp_sr;
+          int rc = sscanf(optarg, "%f%c", &x.stripe_count, &tmp_sr);
+          if (rc < 1 || x.stripe_count < 0)
+            error (EXIT_FAILURE, 0, _("invalid stripe count"));
+          x.stripe_ratio = rc < 2 ? 'a' : tmp_sr;
+          break;
+#endif
+#if HAVE_LIBGCRYPT
+        case CHECK_TREE_OPTION:
+          x.check_tree = true;
+          break;
+        case HASH_LEAF_SIZE_OPTION:
+          x.hash_leaf_size = strtoll(optarg, (char **) NULL, 10);
+          if (x.hash_leaf_size < 1)
+            error (EXIT_FAILURE, 0, _("invalid hash leaf size"));
+          off_t tmp_ls = x.hash_leaf_size;
+          off_t new_ls = 1;
+          while (tmp_ls >>= 1) new_ls <<= 1;
+          if (x.hash_leaf_size != new_ls)
+            error(0, 0, _("note: hash leaf size has been adjusted to %lld"), new_ls);
+          x.hash_leaf_size = new_ls * 1024;
+          break;
+        case HASH_TYPE_OPTION:
+          x.hash_type = -1;
+          // 400 taken from libgcrypt benchmark code
+          for (int i = 1; i < 400; i++) {
+            if (!gcry_md_test_algo(i) &&
+                    !strcasecmp(optarg, gcry_md_algo_name(i))) {
+                x.hash_type = i;
+                break;
+            }
+          }
+          if (x.hash_type < 0) error (EXIT_FAILURE, 0, _("invalid hash type"));
+          break;
+        case PRINT_HASH_OPTION:
+          x.print_hash = true;
+          break;
+#endif
+#if HAVE_LIBMPI && defined(_OPENMP)
+        case MPI_OPTION:
+          x.mpi = true;
+          break;
+#endif
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+        case LISTEN_PORT_OPTION:
+          x.listen_port = (int) strtol(optarg, (char **) NULL, 10);
+          if (x.listen_port < 1 || x.listen_port > 65535)
+            error (EXIT_FAILURE, 0, _("invalid listen port"));
+          break;
+        case MANAGER_HOST_OPTION:
+          if (getaddrinfo(optarg, NULL, NULL, &x.mgr_ai))
+            error (EXIT_FAILURE, 0, _("unable to resolve manager host"));
+          break;
+        case MANAGER_PORT_OPTION:
+          x.mgr_port = (int) strtol(optarg, (char **) NULL, 10);
+          if (x.mgr_port < 1 || x.mgr_port > 65535)
+            error (EXIT_FAILURE, 0, _("invalid manager port"));
+          break;
+        case PASSWORD_FILE_OPTION:
+          x.pw_file = xstrdup(optarg);
+          break;
+#endif
+// < PZK
         case SPARSE_OPTION:
           x.sparse_mode = XARGMATCH ("--sparse", optarg,
                                      sparse_type_string, sparse_type);
@@ -1209,6 +2873,90 @@ main (int argc, char **argv)
 
   hash_init ();
 
+// PZK >
+  if (!dst_offset) x.dst_offset = x.offset;
+  if (target_directory && x.read_stdin)
+    error (EXIT_FAILURE, 0, _("cannot use --target-directory (-t) with --read-stdin"));
+  if (x.read_mode && x.fadvise_read) {
+#if DEFAULT_DIRECT_READ
+    x.read_mode = 0;
+#elif DEFAULT_FADVISE_READ
+    x.fadvise_read = false;
+#else
+    error(0, 0, _("note: --fadvise-read disabled in favor of --direct-read"));
+    x.fadvise_read = false;
+#endif
+  }
+  if (x.write_mode && x.fadvise_write) {
+#if DEFAULT_DIRECT_WRITE
+    x.write_mode = 0;
+#elif DEFAULT_FADVISE_WRITE
+    x.fadvise_write = false;
+#else
+    error(0, 0, _("note: --fadvise-write disabled in favor of --direct-write"));
+    x.fadvise_write = false;
+#endif
+  }
+#if HAVE_LIBGCRYPT
+  if (x.split_size > 0 && x.split_size < x.buffer_size) {
+    error(0, 0, _("note: split size has been adjusted to the buffer size"));
+    x.split_size = x.buffer_size;
+  }
+  if (x.split_size > 0 && x.split_size < x.hash_leaf_size) {
+    error(0, 0, _("note: hash leaf size has been adjusted to the split size"));
+    x.hash_leaf_size = x.split_size;
+  }
+  if (x.split_size > 0 && !x.hash_leaf_size) {
+    x.hash_leaf_size = x.split_size;
+  }
+  x.hash_size = gcry_md_get_algo_dlen(x.hash_type);
+#endif
+#ifndef _OPENMP
+  x.threads = 0;
+#endif
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+  if (x.mgr_ai != NULL && x.mgr_port)
+    ((struct sockaddr_in *) x.mgr_ai->ai_addr)->sin_port = htons(x.mgr_port);
+  if (x.mgr_ai != NULL && x.mgr_port == 0 || x.mgr_ai == NULL && x.mgr_port)
+    error (EXIT_FAILURE, 0, _("must specify both manager host and manager port"));
+  if (x.listen_port && x.mgr_port)
+    error (EXIT_FAILURE, 0, _("cannot use --listen-port with --manager-port"));
+  if (x.listen_port && x.pw_file) {
+    struct stat st;
+    // delay changing pw_file until after password generation
+    char *tmppw = xmalloc(strlen(x.pw_file) + 4);
+    x.mg_file = xmalloc(strlen(x.pw_file) + 4);
+    sprintf(tmppw, "%s.pw", x.pw_file);
+    sprintf(x.mg_file, "%s.mg", x.pw_file);
+    if (stat(x.mg_file, &st) < 0 && stat(tmppw, &st) < 0) {
+      if (srp_generate_auth(x.pw_file, tmppw, x.mg_file) < 0)
+        error (EXIT_FAILURE, 0, _("unable to create manager password files"));
+    } else if (stat(x.mg_file, &st) < 0) {
+      error (EXIT_FAILURE, 0,
+          _("manager modulus/generator file %s does not exist"),
+          quote(x.mg_file));
+    } else if (stat(tmppw, &st) < 0) {
+      error (EXIT_FAILURE, 0, _("manager password file %s does not exist"),
+          quote(tmppw));
+    }
+    free(x.pw_file);
+    x.pw_file = tmppw;
+  } else if (x.pw_file) {
+    struct passwd *pw = getpwuid(getuid());
+    if (pw == NULL)
+        error (EXIT_FAILURE, 0, _("unable to determine user name"));
+    x.user = xstrdup(pw->pw_name);
+    FILE *f = fopen(x.pw_file, "r");
+    if (f == NULL)
+      error (EXIT_FAILURE, 0, _("unable to read user password file"));
+    x.pass = xmalloc(32);
+    if (fread(x.pass, 16, 1, f) < 1)
+      error (EXIT_FAILURE, 0, _("unable to read user password"));
+    x.pass[16] = 0;
+  }
+#endif
+// < PZK
+
   ok = do_copy (argc - optind, argv + optind,
                 target_directory, no_target_directory, &x);
 
diff -rupN orig/src/extent-scan.c new/src/extent-scan.c
--- orig/src/extent-scan.c	2013-12-04 06:48:30.000000000 -0800
+++ new/src/extent-scan.c	2018-01-18 14:44:17.923923697 -0800
@@ -66,12 +66,19 @@ extent_need_sync (void)
 /* Allocate space for struct extent_scan, initialize the entries if
    necessary and return it as the input argument of extent_scan_read().  */
 extern void
-extent_scan_init (int src_fd, struct extent_scan *scan)
+// PZK >
+extent_scan_init (int src_fd, struct extent_scan *scan,
+    off_t start, off_t stop)
+// < PZK
 {
   scan->fd = src_fd;
   scan->ei_count = 0;
   scan->ext_info = NULL;
-  scan->scan_start = 0;
+// PZK >
+  scan->scan_start = start;
+  scan->scan_start0 = start;
+  scan->scan_stop = stop;
+// < PZK
   scan->initial_scan_failed = false;
   scan->hit_final_extent = false;
   scan->fm_flags = extent_need_sync () ? FIEMAP_FLAG_SYNC : 0;
@@ -105,13 +112,22 @@ extent_scan_read (struct extent_scan *sc
       fiemap->fm_start = scan->scan_start;
       fiemap->fm_flags = scan->fm_flags;
       fiemap->fm_extent_count = count;
-      fiemap->fm_length = FIEMAP_MAX_OFFSET - scan->scan_start;
+// PZK >
+      if (scan->scan_start >= scan->scan_stop) {
+        scan->hit_final_extent = true;
+        return scan->scan_start != scan->scan_start0;
+      } else {
+        fiemap->fm_length = scan->scan_stop - scan->scan_start;
+      }
+// < PZK
 
       /* Fall back to the standard copy if call ioctl(2) failed for
          the first time.  */
       if (ioctl (scan->fd, FS_IOC_FIEMAP, fiemap) < 0)
         {
-          if (scan->scan_start == 0)
+// PZK >
+          if (scan->scan_start == scan->scan_start0)
+// < PZK
             scan->initial_scan_failed = true;
           return false;
         }
@@ -120,7 +136,9 @@ extent_scan_read (struct extent_scan *sc
       if (fiemap->fm_mapped_extents == 0)
         {
           scan->hit_final_extent = true;
-          return scan->scan_start != 0;
+// PZK >
+          return scan->scan_start != scan->scan_start0;
+// < PZK
         }
 
       assert (scan->ei_count <= SIZE_MAX - fiemap->fm_mapped_extents);
@@ -172,7 +190,9 @@ extent_scan_read (struct extent_scan *sc
               /* If an extent is contained within the previous one, fail.  */
               if (length_adjust < fm_extents[i].fe_length)
                 {
-                  if (scan->scan_start == 0)
+// PZK >
+                  if (scan->scan_start == scan->scan_start0)
+// < PZK
                     scan->initial_scan_failed = true;
                   return false;
                 }
diff -rupN orig/src/extent-scan.h new/src/extent-scan.h
--- orig/src/extent-scan.h	2013-12-04 06:48:30.000000000 -0800
+++ new/src/extent-scan.h	2018-01-18 14:44:17.923923697 -0800
@@ -41,6 +41,14 @@ struct extent_scan
   /* Next scan start offset.  */
   off_t scan_start;
 
+// PZK >
+  /* Initial scan start offset.  */
+  off_t scan_start0;
+
+  /* Next scan stop offset.  */
+  off_t scan_stop;
+// < PZK
+
   /* Flags to use for scan.  */
   uint32_t fm_flags;
 
@@ -58,7 +66,10 @@ struct extent_scan
   struct extent_info *ext_info;
 };
 
-void extent_scan_init (int src_fd, struct extent_scan *scan);
+// PZK >
+void extent_scan_init (int src_fd, struct extent_scan *scan,
+    off_t start, off_t stop);
+// < PZK
 
 bool extent_scan_read (struct extent_scan *scan);
 
diff -rupN orig/src/local.mk new/src/local.mk
--- orig/src/local.mk	2013-12-04 06:48:30.000000000 -0800
+++ new/src/local.mk	2018-01-18 14:44:17.927923805 -0800
@@ -17,7 +17,9 @@
 ## along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 # FIXME: once lib/ and gnulib-tests/ are also converted, hoist to Makefile.am
-AM_CFLAGS = $(WERROR_CFLAGS)
+# PZK >
+AM_CFLAGS = $(WERROR_CFLAGS) $(OPENMP_CFLAGS)
+# < PZK
 
 # The list of all programs (separated in different variables to express
 # the how and when they should be installed) is defined in this makefile
@@ -325,11 +327,14 @@ selinux_sources = \
   src/selinux.c \
   src/selinux.h
 
+# PZK >
 copy_sources = \
   src/copy.c \
   src/cp-hash.c \
   src/extent-scan.c \
-  src/extent-scan.h
+  src/extent-scan.h \
+  src/mutil.c
+# < PZK
 
 # Use 'ginstall' in the definition of PROGRAMS and in dependencies to avoid
 # confusion with the 'install' target.  The install rule transforms 'ginstall'
@@ -370,17 +375,20 @@ src_stat_SOURCES = src/stat.c src/find-m
 src_uname_SOURCES = src/uname.c src/uname-uname.c
 src_arch_SOURCES = src/uname.c src/uname-arch.c
 
+# PZK >
+src_md5sum_SOURCES = src/md5sum.c src/mutil.c
 src_md5sum_CPPFLAGS = -DHASH_ALGO_MD5=1 $(AM_CPPFLAGS)
-src_sha1sum_SOURCES = src/md5sum.c
+src_sha1sum_SOURCES = src/md5sum.c src/mutil.c
 src_sha1sum_CPPFLAGS = -DHASH_ALGO_SHA1=1 $(AM_CPPFLAGS)
-src_sha224sum_SOURCES = src/md5sum.c
+src_sha224sum_SOURCES = src/md5sum.c src/mutil.c
 src_sha224sum_CPPFLAGS = -DHASH_ALGO_SHA224=1 $(AM_CPPFLAGS)
-src_sha256sum_SOURCES = src/md5sum.c
+src_sha256sum_SOURCES = src/md5sum.c src/mutil.c
 src_sha256sum_CPPFLAGS = -DHASH_ALGO_SHA256=1 $(AM_CPPFLAGS)
-src_sha384sum_SOURCES = src/md5sum.c
+src_sha384sum_SOURCES = src/md5sum.c src/mutil.c
 src_sha384sum_CPPFLAGS = -DHASH_ALGO_SHA384=1 $(AM_CPPFLAGS)
-src_sha512sum_SOURCES = src/md5sum.c
+src_sha512sum_SOURCES = src/md5sum.c src/mutil.c
 src_sha512sum_CPPFLAGS = -DHASH_ALGO_SHA512=1 $(AM_CPPFLAGS)
+# < PZK
 
 src_ginstall_CPPFLAGS = -DENABLE_MATCHPATHCON=1 $(AM_CPPFLAGS)
 
diff -rupN orig/src/md5sum.c new/src/md5sum.c
--- orig/src/md5sum.c	2013-12-04 06:48:30.000000000 -0800
+++ new/src/md5sum.c	2018-01-18 14:44:17.939924128 -0800
@@ -14,7 +14,69 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
-/* Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>.  */
+// PZK >
+/* Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>.
+   High performance multi-threaded modifications by Paul Kolano.  */
+
+/* Additional Terms per Section 7 of GNU General Public License Version 3
+
+1.  DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION
+
+    No Warranty: NASA PROVIDES THE COVERED WORKS "AS IS" WITHOUT ANY
+    WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
+    INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE COVERED WORKS
+    WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
+    INFRINGEMENT, ANY WARRANTY THAT THE COVERED WORKS WILL BE ERROR
+    FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
+    TO THE COVERED WORKS. THIS AGREEMENT DOES NOT, IN ANY MANNER,
+    CONSTITUTE AN ENDORSEMENT BY NASA OR ANY OTHER RECIPIENT OF ANY
+    RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER
+    APPLICATIONS RESULTING FROM USE OF THE COVERED WORKS.  FURTHER, NASA
+    DISCLAIMS ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY
+    SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT
+    "AS IS."
+
+    Waiver and Indemnity: YOU AGREE TO WAIVE ANY AND ALL CLAIMS
+    AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
+    SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT.  IF YOUR USE OF THE
+    COVERED WORKS RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES
+    OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM PRODUCTS
+    BASED ON, OR RESULTING FROM, YOUR USE OF THE COVERED WORKS, YOU
+    SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS
+    CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT, TO
+    THE EXTENT PERMITTED BY LAW.  YOUR SOLE REMEDY FOR ANY SUCH MATTER
+    SHALL BE THE IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
+
+2.  You must ensure that the following copyright notice appears
+    prominently in the covered works:
+
+        Copyright 2010 United States Government National Aeronautics and
+        Space Administration (NASA).  No copyright is claimed in the United
+        States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+3.  You must characterize Your alteration of the covered works as a
+    Modification or Contribution and must identify Yourself as the
+    originator of Your Modification or Contribution in a manner that
+    reasonably allows subsequent Recipients to identify the originator
+    of the Modification or Contribution.  In fulfillment of these
+    requirements, You must include a file (e.g., a change log file) that
+    describes the alterations made and the date of the alterations,
+    identifies You as originator of the alterations, and consents to
+    characterization of the alterations as a Modification or
+    Contribution, for example, by including a statement that the
+    Modification or Contribution is derived, directly or indirectly,
+    from covered work provided by NASA. Once consent is granted, it may
+    not thereafter be revoked.
+
+4.  You may not make any representation in the covered works or in any
+    promotional, advertising or other material that may be construed as
+    an endorsement by NASA or by any other Recipient of any product or
+    service provided by You, or that may seek to obtain commercial
+    advantage of NASA's or any other Recipient's participation in this
+    License.
+*/
+// < PZK
 
 #include <config.h>
 
@@ -40,9 +102,45 @@
 #include "stdio--.h"
 #include "xfreopen.h"
 
+// PZK >
+#include "buffer-lcm.h"
+#include "ioblksize.h"
+#include "mutil.h"
+#include "mkancesdirs.h"
+#include "quote.h"
+#include "savewd.h"
+#include <aio.h>
+#include <ctype.h>
+
+#if HAVE_LIBGCRYPT
+# include <gcrypt.h>
+# ifdef _OPENMP
+#  include <errno.h>
+#  include <pthread.h>
+GCRY_THREAD_OPTION_PTHREAD_IMPL;
+# endif
+#endif
+
+#if HAVE_LIBMPI && defined(_OPENMP)
+# include "mpi.h"
+#endif
+
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+# include <arpa/inet.h>
+# include <gnutls/gnutls.h>
+# include <netdb.h>
+# include <poll.h>
+# include <pthread.h>
+# include <pwd.h>
+# include <sys/socket.h>
+#endif
+// < PZK
+
 /* The official name of this program (e.g., no 'g' prefix).  */
 #if HASH_ALGO_MD5
-# define PROGRAM_NAME "md5sum"
+// PZK >
+# define PROGRAM_NAME "msum 1.822.5"
+// < PZK
 # define DIGEST_TYPE_STRING "MD5"
 # define DIGEST_STREAM md5_stream
 # define DIGEST_BITS 128
@@ -90,10 +188,35 @@
 #define DIGEST_HEX_BYTES (DIGEST_BITS / 4)
 #define DIGEST_BIN_BYTES (DIGEST_BITS / 8)
 
+// PZK >
 #define AUTHORS \
   proper_name ("Ulrich Drepper"), \
   proper_name ("Scott Miller"), \
-  proper_name ("David Madore")
+  proper_name ("David Madore"), \
+  proper_name ("Paul Kolano")
+
+#ifndef DEFAULT_BUFFER_SIZE
+# define DEFAULT_BUFFER_SIZE 4
+#endif
+#ifndef DEFAULT_DIRECT_READ
+# define DEFAULT_DIRECT_READ 0
+#endif
+#ifndef DEFAULT_DOUBLE_BUFFER
+# define DEFAULT_DOUBLE_BUFFER 0
+#endif
+#ifndef DEFAULT_FADVISE_READ
+# define DEFAULT_FADVISE_READ 0
+#endif
+#if !defined(DEFAULT_HASH_TYPE) && HAVE_LIBGCRYPT
+# define DEFAULT_HASH_TYPE GCRY_MD_MD5
+#endif
+#ifndef DEFAULT_SPLIT_SIZE
+# define DEFAULT_SPLIT_SIZE 0
+#endif
+#ifndef DEFAULT_THREADS
+# define DEFAULT_THREADS 4
+#endif
+// < PZK
 
 /* The minimum length of a valid digest line.  This length does
    not include any newline character at the end of a line.  */
@@ -134,6 +257,39 @@ static int bsd_reversed = -1;
 enum
 {
   STATUS_OPTION = CHAR_MAX + 1,
+// PZK >
+  BUFFER_SIZE_OPTION,
+  DIRECT_READ_OPTION,
+  DOUBLE_BUFFER_OPTION,
+  LENGTH_OPTION,
+  NO_DIRECT_READ_OPTION,
+  NO_DOUBLE_BUFFER_OPTION,
+  OFFSET_OPTION,
+  READ_STDIN_OPTION,
+#ifdef POSIX_FADV_DONTNEED
+  FADVISE_READ_OPTION,
+  NO_FADVISE_READ_OPTION,
+#endif
+#ifdef _OPENMP
+  PRINT_STATS_OPTION,
+  SPLIT_SIZE_OPTION,
+  THREADS_OPTION,
+#endif
+#if HAVE_LIBGCRYPT
+  CHECK_TREE_OPTION,
+  HASH_LEAF_SIZE_OPTION,
+  HASH_TYPE_OPTION,
+#endif
+#if HAVE_LIBMPI && defined(_OPENMP)
+  MPI_OPTION,
+#endif
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+  LISTEN_PORT_OPTION,
+  MANAGER_HOST_OPTION,
+  MANAGER_PORT_OPTION,
+  PASSWORD_FILE_OPTION,
+#endif
+// < PZK
   QUIET_OPTION,
   STRICT_OPTION,
   TAG_OPTION
@@ -141,6 +297,39 @@ enum
 
 static struct option const long_options[] =
 {
+// PZK >
+  {"buffer-size", required_argument, NULL, BUFFER_SIZE_OPTION},
+  {"direct-read", no_argument, NULL, DIRECT_READ_OPTION},
+  {"double-buffer", no_argument, NULL, DOUBLE_BUFFER_OPTION},
+  {"length", required_argument, NULL, LENGTH_OPTION},
+  {"no-direct-read", no_argument, NULL, NO_DIRECT_READ_OPTION},
+  {"no-double-buffer", no_argument, NULL, NO_DOUBLE_BUFFER_OPTION},
+  {"offset", required_argument, NULL, OFFSET_OPTION},
+  {"read-stdin", no_argument, NULL, READ_STDIN_OPTION},
+#ifdef POSIX_FADV_DONTNEED
+  {"fadvise-read", no_argument, NULL, FADVISE_READ_OPTION},
+  {"no-fadvise-read", no_argument, NULL, NO_FADVISE_READ_OPTION},
+#endif
+#ifdef _OPENMP
+  {"print-stats", no_argument, NULL, PRINT_STATS_OPTION},
+  {"split-size", required_argument, NULL, SPLIT_SIZE_OPTION},
+  {"threads", required_argument, NULL, THREADS_OPTION},
+#endif
+#if HAVE_LIBGCRYPT
+  {"check-tree", no_argument, NULL, CHECK_TREE_OPTION},
+  {"hash-leaf-size", required_argument, NULL, HASH_LEAF_SIZE_OPTION},
+  {"hash-type", required_argument, NULL, HASH_TYPE_OPTION},
+#endif
+#if HAVE_LIBMPI && defined(_OPENMP)
+  {"mpi", no_argument, NULL, MPI_OPTION},
+#endif
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+  {"listen-port", required_argument, NULL, LISTEN_PORT_OPTION},
+  {"manager-host", required_argument, NULL, MANAGER_HOST_OPTION},
+  {"manager-port", required_argument, NULL, MANAGER_PORT_OPTION},
+  {"password-file", required_argument, NULL, PASSWORD_FILE_OPTION},
+#endif
+// < PZK
   { "binary", no_argument, NULL, 'b' },
   { "check", no_argument, NULL, 'c' },
   { "quiet", no_argument, NULL, QUIET_OPTION },
@@ -154,6 +343,403 @@ static struct option const long_options[
   { NULL, 0, NULL, 0 }
 };
 
+// PZK >
+#define sum_options cp_options
+#define sum_task_t copy_reg_t
+#define hash_time write_time
+#define sum_time copy_time
+#define hash_check dst_name
+
+static void
+sum_option_init (struct sum_options *x)
+{
+  x->buffer_size = DEFAULT_BUFFER_SIZE * 1024 * 1024;
+  x->check_tree = false;
+#if DEFAULT_DOUBLE_BUFFER
+  x->double_buffer = true;
+#else
+  x->double_buffer = false;
+#endif
+#if DEFAULT_FADVISE_READ
+  x->fadvise_read = true;
+#else
+  x->fadvise_read = false;
+#endif
+  x->hash_size = 0;
+  x->hash_stat_tasks = xcalloc(1, sizeof(long long));
+#if HAVE_LIBGCRYPT
+  x->hash_type = DEFAULT_HASH_TYPE;
+#endif
+  x->length = -1;
+  x->listen_port = 0;
+  x->mg_file = NULL;
+  x->mgr_ai = NULL;
+  x->mgr_port = 0;
+  x->mpi = false;
+  x->offset = 0;
+  x->pass = NULL;
+  x->print_stats = false;
+  x->pw_file = 0;
+#if DEFAULT_DIRECT_READ
+  x->read_mode = O_DIRECT;
+#else
+  x->read_mode = 0;
+#endif
+  x->read_stdin = false;
+  x->split_size = DEFAULT_SPLIT_SIZE * 1024 * 1024;
+  x->hash_leaf_size = x->split_size; // this must follow split_size
+  x->task_q = NULL;
+  x->threads = DEFAULT_THREADS;
+  x->user = NULL;
+}
+
+extern bool
+sum_task(sum_task_t *stt, struct sum_options *so)
+{
+  char *buf[2];
+  char *buf_alloc[2];
+  buf_alloc[0] = NULL;
+  buf_alloc[1] = NULL;
+  struct stat src_open_sb;
+  bool return_val = true;
+
+#if HAVE_LIBGCRYPT
+  hash_tree_t htt;
+#endif
+
+  int src_fd = open(stt->src_name, O_RDONLY | O_BINARY | so->read_mode);
+  if (src_fd < 0)
+    error(0, errno, _("warning: unable to open %s for read"), quote(stt->src_name));
+  if (lseek(src_fd, stt->start_offset, SEEK_SET) < 0)
+    error(0, errno, _("warning: unable to seek in %s"), quote(stt->src_name));
+  //TODO: additional error handling if can't open or seek?
+
+  if (fstat (src_fd, &src_open_sb) != 0)
+    {
+      error (0, errno, _("cannot fstat %s"), quote (stt->src_name));
+      return_val = false;
+      goto task_close_src_and_dst_desc;
+    }
+
+  typedef uintptr_t word;
+  off_t total_n_read = 0;
+
+  /* Choose a suitable buffer size; it may be adjusted later.  */
+  size_t buf_alignment = lcm (getpagesize (), sizeof (word));
+  size_t buf_alignment_slop = sizeof (word) + buf_alignment - 1;
+  size_t buf_size = stt->dst_blksize;
+ 
+  /* Compute the least common multiple of the input and output
+     buffer sizes, adjusting for outlandish values.  */
+  size_t blcm_max = MIN (SIZE_MAX, SSIZE_MAX) - buf_alignment_slop;
+  size_t blcm = buffer_lcm (io_blksize (src_open_sb), buf_size,
+                                blcm_max);
+  blcm = so->buffer_size;
+  if (so->read_mode)
+    blcm = buffer_lcm (blcm, 512, blcm_max);
+
+  /* Do not bother with a buffer larger than the input file, plus one
+     byte to make sure the file has not grown while reading it.  */
+  if (S_ISREG (src_open_sb.st_mode) && src_open_sb.st_size < buf_size)
+    buf_size = src_open_sb.st_size + 1;
+
+  /* However, stick with a block size that is a positive multiple of
+     blcm, overriding the above adjustments.  Watch out for
+     overflow.  */
+  buf_size += blcm - 1;
+  buf_size -= buf_size % blcm;
+  if (buf_size == 0 || blcm_max < buf_size)
+    buf_size = blcm;
+
+  /* Make a buffer with space for a sentinel at the end.  */
+  buf_alloc[0] = xmalloc (buf_size + buf_alignment_slop);
+  buf[0] = ptr_align (buf_alloc[0], buf_alignment);
+  if (so->double_buffer) {
+    buf_alloc[1] = xmalloc (buf_size + buf_alignment_slop);
+    buf[1] = ptr_align (buf_alloc[1], buf_alignment);
+  }
+
+#if HAVE_LIBGCRYPT
+  gcry_md_hd_t ctx;
+  gcry_md_open(&ctx, so->hash_type, 0);
+  if (stt->nsplits > 1) {
+    htt.total_n_hash = 0;
+    htt.hash_ctx = &ctx;
+    htt.hash_ctx_len = 0;
+    htt.stack_len = 0;
+
+    // compute approximate height of split sub-tree
+    off_t leafs = (stt->stop_offset - stt->start_offset) /
+        so->hash_leaf_size + 1;
+    ssize_t n = 1;
+    while (leafs >>= 1) n++;
+    // stack needs space for at most height of tree hashes
+    htt.stack = xmalloc(n * so->hash_size);
+  }
+#endif
+
+  struct timespec rts[2], hts[2];
+  struct aiocb aio;
+  struct aiocb *aiol[1];
+  aiol[0] = NULL;
+  int aio_buf = 0;
+
+  for (;;)
+    {
+      if (total_n_read >= stt->stop_offset - stt->start_offset) break;
+
+      ssize_t n_read;
+      if (aiol[0] != NULL) {
+        // this will be skipped during the first double buffer iteration
+        // wait for previous asynchronous read to complete
+        while (aio_suspend((const struct aiocb * const *) aiol, 1, NULL) && errno == EINTR);
+        n_read = aio_return(aiol[0]);
+      } else {
+        off_t to_read = MIN(buf_size,
+            stt->stop_offset - stt->start_offset - total_n_read);
+        // special handling for non-empty size zero files
+        if (!src_open_sb.st_size) to_read = buf_size;
+        // align offset for direct i/o and better performance when buffered
+        off_t align_read = (stt->start_offset + total_n_read) % 4096;
+        if (align_read != 0 && to_read > 4096) to_read = 4096 - align_read;
+        if (so->read_mode && to_read < buf_size) {
+            // turn off direct i/o if going to read unaligned block
+            int old_flags = fcntl(src_fd, F_GETFL);
+            if (fcntl(src_fd, F_SETFL, old_flags & ~O_DIRECT) != 0)
+                error(0, errno, _("failed to turn off O_DIRECT: %s"),
+                    quote (stt->src_name));
+        }
+
+        if (so->print_stats) clock_gettime(0, &rts[0]);
+        n_read = read (src_fd, buf[aio_buf], to_read);
+
+        if (so->read_mode && align_read != 0) {
+            // turn direct i/o back on in case it was turned off
+            int old_flags = fcntl(src_fd, F_GETFL);
+            if (old_flags & O_DIRECT == 0 &&
+                fcntl(src_fd, F_SETFL, old_flags | O_DIRECT) != 0)
+                    error(0, errno, _("failed to turn on O_DIRECT: %s"),
+                        quote(stt->src_name));
+        }
+      }
+
+      if (so->print_stats) {
+        clock_gettime(0, &rts[1]);
+        stt->read_time += (double) (
+            (double) rts[1].tv_sec + (double) rts[1].tv_nsec / (double) 1.0e9 -
+            (double) rts[0].tv_sec - (double) rts[0].tv_nsec / (double) 1.0e9);
+      }
+
+      if (n_read < 0)
+        {
+#ifdef EINTR
+          if (errno == EINTR)
+            continue;
+#endif
+          error (0, errno, _("reading %s"), quote (stt->src_name));
+          return_val = false;
+          goto task_close_src_and_dst_desc;
+        }
+      if (n_read == 0)
+        break;
+
+#ifdef POSIX_FADV_DONTNEED
+      if (so->fadvise_read) {
+        // indicate done with read data
+        posix_fadvise(src_fd, stt->start_offset + total_n_read,
+            n_read, POSIX_FADV_DONTNEED);
+      }
+#endif
+
+      total_n_read += n_read;
+
+      off_t to_read = MIN(buf_size,
+        stt->stop_offset - stt->start_offset - total_n_read);
+      // special handling for non-empty size zero files
+      if (!src_open_sb.st_size) to_read = buf_size;
+      if (so->double_buffer && to_read > 0) {
+        if (so->read_mode && to_read < buf_size) {
+            // turn off direct i/o if going to read unaligned block
+            int old_flags = fcntl(src_fd, F_GETFL);
+            if (fcntl(src_fd, F_SETFL, old_flags & ~O_DIRECT) != 0)
+                error(0, errno, _("failed to turn off O_DIRECT: %s"),
+                    quote (stt->src_name));
+        }
+
+        if (so->print_stats) clock_gettime(0, &rts[0]);
+        memset(&aio, 0, sizeof(struct aiocb));
+        aio.aio_fildes = src_fd;
+        aio.aio_offset = stt->start_offset + total_n_read;
+        aio.aio_buf = buf[!aio_buf];
+        aio.aio_nbytes = to_read;
+        aiol[0] = &aio;
+        if (aio_read(&aio) < 0) {
+            error (0, errno, _("failed to initiate aio_read: %s"),
+                quote (stt->src_name));
+            return_val = false;
+            goto task_close_src_and_dst_desc;
+        }
+      }
+
+      if (so->print_stats) clock_gettime(0, &hts[0]);
+#if HAVE_LIBGCRYPT
+       //TODO: is st_size right for partial files?
+      if (stt->nsplits > 1)
+        hash_tree(&htt, stt, so, buf[aio_buf], total_n_read);
+      else
+        gcry_md_write(ctx, buf[aio_buf], n_read);
+#endif
+      if (so->print_stats) {
+        clock_gettime(0, &hts[1]);
+        stt->hash_time += (double) (
+            (double) hts[1].tv_sec + (double) hts[1].tv_nsec / (double) 1.0e9 -
+            (double) hts[0].tv_sec - (double) hts[0].tv_nsec / (double) 1.0e9);
+      }
+      if (so->double_buffer) aio_buf = !aio_buf;
+    }
+
+task_close_src_and_dst_desc:
+  if (close (src_fd) < 0)
+    {
+      error (0, errno, _("closing %s"), quote (stt->src_name));
+      return_val = false;
+    }
+
+  free (buf_alloc[0]);
+  free (buf_alloc[1]);
+  if (!return_val) {
+    error (0, 0, _("%s: FAILED open or read"), quote (stt->src_name));
+#if HAVE_LIBGCRYPT
+  } else {
+    // copy final hash onto stt hash stack
+    if (stt->nsplits > 1) {
+        memcpy(stt->hash_stack, htt.stack, so->hash_size);
+    } else {
+        memcpy(stt->hash_stack, gcry_md_read(ctx, 0), so->hash_size);
+    }
+#endif
+  }
+
+#if HAVE_LIBGCRYPT
+  if (buf_alloc[0] != NULL) {
+    gcry_md_close(ctx);
+    if (stt->nsplits > 1)
+        free(htt.stack);
+  }
+#endif
+
+  return return_val;
+}
+
+void print_check(struct sum_options *x, sum_task_t *stt)
+{
+    static const char bin2hex[] = { '0', '1', '2', '3',
+                                    '4', '5', '6', '7',
+                                    '8', '9', 'a', 'b',
+                                    'c', 'd', 'e', 'f' };
+    size_t digest_bin_bytes = digest_hex_bytes / 2;
+    size_t cnt, s;
+    unsigned char *stack = stt->hash_stack;
+    unsigned char *check = stt->hash_check;
+    int fail = 0;
+    if (!status_only) printf("%s: ", stt->src_name);
+
+    /* Compare generated binary number with text representation
+       in check file.  Ignore case of hex digits.  */
+    int nsplits = x->check_tree ? stt->nsplits : 1;
+    for (s = 0; s < nsplits; s++) {
+        for (cnt = 0; cnt < digest_bin_bytes; ++cnt) {
+            if (tolower (check[2 * cnt])
+                != bin2hex[stack[cnt] >> 4]
+                || (tolower (check[2 * cnt + 1])
+                    != (bin2hex[stack[cnt] & 0xf])))
+            break;
+        }
+        if (!status_only) {
+            if (cnt != digest_bin_bytes) {
+                if (!fail) {
+                    printf("%s", _("FAILED"));
+                    fail = 1;
+                }
+                if (stt->partial || x->check_tree) {
+                    off_t end = stt->start_offset + (s + 1) * x->split_size;
+                    if (end > stt->stop_offset) end = stt->stop_offset;
+                    printf(",%lld-%lld",
+                        stt->start_offset + s * x->split_size, end);
+                }
+            }
+        }
+        stack += digest_bin_bytes;
+        check += digest_hex_bytes;
+    }
+/*TODO: do something with this in hash thread
+    if (cnt != digest_bin_bytes)
+      ++n_mismatched_checksums;
+*/
+    if (!status_only) {
+        if (!quiet && !fail) {
+            printf("%s", _("OK"));
+            if (stt->partial)
+                printf(",%lld-%lld", stt->start_offset, stt->stop_offset);
+        }
+        if (fail || !quiet) printf("\n");
+        fflush (stdout);
+    }
+}
+
+void print_hash(struct sum_options *x, sum_task_t *stt)
+{
+    size_t i;
+
+    // put non-standard output in comments
+    if (stt->nsplits > 1 || stt->partial) {
+        printf("#mutil#");
+        if (stt->partial)
+            printf("%lld-%lld", stt->start_offset, stt->stop_offset);
+        printf("#");
+    }
+
+    /* Output a leading backslash if the file name contains
+       a newline or backslash.  */
+    if (strchr (stt->src_name, '\n') || strchr (stt->src_name, '\\'))
+      putchar ('\\');
+
+    size_t bytes = digest_hex_bytes / 2;
+    if (x->check_tree) bytes *= stt->nsplits;
+    for (i = 0; i < bytes; ++i)
+      printf ("%02x", stt->hash_stack[i]);
+
+    putchar (' ');
+/*TODO: do something with this binary stuff
+    if (file_is_binary)
+      putchar ('*');
+    else
+*/
+      putchar (' ');
+
+    /* Translate each NEWLINE byte to the string, "\\n",
+       and each backslash to "\\\\".  */
+    for (i = 0; i < strlen (stt->src_name); ++i)
+      {
+        switch (stt->src_name[i])
+          {
+          case '\n':
+            fputs ("\\n", stdout);
+            break;
+
+          case '\\':
+            fputs ("\\\\", stdout);
+            break;
+
+          default:
+            putchar (stt->src_name[i]);
+            break;
+          }
+      }
+    putchar ('\n');
+}
+// < PZK
+
 void
 usage (int status)
 {
@@ -161,15 +747,120 @@ usage (int status)
     emit_try_help ();
   else
     {
+// PZK >
       printf (_("\
 Usage: %s [OPTION]... [FILE]...\n\
-Print or check %s (%d-bit) checksums.\n\
+Print or check checksums.\n\
 With no FILE, or when FILE is -, read standard input.\n\
 \n\
 "),
-              program_name,
-              DIGEST_TYPE_STRING,
-              DIGEST_BITS);
+              program_name);
+      fputs (_("Msum-specific options (defaults in brackets):\n"), stdout);
+      fprintf (stdout, _("\
+      --buffer-size=MBYTES     read/write buffer size [%d]\n"),
+        DEFAULT_BUFFER_SIZE);
+#if HAVE_LIBGCRYPT
+      fputs (_("\
+      --check-tree             print/check hash subtrees to pinpoint corruption\n\
+"), stdout);
+#endif
+#if !DEFAULT_DIRECT_READ
+      fputs (_("\
+      --direct-read            enable use of direct I/O for reads\n\
+"), stdout);
+#endif
+#if !DEFAULT_DOUBLE_BUFFER
+      fputs (_("\
+      --double-buffer          enable use of double buffering during file I/O\n\
+"), stdout);
+#endif
+#ifdef POSIX_FADV_DONTNEED
+# if !DEFAULT_FADVISE_READ
+      fputs (_("\
+      --fadvise-read           enable use of posix_fadvise during reads\n\
+"), stdout);
+# endif
+#endif
+#if HAVE_LIBGCRYPT
+      fprintf (stdout, _("\
+      --hash-leaf-size=KBYTES  granularity of hash tree [%d]\n\
+      --hash-type=TYPE         hash type [%s], with TYPE one of:\n\
+                                 "),
+        DEFAULT_SPLIT_SIZE * 1024, gcry_md_algo_name(DEFAULT_HASH_TYPE));
+      int n = 33;
+      // 400 taken from libgcrypt benchmark code
+      for (int i = 1; i < 400; i++) {
+        if (gcry_md_test_algo(i)) continue;
+        const char *name = gcry_md_algo_name(i);
+        if (n + strlen(name) > 78) {
+            fputs (_("\n                                 "), stdout);
+            n = 33;
+        }
+        n += strlen(name);
+        while (*name) fputc(tolower(*name++), stdout);
+        fputc(' ', stdout);
+      }
+      fputs(_("\n"), stdout);
+#endif
+      fputs (_("\
+      --length=LEN             hash LEN bytes beginning at --offset\n\
+                                 (or from 0 if --offset not specified)\n\
+"), stdout);
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+      fputs (_("\
+      --listen-port=PORT       listen on port PORT for requests from\n\
+                                 cooperating hosts\n\
+      --manager-host=HOST      host name or IP address of management thread\n\
+                                 for multi-node/multi-host copies\n\
+      --manager-port=PORT      port on which to contact management thread\n\
+"), stdout);
+#endif
+#if HAVE_LIBMPI && defined(_OPENMP)
+      fputs (_("\
+      --mpi                    enable use of MPI for multi-node checksums\n\
+"), stdout);
+#endif
+#if DEFAULT_DIRECT_READ
+      fputs (_("\
+      --no-direct-read         disable use of direct I/O for reads\n\
+"), stdout);
+#endif
+#if DEFAULT_DOUBLE_BUFFER
+      fputs (_("\
+      --no-double-buffer       disable use of double buffering during file I/O\n\
+"), stdout);
+#endif
+#ifdef POSIX_FADV_DONTNEED
+# if DEFAULT_FADVISE_READ
+      fputs (_("\
+      --no-fadvise-read        disable use of posix_fadvise during reads\n\
+"), stdout);
+# endif
+#endif
+      fputs (_("\
+      --offset=POS             hash --length bytes beginning at POS\n\
+                                 (or to end if --length not specified)\n\
+"), stdout);
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+      fputs (_("\
+      --password-file=FILE     file to use for passwords (will be created\n\
+                                 if does not exist)\n\
+"), stdout);
+#endif
+#ifdef _OPENMP
+      fprintf (stdout, _("\
+      --read-stdin             perform a batch of operations read over stdin\n\
+                                 in the form 'FILE RANGES' where FILE must be\n\
+                                 a URI-escaped (RFC 3986) file name and RANGES\n\
+                                 is zero or more comma-separated ranges of the\n\
+                                 form 'START-END' for 0 <= START < END\n\
+      --split-size=MBYTES      size to split files for parallelization [%d]\n\
+      --threads=NUMBER         number of OpenMP worker threads to use [%d]\n\
+\n\
+"), DEFAULT_SPLIT_SIZE, DEFAULT_THREADS);
+#endif
+      fputs (_("Standard options:\n"), stdout);
+// < PZK
       if (O_BINARY)
         fputs (_("\
   -b, --binary         read in binary mode (default unless reading tty stdin)\n\
@@ -178,9 +869,10 @@ With no FILE, or when FILE is -, read st
         fputs (_("\
   -b, --binary         read in binary mode\n\
 "), stdout);
+// PZK >
       printf (_("\
-  -c, --check          read %s sums from the FILEs and check them\n"),
-              DIGEST_TYPE_STRING);
+  -c, --check          read sums from the FILEs and check them\n"));
+// < PZK
       fputs (_("\
       --tag            create a BSD-style checksum\n\
 "), stdout);
@@ -203,13 +895,13 @@ The following four options are useful on
 "), stdout);
       fputs (HELP_OPTION_DESCRIPTION, stdout);
       fputs (VERSION_OPTION_DESCRIPTION, stdout);
+// PZK >
       printf (_("\
 \n\
-The sums are computed as described in %s.  When checking, the input\n\
-should be a former output of this program.  The default mode is to print\n\
-a line with checksum, a character indicating input mode ('*' for binary,\n\
-space for text), and name for each FILE.\n"),
-              DIGEST_REFERENCE);
+When checking, the input should be a former output of this program.\n\
+The default mode is to print a line with checksum, a character indicating\n\
+type (`*' for binary, space for text), and name for each FILE.\n"));
+// < PZK
       emit_ancillary_info ();
     }
 
@@ -318,6 +1010,9 @@ bsd_split_3 (char *s, size_t s_len, unsi
    a hexadecimal digest, binary flag, and the file name.
    S is modified.  Return true if successful.  */
 
+// PZK >
+//TODO: need to modify this to take different hash sizes into account
+// < PZK
 static bool
 split_3 (char *s, size_t s_len,
          unsigned char **hex_digest, int *binary, char **file_name)
@@ -364,6 +1059,11 @@ split_3 (char *s, size_t s_len,
      representation of the message digest.  If it is not followed
      immediately by a white space it's an error.  */
   i += digest_hex_bytes;
+// PZK >
+  //TODO: put this in for checktree
+  while (!ISWHITE (s[i]))
+    i++;
+// < PZK
   if (!ISWHITE (s[i]))
     return false;
 
@@ -403,6 +1103,10 @@ split_3 (char *s, size_t s_len,
 static bool _GL_ATTRIBUTE_PURE
 hex_digits (unsigned char const *s)
 {
+// PZK >
+    //TODO: temporarily set this true until check-tree finalized
+    return true;
+// < PZK
   unsigned int i;
   for (i = 0; i < digest_hex_bytes; i++)
     {
@@ -425,12 +1129,88 @@ hex_digits (unsigned char const *s)
    Return true if successful.  */
 
 static bool
-digest_file (const char *filename, int *binary, unsigned char *bin_result)
+// PZK >
+digest_file (struct sum_options *x, unsigned char *h_check,
+    const char *filename, int *binary, unsigned char *bin_result)
+// < PZK
 {
   FILE *fp;
   int err;
   bool is_stdin = STREQ (filename, "-");
 
+// PZK >
+#if HAVE_LIBGCRYPT && defined(_OPENMP)
+  if (is_stdin) goto do_stdin;
+
+  struct stat src_sb;
+  if (stat (filename, &src_sb) != 0) {
+      error (0, errno, _("cannot stat %s"), quote (filename));
+      return false;
+  }
+
+  if (!S_ISREG(src_sb.st_mode)) {
+      error (0, 0, _("%s: Is not a regular file"), quote (filename));
+      return false;
+  }
+
+//TODO:  do something with binary?  why should that matter?
+  off_t pos = 0;
+  if (x->offset && x->offset > src_sb.st_size) pos = src_sb.st_size;
+  else if (x->offset) pos = x->offset;
+  off_t orig_offset = pos;
+  off_t end = src_sb.st_size;
+  if (x->length >= 0 && pos + x->length < end) end = pos + x->length;
+  size_t nsplits = 1, split = 0;
+  if (x->split_size > 0 && end - pos > 0)
+      nsplits = (end - pos) / x->split_size +
+          ((end - pos) % x->split_size ? 1 : 0);
+  while (nsplits == 1 || pos < end) {
+      sum_task_t *stt = xmalloc(sizeof(sum_task_t));
+      stt->src_name = xstrdup(filename);
+      stt->dst_blksize = io_blksize(src_sb);
+      stt->read_time = 0;
+      stt->hash_time = 0;
+      stt->sum_time = 0;
+      stt->nsplits = nsplits;
+      stt->split = split++;
+      stt->start_offset = pos;
+      stt->orig_offset = orig_offset;
+      stt->partial = x->offset || x->length >= 0 ||
+            end < src_sb.st_size ? true : false;
+      stt->hash_stack = xmalloc(x->hash_size);
+      stt->hash_check = NULL;
+      *x->hash_stat_tasks += 1;
+      pos += x->split_size;
+      if (nsplits > 1) {
+          // stop after split size bytes
+          stt->stop_offset = MIN(pos, end);
+          if (stt->start_offset == x->offset) {
+              sum_task_t *sttcp = xmalloc(sizeof(sum_task_t));
+              sttcp->nsplits = nsplits;
+              sttcp->split = nsplits;
+              sttcp->start_offset = x->offset;
+              sttcp->stop_offset = end;
+              sttcp->orig_offset = orig_offset;
+              sttcp->partial = stt->partial;
+              sttcp->src_name = xstrdup(filename);
+              sttcp->hash_stack = xmalloc(nsplits * x->hash_size);
+              sttcp->hash_check = h_check;
+              // send stt copy to hash handler
+              sem_q_push(x->send_q, sttcp);
+          }
+      } else {
+          // stop at end of file
+          stt->stop_offset = end;
+          stt->hash_check = h_check;
+      }
+      sem_q_push(x->task_q, stt);
+      if (nsplits == 1) break;
+  }
+  return true;
+do_stdin:
+#endif
+// < PZK
+
   if (is_stdin)
     {
       have_read_stdin = true;
@@ -474,7 +1254,9 @@ digest_file (const char *filename, int *
 }
 
 static bool
-digest_check (const char *checkfile_name)
+// PZK >
+digest_check (struct sum_options *x, const char *checkfile_name)
+// < PZK
 {
   FILE *checkfile_stream;
   uintmax_t n_misformatted_lines = 0;
@@ -525,15 +1307,36 @@ digest_check (const char *checkfile_name
       if (line_length <= 0)
         break;
 
-      /* Ignore comment lines, which begin with a '#' character.  */
+// PZK >
+      /* Ignore comment lines, which begin with a '#' character.
       if (line[0] == '#')
-        continue;
+        continue;*/
+// < PZK
 
       /* Remove any trailing newline.  */
       if (line[line_length - 1] == '\n')
         line[--line_length] = '\0';
 
-      if (! (split_3 (line, line_length, &hex_digest, &binary, &filename)
+// PZK >
+      off_t stop;
+      if (sscanf(line, "#mutil#%lld-%lld", &x->offset, &stop) != 2) {
+        x->offset = 0;
+        x->length = -1;
+      } else {
+        x->length = stop - x->offset;
+      }
+      size_t iline = 0;
+      if (!strncmp(line, "#mutil#", 7)) {
+        iline = strcspn(&line[7], "#") + 8;
+        if (iline > line_length) continue;
+        line_length -= iline;
+      } else
+      /* Ignore comment lines, which begin with a '#' character.  */
+      if (line[0] == '#')
+        continue;
+
+      if (! (split_3(&line[iline], line_length, &hex_digest, &binary, &filename)
+// < PZK
              && ! (is_stdin && STREQ (filename, "-"))
              && hex_digits (hex_digest)))
         {
@@ -560,7 +1363,11 @@ digest_check (const char *checkfile_name
 
           ++n_properly_formatted_lines;
 
-          ok = digest_file (filename, &binary, bin_buffer);
+// PZK >
+          unsigned char *h_check = xstrdup(hex_digest);
+          ok = digest_file (x, h_check, filename, &binary, bin_buffer);
+          continue;
+// < PZK
 
           if (!ok)
             {
@@ -686,6 +1493,74 @@ print_filename (char const *file, bool e
     }
 }
 
+// PZK >
+/* unescape() based on curl_easy_escape() to which the following applies
+COPYRIGHT AND PERMISSION NOTICE
+
+Copyright (c) 1996 - 2009, Daniel Stenberg, <daniel@haxx.se>.
+
+All rights reserved.
+
+Permission to use, copy, modify, and distribute this software for any purpose
+with or without fee is hereby granted, provided that the above copyright
+notice and this permission notice appear in all copies.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN
+NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
+OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of a copyright holder shall not
+be used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization of the copyright holder.
+*/
+
+/*
+ * Unescapes the given URL escaped string of given length. Returns a
+ * pointer to a malloced string.
+ * If length == 0, the length is assumed to be strlen(string).
+ */
+char *unescape(const char *string, int length)
+{
+  int alloc = (length?length:(int)strlen(string))+1;
+  char *ns = xmalloc(alloc);
+  unsigned char in;
+  int strindex=0;
+  long hex;
+
+  if( !ns )
+    return NULL;
+
+  while(--alloc > 0) {
+    in = *string;
+    if(('%' == in) && isxdigit(string[1]) && isxdigit(string[2])) {
+      /* this is two hexadecimal digits following a '%' */
+      char hexstr[3];
+      char *ptr;
+      hexstr[0] = string[1];
+      hexstr[1] = string[2];
+      hexstr[2] = 0;
+
+      hex = strtol(hexstr, &ptr, 16);
+
+      in = (unsigned char)hex; /* this long is never bigger than 255 anyway */
+
+      string+=2;
+      alloc-=2;
+    }
+
+    ns[strindex++] = in;
+    string++;
+  }
+  ns[strindex]=0; /* terminate it */
+
+  return ns;
+}
+// < PZK
+
 int
 main (int argc, char **argv)
 {
@@ -707,6 +1582,11 @@ main (int argc, char **argv)
 
   atexit (close_stdout);
 
+// PZK >
+  struct sum_options x;
+  sum_option_init (&x);
+// < PZK
+
   /* Line buffer stdout to ensure lines are written atomically and immediately
      so that processes running in parallel do not intersperse their output.  */
   setvbuf (stdout, NULL, _IOLBF, 0);
@@ -714,6 +1594,127 @@ main (int argc, char **argv)
   while ((opt = getopt_long (argc, argv, "bctw", long_options, NULL)) != -1)
     switch (opt)
       {
+// PZK >
+        case BUFFER_SIZE_OPTION:
+          x.buffer_size = (int) strtol(optarg, (char **) NULL, 10);
+          if (x.buffer_size < 1 || x.buffer_size > 128)
+            error (EXIT_FAILURE, 0, _("invalid buffer size"));
+          size_t tmp_bs = x.buffer_size;
+          size_t new_bs = 1;
+          while (tmp_bs >>= 1) new_bs <<= 1;
+          if (x.buffer_size != new_bs)
+            error(0, 0, _("Note: buffer size has been adjusted to %lld"), new_bs);
+          x.buffer_size = new_bs * 1024 * 1024;
+          break;
+        case DIRECT_READ_OPTION:
+          x.read_mode = O_DIRECT;
+          break;
+        case DOUBLE_BUFFER_OPTION:
+          x.double_buffer = true;
+          break;
+        case LENGTH_OPTION:
+          x.length = strtoll(optarg, (char **) NULL, 10);
+          if (x.length < 0)
+            error (EXIT_FAILURE, 0, _("invalid length"));
+          break;
+        case NO_DIRECT_READ_OPTION:
+          x.read_mode = 0;
+          break;
+        case NO_DOUBLE_BUFFER_OPTION:
+          x.double_buffer = false;
+          break;
+        case OFFSET_OPTION:
+          x.offset = strtoll(optarg, (char **) NULL, 10);
+          if (x.offset < 0)
+            error (EXIT_FAILURE, 0, _("invalid offset"));
+          break;
+        case READ_STDIN_OPTION:
+          x.read_stdin = true;
+          break;
+#ifdef POSIX_FADV_DONTNEED
+        case FADVISE_READ_OPTION:
+          x.fadvise_read = true;
+          break;
+        case NO_FADVISE_READ_OPTION:
+          x.fadvise_read = false;
+          break;
+#endif
+#ifdef _OPENMP
+        case PRINT_STATS_OPTION:
+          x.print_stats = true;
+          break;
+        case SPLIT_SIZE_OPTION:
+          x.split_size = strtoll(optarg, (char **) NULL, 10);
+          if (x.split_size < 0)
+            error (EXIT_FAILURE, 0, _("invalid split size"));
+          if (x.split_size > 0) {
+            off_t tmp_ss = x.split_size;
+            off_t new_ss = 1;
+            while (tmp_ss >>= 1) new_ss <<= 1;
+            if (x.split_size != new_ss)
+              error(0, 0, _("Note: split size has been adjusted to %lld"), new_ss);
+            x.split_size = new_ss * 1024 * 1024;
+          }
+          break;
+        case THREADS_OPTION:
+          x.threads = (int) strtol(optarg, (char **) NULL, 10);
+          if (x.threads < 1 || x.threads > 512)
+            error (EXIT_FAILURE, 0, _("invalid number of threads"));
+          break;
+#endif
+#if HAVE_LIBGCRYPT
+        case CHECK_TREE_OPTION:
+          x.check_tree = true;
+          break;
+        case HASH_LEAF_SIZE_OPTION:
+          x.hash_leaf_size = strtoll(optarg, (char **) NULL, 10);
+          if (x.hash_leaf_size < 1)
+            error (EXIT_FAILURE, 0, _("invalid hash leaf size"));
+          off_t tmp_ls = x.hash_leaf_size;
+          off_t new_ls = 1;
+          while (tmp_ls >>= 1) new_ls <<= 1;
+          if (x.hash_leaf_size != new_ls)
+            error(0, 0, _("Note: hash leaf size has been adjusted to %lld"), new_ls);
+          x.hash_leaf_size = new_ls * 1024;
+          break;
+        case HASH_TYPE_OPTION:
+          x.hash_type = -1;
+          // 400 taken from libgcrypt benchmark code
+          for (int i = 1; i < 400; i++) {
+            if (!gcry_md_test_algo(i) &&
+                    !strcasecmp(optarg, gcry_md_algo_name(i))) {
+                x.hash_type = i;
+                break;
+            }
+          }
+          if (x.hash_type < 0) error (EXIT_FAILURE, 0, _("invalid hash type"));
+          break;
+#endif
+#if HAVE_LIBMPI && defined(_OPENMP)
+        case MPI_OPTION:
+          x.mpi = true;
+          break;
+#endif
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+        case LISTEN_PORT_OPTION:
+          x.listen_port = (int) strtol(optarg, (char **) NULL, 10);
+          if (x.listen_port < 1 || x.listen_port > 65535)
+            error (EXIT_FAILURE, 0, _("invalid listen port"));
+          break;
+        case MANAGER_HOST_OPTION:
+          if (getaddrinfo(optarg, NULL, NULL, &x.mgr_ai))
+            error (EXIT_FAILURE, 0, _("unable to resolve manager host"));
+          break;
+        case MANAGER_PORT_OPTION:
+          x.mgr_port = (int) strtol(optarg, (char **) NULL, 10);
+          if (x.mgr_port < 1 || x.mgr_port > 65535)
+            error (EXIT_FAILURE, 0, _("invalid manager port"));
+          break;
+        case PASSWORD_FILE_OPTION:
+          x.pw_file = xstrdup(optarg);
+          break;
+#endif
+// < PZK
       case 'b':
         binary = 1;
         break;
@@ -800,7 +1801,7 @@ main (int argc, char **argv)
       usage (EXIT_FAILURE);
     }
 
-  if (strict & !do_check)
+  if (strict && !do_check)
    {
      error (0, 0,
         _("the --strict option is meaningful only when verifying checksums"));
@@ -812,21 +1813,828 @@ main (int argc, char **argv)
 
   if (optind == argc)
     argv[argc++] = bad_cast ("-");
+// PZK >
+  else if (x.read_stdin)
+    error (EXIT_FAILURE, 0, _("--read-stdin cannot be used with other arguments"));
+  if (x.read_stdin && do_check)
+    error (EXIT_FAILURE, 0, _("--read-stdin cannot be used with -c/--check"));
+  if (x.read_mode && x.fadvise_read) {
+#if DEFAULT_DIRECT_READ
+    x.read_mode = 0;
+#elif DEFAULT_FADVISE_READ
+    x.fadvise_read = false;
+#else
+    error(0, 0, _("Note: --fadvise-read disabled in favor of --direct-read"));
+    x.fadvise_read = false;
+#endif
+  }
+#if HAVE_LIBGCRYPT
+  if (x.split_size > 0 && x.split_size < x.buffer_size) {
+    error(0, 0, _("Note: split size has been adjusted to the buffer size"));
+    x.split_size = x.buffer_size;
+  }
+  if (x.split_size > 0 && x.split_size < x.hash_leaf_size) {
+    error(0, 0, _("Note: hash leaf size has been adjusted to the split size"));
+    x.hash_leaf_size = x.split_size;
+  } else if (x.split_size > 0 && !x.hash_leaf_size) {
+    x.hash_leaf_size = x.split_size;
+  }
+  x.hash_size = gcry_md_get_algo_dlen(x.hash_type);
+  min_digest_line_length = 2 * x.hash_size + 2 + 1;
+  digest_hex_bytes = 2 * x.hash_size;
+#endif
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+  if (x.mgr_ai != NULL && x.mgr_port)
+    ((struct sockaddr_in *) x.mgr_ai->ai_addr)->sin_port = htons(x.mgr_port);
+  if (x.mgr_ai != NULL && x.mgr_port == 0 || x.mgr_ai == NULL && x.mgr_port)
+    error (EXIT_FAILURE, 0, _("must specify both manager host and manager port"));
+  if (x.listen_port && x.mgr_port)
+    error (EXIT_FAILURE, 0, _("cannot use --listen-port with --manager-port"));
+  if (x.listen_port && x.pw_file) {
+    struct stat st;
+    // delay changing pw_file until after password generation
+    char *tmppw = xmalloc(strlen(x.pw_file) + 4);
+    x.mg_file = xmalloc(strlen(x.pw_file) + 4);
+    sprintf(tmppw, "%s.pw", x.pw_file);
+    sprintf(x.mg_file, "%s.mg", x.pw_file);
+    if (stat(x.mg_file, &st) < 0 && stat(tmppw, &st) < 0) {
+      if (srp_generate_auth(x.pw_file, tmppw, x.mg_file) < 0)
+        error (EXIT_FAILURE, 0, _("unable to create manager password files"));
+    } else if (stat(x.mg_file, &st) < 0) {
+      error (EXIT_FAILURE, 0,
+          _("manager modulus/generator file %s does not exist"),
+          quote(x.mg_file));
+    } else if (stat(tmppw, &st) < 0) {
+      error (EXIT_FAILURE, 0, _("manager password file %s does not exist"),
+          quote(tmppw));
+    }
+    free(x.pw_file);
+    x.pw_file = tmppw;
+  } else if (x.pw_file) {
+    struct passwd *pw = getpwuid(getuid());
+    if (pw == NULL)
+        error (EXIT_FAILURE, 0, _("unable to determine user name"));
+    x.user = xstrdup(pw->pw_name);
+    FILE *f = fopen(x.pw_file, "r");
+    if (f == NULL)
+      error (EXIT_FAILURE, 0, _("unable to read user password file"));
+    x.pass = xmalloc(32);
+    if (fread(x.pass, 16, 1, f) < 1)
+      error (EXIT_FAILURE, 0, _("unable to read user password"));
+    x.pass[16] = 0;
+  }
+#endif
+
+#ifdef _OPENMP
+  int pid = 0, procs = 1;
+  int hash_stat_done = 0;
+  int main_done = 0;
+# if HAVE_LIBMPI
+  if (x.mpi) {
+    MPI_Init(NULL, NULL);
+    MPI_Comm_rank(MPI_COMM_WORLD, &pid);
+    MPI_Comm_size(MPI_COMM_WORLD, &procs);
+    // add a thread for MPI handler on main node
+    if (pid == 0) x.threads++;
+  }
+# endif
+  // add a thread for TCP handler on main node
+  if (x.listen_port) x.threads++;
+  // add a thread for file/TCP handler on main/other nodes
+  x.threads++;
+  // add a thread for stat/hash handler on main node
+  if (!x.mgr_port && pid == 0) x.threads++;
+
+  omp_set_num_threads(x.threads);
+  bool oks[x.threads];
+  sem_q_t task_q;
+  sem_q_init(&task_q, x.threads, sizeof(sum_task_t));
+  x.task_q = &task_q;
+  sem_q_t send_q;
+  sem_q_init(&send_q, x.threads, sizeof(void *));
+  x.send_q = &send_q;
+
+# if HAVE_LIBGCRYPT
+  gcry_control(GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);
+  if (!gcry_check_version(GCRYPT_VERSION))
+    error (EXIT_FAILURE, 0, _("libgcrypt version mismatch"));
+  gcry_control(GCRYCTL_DISABLE_SECMEM, 0);
+  gcry_control(GCRYCTL_ENABLE_M_GUARD, 0);
+  gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);
+# endif
+# if HAVE_LIBGNUTLS
+  if (x.listen_port || x.mgr_port) {
+    gnutls_global_init();
+  }
+#endif
+
+# pragma omp parallel
+{
+  int tid = omp_get_thread_num();
+  oks[tid] = true;
+
+  if (!x.mgr_port && pid == 0 && tid == 2) {
+    ////////////////////////////////////
+    // stat/hash handler on main node //
+    ////////////////////////////////////
+    struct timespec tts[2];
+    if (x.print_stats) {
+      fprintf(stderr, _("      size        rd_mbs  hs_mbs  sm_mbs  file\n"));
+      fprintf(stderr, _("      ----        ------  ------  ------  ----\n"));
+      clock_gettime(0, &tts[0]);
+    }
+    off_t tsize = 0;
+    int maxstts = 128;
+    sum_task_t **stts = xcalloc(maxstts, sizeof(sum_task_t *));
+    int nstts = 0;
+    long long done_tasks = 0;
+    while (!main_done || *x.hash_stat_tasks > done_tasks) {
+      //TODO: timeout on pop?
+      sum_task_t *stt = sem_q_pop(&send_q);
+      if (stt != NULL && stt->split != stt->nsplits) done_tasks++;
+      if (stt == NULL || stt->src_name == NULL) {
+        //TODO: do something with error?
+        continue;
+      }
+      if (x.print_stats && stt->split != stt->nsplits) {
+        tsize += stt->stop_offset - stt->start_offset;
+        double mb = (stt->stop_offset - stt->start_offset) / 1000.0 / 1000.0;
+        fprintf(stderr, _("%16lld  %6.1f  %6.1f  %6.1f  %s"),
+            stt->stop_offset - stt->start_offset, mb / stt->read_time,
+            mb / stt->hash_time, mb / stt->sum_time, stt->src_name);
+        if (stt->nsplits > 1)
+            fprintf(stderr, _(" (%lu/%lu)"), stt->split + 1, stt->nsplits);
+        fprintf(stderr, _("\n"));
+      }
+
+      if (stt->nsplits == 1) {
+        if (stt->hash_check != NULL) {
+            print_check(&x, stt);
+        } else {
+            print_hash(&x, stt);
+        }
+      }
+
+      if (stt->nsplits <= 1) {
+        free(stt->src_name);
+        free(stt->hash_stack);
+        free(stt->hash_check);
+        free(stt);
+        continue;
+      }
+ 
+      int index;
+      int empty = -1;
+      // find existing entry and/or free slot
+      for (index = 0; index < maxstts; index++) {
+          if (stts[index] == NULL) {
+              if (empty < 0) empty = index;
+              continue;
+          }
+          if (!strcmp(stt->src_name, stts[index]->src_name) &&
+              stt->orig_offset == stts[index]->orig_offset) break;
+      }
+      if (index >= maxstts) {
+          // this is the first split received
+          if (empty == -1) {
+              // no free slot found so expand array
+              maxstts *= 2;
+              //TODO: should probably error out if array gets too big
+              xrealloc(stts, maxstts * sizeof(sum_task_t *));
+              bzero(&stts[maxstts / 2], maxstts / 2 * sizeof(sum_task_t *));
+              empty = index;
+          }
+          // first stt has special field values including
+          //   split = nsplits, stop_offset = file size,
+          //   dst_fd = open fd, and hash_stack of size nsplits * hash size
+          stts[empty] = stt;
+      } else {
+#if HAVE_LIBGCRYPT
+        // copy final hash onto shared hash stack
+        memcpy(&stts[index]->hash_stack[stt->split * x.hash_size],
+            stt->hash_stack, x.hash_size);
+        free(stt->hash_stack);
+#endif
+        free(stt->src_name);
+        free(stt);
+        stt = stts[index];
+        // this works because split will be nsplits in first stt received
+        if (--stt->split == 0) {
+#if HAVE_LIBGCRYPT
+            // finalize hash if last
+            gcry_md_hd_t ctx;
+            gcry_md_open(&ctx, x.hash_type, 0);
+            hash_tree_t htt;
+            htt.total_n_hash = 0;
+            htt.hash_ctx = &ctx;
+            htt.hash_ctx_len = 0;
+            htt.stack_len = 0;
+            // don't compute root of tree when printing/checking subtrees
+            if (!x.check_tree) hash_final(&htt, stt, &x, 0, stt->nsplits);
+            // print or check hash
+            if (stt->hash_check != NULL) {
+                print_check(&x, stt);
+            } else {
+                print_hash(&x, stt);
+            }
+            // clean up
+            gcry_md_close(ctx);
+            free(stt->hash_stack);
+            free(stt->hash_check);
+#endif
+            free(stt->src_name);
+            free(stt);
+            stts[index] = NULL;
+            //TODO: if last, then set done for tcp, etc.
+        }
+      }
+    }
+     if (x.print_stats) {
+        clock_gettime(0, &tts[1]);
+        double tt = (double) (
+            (double) tts[1].tv_sec + (double) tts[1].tv_nsec / (double) 1.0e9 -
+            (double) tts[0].tv_sec - (double) tts[0].tv_nsec / (double) 1.0e9);
+        double mb = tsize / 1000.0 / 1000.0;
+        fprintf(stderr, _("      ----        ------  ------  ------  ----\n"));
+        fprintf(stderr, _("%16lld                  %6.1f  total\n"),
+            tsize, mb / tt);
+    }
+    hash_stat_done = 1;
+# if HAVE_LIBMPI
+    if (x.mpi) {
+        // send message to MPI handler on main node to break out of
+        // a final receive called just before hash_stat_done is set
+        long long sz = -1;
+        MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+    }
+# endif
+# if HAVE_LIBGNUTLS
+  } else if (x.mgr_port && tid == 0) {
+    ////////////////////////////////
+    // TCP handler on other nodes //
+    ////////////////////////////////
+    // initialize tls/srp
+    gnutls_session_t tls_sess;
+    gnutls_srp_client_credentials_t srp_cred;
+    gnutls_srp_allocate_client_credentials(&srp_cred);
+    gnutls_srp_set_client_credentials(srp_cred, x.user, x.pass);
+
+    int nulls = 0;
+    int null_task = 0;
+    int nonnull_task = 0;
+
+    while (nulls < x.threads - 1) {
+      sum_task_t *stt = sem_q_pop(&send_q);
+      if (stt == NULL && null_task) {
+        nulls++;
+        sem_q_push(&task_q, NULL);
+        continue;
+      } else if (stt != NULL) {
+        nonnull_task = 1;
+      }
+
+      int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+      if (sock < 0)
+        error(EXIT_FAILURE, 0, _("unable to create socket"));
+
+      size_t src_size = 0;
+      ssize_t rc = connect(sock, x.mgr_ai->ai_addr, sizeof(struct sockaddr_in));
+      if (!rc) {
+        // initialize tls session
+        gnutls_init(&tls_sess, GNUTLS_CLIENT);
+        gnutls_priority_set_direct(tls_sess, "NORMAL:+SRP", NULL);
+        gnutls_credentials_set(tls_sess, GNUTLS_CRD_SRP, srp_cred);
+        gnutls_transport_set_ptr(tls_sess,
+            (gnutls_transport_ptr_t)(uintptr_t) sock);
+        if (gnutls_handshake(tls_sess) < 0) {
+            error(0, 0, _("unable to authenticate to server"));
+            //TODO: can this cause deadlocK?
+            sem_q_push(&send_q, NULL);
+            continue;
+        }
+      } else {
+        if (nonnull_task) {
+            nulls++;
+            sem_q_push(&task_q, NULL);
+            continue;
+        }
+        error(0, 0, _("connect failed...sleeping"));
+        fflush(stderr);
+        // wait until server starts
+        sleep(1);
+        //TODO: can this cause deadlocK?
+        sem_q_push(&send_q, NULL);
+        // probably want some check so don't loop forever
+        continue;
+      }
+
+
+      if (stt != NULL) {
+        // send final status with times and hash
+        src_size = strlen(stt->src_name) + 1;
+        rc |= gnutls_record_send(tls_sess, &src_size, sizeof(src_size));
+        rc |= gnutls_record_send(tls_sess, stt->src_name, src_size);
+        rc |= gnutls_record_send(tls_sess, stt->hash_stack, x.hash_size);
+        rc |= gnutls_record_send(tls_sess, stt, sizeof(sum_task_t));
+        if (stt->hash_check != NULL)
+            rc |= gnutls_record_send(tls_sess, stt->hash_check,
+                2 * x.hash_size);
+        if (rc < 0)
+            error(0, 0, _("unable to send final status to server"));
+            //TODO: do something else like requeue stt?
+        free(stt->src_name);
+        free(stt->hash_check);
+        free(stt->hash_stack);
+        free(stt);
+      } else {
+        // send task request
+        src_size = 0;
+        rc |= gnutls_record_send(tls_sess, &src_size, sizeof(src_size));
+
+        // receive task request
+        rc |= gnutls_record_recv(tls_sess, &src_size, sizeof(src_size));
+        if (rc < 0 || src_size == 0) {
+          null_task = 1;
+          nulls++;
+          sem_q_push(&task_q, NULL);
+        } else {
+          if (rc > 0) {
+              char *src_tmp = xmalloc(src_size);
+              stt = xmalloc(sizeof(sum_task_t));
+              stt->hash_check = NULL;
+              rc |= gnutls_record_recv(tls_sess, src_tmp, src_size);
+              rc |= gnutls_record_recv(tls_sess, stt, sizeof(sum_task_t));
+              if (rc > 0 && stt->hash_check != NULL) {
+                stt->hash_check = xmalloc(2 * x.hash_size + 1);
+                rc |= gnutls_record_recv(tls_sess, stt->hash_check,
+                    2 * x.hash_size);
+                stt->hash_check[2 * x.hash_size] = 0;
+              }
+              //TODO: this section still needs work??
+              if (rc > 0) {
+                  stt->src_name = src_tmp;
+                  stt->hash_stack = xmalloc(x.hash_size);
+                  sem_q_push(&task_q, stt);
+              } else {
+                  free(src_tmp);
+                  free(stt->hash_check);
+                  free(stt);
+              }
+          }
+        }
+      }
+      if (rc >= 0 || src_size > 0) {
+        // shutdown tls session
+        gnutls_bye(tls_sess, GNUTLS_SHUT_RDWR);
+        shutdown(sock, SHUT_RDWR);
+        gnutls_deinit(tls_sess);
+      }
+    }
+    // free tls/srp resources
+    gnutls_srp_free_client_credentials(srp_cred);
+    gnutls_global_deinit();
+  } else if (x.listen_port && tid == 1) {
+    //////////////////////////////
+    // TCP handler on main node //
+    //////////////////////////////
+    // initialize tls/srp
+    gnutls_srp_server_credentials_t srp_cred;
+    gnutls_srp_allocate_server_credentials(&srp_cred);
+    gnutls_srp_set_server_credentials_file(srp_cred, x.pw_file, x.mg_file);
+
+    int server_sock, client_sock;
+    struct sockaddr_in server_sa, client_sa;
+    socklen_t client_len = sizeof(client_sa);
+
+    server_sa.sin_family = AF_INET;
+    server_sa.sin_addr.s_addr = htonl(INADDR_ANY);
+    server_sa.sin_port = htons(x.listen_port);
+
+    server_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+    if (server_sock < 0)
+        error(EXIT_FAILURE, 0, _("unable to create socket"));
+    if (fcntl(server_sock, F_SETFL, O_NONBLOCK) < 0)
+        error(EXIT_FAILURE, 0, _("unable to set socket option"));
+    if (bind(server_sock, (struct sockaddr *) &server_sa, sizeof(server_sa)) < 0)
+        error(EXIT_FAILURE, 0, _("unable to bind to socket"));
+    if (listen(server_sock, SOMAXCONN) < 0)
+        error(EXIT_FAILURE, 0, _("unable to listen on socket"));
+
+    struct pollfd sfds[1];
+    sfds[0].fd = server_sock;
+    sfds[0].events = POLLIN;
+
+    int null_task = 0;
+
+    while (!main_done || !hash_stat_done) {
+        if (poll(sfds, 1, 1000) <= 0) continue;
+
+        gnutls_session_t tls_sess;
+        gnutls_init(&tls_sess, GNUTLS_SERVER);
+        gnutls_priority_set_direct(tls_sess, "NORMAL:+SRP", NULL);
+        gnutls_credentials_set(tls_sess, GNUTLS_CRD_SRP, srp_cred);
+
+        client_sock =
+            accept(server_sock, (struct sockaddr *) &client_sa, &client_len);
+        if (client_sock < 0) continue;
+        gnutls_transport_set_ptr(tls_sess,
+            (gnutls_transport_ptr_t)(uintptr_t) client_sock);
+         if (gnutls_handshake(tls_sess) < 0) {
+            error(0, 0, _("warning: failed authentication attempt from %s:%d"),
+                inet_ntoa(client_sa.sin_addr), ntohs(client_sa.sin_port));
+            continue;
+        }
+
+        size_t src_size;
+        ssize_t rc = 0;
+        sum_task_t *stt;
+        //TODO: need timeouts throughout here
+        if (gnutls_record_recv(tls_sess, &src_size, sizeof(src_size)) < 0) continue;
+        if (src_size > 0) {
+          char *src_tmp = xmalloc(src_size);
+          unsigned char *hash_tmp = xmalloc(x.hash_size);
+          stt = xmalloc(sizeof(sum_task_t));
+          stt->hash_check = NULL;
+          rc |= gnutls_record_recv(tls_sess, src_tmp, src_size);
+          rc |= gnutls_record_recv(tls_sess, hash_tmp, x.hash_size);
+          rc |= gnutls_record_recv(tls_sess, stt, sizeof(sum_task_t));
+          if (rc > 0 && stt->hash_check != NULL) {
+              stt->hash_check = xmalloc(2 * x.hash_size + 1);
+              rc |= gnutls_record_recv(tls_sess, stt->hash_check,
+                  2 * x.hash_size);
+              stt->hash_check[2 * x.hash_size] = 0;
+          }
+          //TODO: this section still needs work??
+          if (rc > 0) {
+              stt->src_name = src_tmp;
+              stt->hash_stack = hash_tmp;
+              sem_q_push(&send_q, stt);
+          } else {
+              free(src_tmp);
+              free(hash_tmp);
+              free(stt->hash_check);
+              stt->src_name = NULL;
+              // indicate error with null src
+              sem_q_push(&send_q, stt);
+              //TODO: see if this technique can be used elsewhere
+          }
+        } else {
+            stt = null_task ? NULL : sem_q_pop(&task_q);
+            if (stt == NULL) {
+                null_task = 1;
+                src_size = 0;
+                rc |= gnutls_record_send(tls_sess, &src_size, sizeof(src_size));
+            } else {
+                // this assumes same arch on client/server
+                src_size = strlen(stt->src_name) + 1;
+                rc |= gnutls_record_send(tls_sess, &src_size, sizeof(src_size));
+                rc |= gnutls_record_send(tls_sess, stt->src_name, src_size);
+                rc |= gnutls_record_send(tls_sess, stt, sizeof(sum_task_t));
+                if (stt->hash_check != NULL)
+                    rc |= gnutls_record_send(tls_sess, stt->hash_check,
+                        2 * x.hash_size);
+                if (rc <= 0) {
+                    sem_q_push(&task_q, stt);
+                    error(0, 0, _("warning: failure responding to client (will retry)"));
+                } else {
+                    free(stt->src_name);
+                    free(stt->hash_check);
+                    free(stt->hash_stack);
+                    free(stt);
+                }
+            }
+        }
+        gnutls_bye(tls_sess, GNUTLS_SHUT_WR);
+        close(client_sock);
+        gnutls_deinit(tls_sess);
+    }
+    close(server_sock);
+    gnutls_srp_free_server_credentials(srp_cred);
+    gnutls_global_deinit();
+# endif
+# if HAVE_LIBMPI
+  } else if (pid != 0 && tid == 0) {
+    ////////////////////////////////
+    // MPI handler on other nodes //
+    ////////////////////////////////
+    int nulls = 0;
+    int null_task = 0;
+    int nonnull_task = 0;
+
+    while (nulls < x.threads - 1) {
+      sum_task_t *stt = sem_q_pop(&send_q);
+      if (stt == NULL && null_task) {
+        nulls++;
+        sem_q_push(&task_q, NULL);
+        continue;
+      } else if (stt != NULL) {
+        nonnull_task = 1;
+      }
+
+      size_t src_size, chk_size;
+      long long sz;
+      int pos = 0;
+
+      if (stt != NULL) {
+        // send final status with times and hash
+        src_size = strlen(stt->src_name) + 1;
+        chk_size = stt->hash_check == NULL ?  0 : strlen(stt->hash_check) + 1;
+        sz = src_size + chk_size + x.hash_size + sizeof(sum_task_t);
+        MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+
+        // pack stt into one big byte array
+        char pack[sz];
+        // this assumes same arch on client/server
+        MPI_Pack(&src_size, sizeof(src_size),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&chk_size, sizeof(chk_size),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(stt->src_name, src_size,
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        if (chk_size)
+            MPI_Pack(stt->hash_check, chk_size,
+                MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(stt->hash_stack, x.hash_size,
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&stt->dst_blksize, sizeof(stt->dst_blksize),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&stt->read_time, sizeof(stt->read_time),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&stt->hash_time, sizeof(stt->hash_time),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&stt->sum_time, sizeof(stt->sum_time),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&stt->start_offset, sizeof(stt->start_offset),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&stt->stop_offset, sizeof(stt->stop_offset),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&stt->nsplits, sizeof(stt->nsplits),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&stt->split, sizeof(stt->split),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+
+        MPI_Send(pack, pos, MPI_PACKED, 0, 1, MPI_COMM_WORLD);
+
+        free(stt->src_name);
+        free(stt->hash_check);
+        free(stt->hash_stack);
+        free(stt);
+      } else {
+        // send task request
+        sz = 0;
+        MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+
+        // receive task request
+        MPI_Status stat;
+        int rc = MPI_Recv(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD, &stat);
+        if (rc || sz == 0) {
+            null_task = 1;
+            nulls++;
+            sem_q_push(&task_q, NULL);
+        } else {
+            // unpack stt from one big byte array
+            char pack[sz];
+            if (MPI_Recv(pack, sz, MPI_PACKED, 0, 1, MPI_COMM_WORLD, &stat))
+                continue;
+            // this assumes same arch on client/server
+            MPI_Unpack(pack, sz, &pos, &src_size, sizeof(src_size),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &chk_size, sizeof(chk_size),
+                MPI_BYTE, MPI_COMM_WORLD);
+
+            stt = xmalloc(sizeof(sum_task_t));
+            stt->src_name = xmalloc(src_size);
+            stt->hash_stack = xmalloc(x.hash_size);
+            MPI_Unpack(pack, sz, &pos, stt->src_name, src_size,
+                MPI_BYTE, MPI_COMM_WORLD);
+            if (chk_size) {
+                stt->hash_check = xmalloc(chk_size);
+                MPI_Unpack(pack, sz, &pos, stt->hash_check, chk_size,
+                    MPI_BYTE, MPI_COMM_WORLD);
+            } else {
+                stt->hash_check = NULL;
+            }
+            MPI_Unpack(pack, sz, &pos, &stt->dst_blksize, sizeof(stt->dst_blksize),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->read_time, sizeof(stt->read_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->hash_time, sizeof(stt->hash_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->sum_time, sizeof(stt->sum_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->start_offset, sizeof(stt->start_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->stop_offset, sizeof(stt->stop_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->nsplits, sizeof(stt->nsplits),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->split, sizeof(stt->split),
+                MPI_BYTE, MPI_COMM_WORLD);
+
+            sem_q_push(&task_q, stt);
+        }
+      }
+    }
+  } else if (x.mpi && pid == 0 && tid == 1) {
+    //////////////////////////////
+    // MPI handler on main node //
+    //////////////////////////////
+    int null_task = 0;
+    MPI_Status stat;
+    long long sz;
+    int mpi_recv = 0;
+
+    while (!main_done || !hash_stat_done || x.mpi && mpi_recv < 2) {
+        if (MPI_Recv(&sz, 1, MPI_LONG_LONG, MPI_ANY_SOURCE, MPI_ANY_TAG,
+                MPI_COMM_WORLD, &stat)) break;
+
+        size_t src_size, chk_size;
+        sum_task_t *stt;
+        int pos = 0;
+
+        if (sz > 0) {
+            // unpack stt from one big byte array
+            char pack[sz];
+            if (MPI_Recv(pack, sz, MPI_PACKED, stat.MPI_SOURCE,
+                    stat.MPI_TAG, MPI_COMM_WORLD, &stat)) continue;
+            // this assumes same arch on client/server
+            MPI_Unpack(pack, sz, &pos, &src_size, sizeof(src_size),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &chk_size, sizeof(chk_size),
+                MPI_BYTE, MPI_COMM_WORLD);
+
+            stt = xmalloc(sizeof(sum_task_t));
+            stt->src_name = xmalloc(src_size);
+            stt->hash_stack = xmalloc(x.hash_size);
+            MPI_Unpack(pack, sz, &pos, stt->src_name, src_size,
+                MPI_BYTE, MPI_COMM_WORLD);
+            if (chk_size) {
+                stt->hash_check = xmalloc(chk_size);
+                MPI_Unpack(pack, sz, &pos, stt->hash_check, chk_size,
+                    MPI_BYTE, MPI_COMM_WORLD);
+            } else {
+                stt->hash_check = NULL;
+            }
+            MPI_Unpack(pack, sz, &pos, stt->hash_stack, x.hash_size,
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->dst_blksize, sizeof(stt->dst_blksize),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->read_time, sizeof(stt->read_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->hash_time, sizeof(stt->hash_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->sum_time, sizeof(stt->sum_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->start_offset, sizeof(stt->start_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->stop_offset, sizeof(stt->stop_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->nsplits, sizeof(stt->nsplits),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->split, sizeof(stt->split),
+                MPI_BYTE, MPI_COMM_WORLD);
+
+            sem_q_push(&send_q, stt);
+        } else if (sz == 0) {
+            stt = null_task ? NULL : sem_q_pop(&task_q);
+            if (stt == NULL) {
+                null_task = 1;
+                sz = 0;
+                MPI_Send(&sz, 1, MPI_LONG_LONG, stat.MPI_SOURCE,
+                    stat.MPI_TAG, MPI_COMM_WORLD);
+            } else {
+                src_size = strlen(stt->src_name) + 1;
+                chk_size = stt->hash_check == NULL ?
+                    0 : strlen(stt->hash_check) + 1;
+                sz = src_size + chk_size + sizeof(sum_task_t);
+                MPI_Send(&sz, 1, MPI_LONG_LONG, stat.MPI_SOURCE,
+                    stat.MPI_TAG, MPI_COMM_WORLD);
+                // pack stt into one big byte array
+                char pack[sz];
+                // this assumes same arch on client/server
+                MPI_Pack(&src_size, sizeof(src_size),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&chk_size, sizeof(chk_size),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(stt->src_name, src_size,
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                if (chk_size)
+                    MPI_Pack(stt->hash_check, chk_size,
+                        MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&stt->dst_blksize, sizeof(stt->dst_blksize),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&stt->read_time, sizeof(stt->read_time),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&stt->hash_time, sizeof(stt->hash_time),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&stt->sum_time, sizeof(stt->sum_time),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&stt->start_offset, sizeof(stt->start_offset),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&stt->stop_offset, sizeof(stt->stop_offset),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&stt->nsplits, sizeof(stt->nsplits),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&stt->split, sizeof(stt->split),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+
+                MPI_Send(pack, pos, MPI_PACKED, stat.MPI_SOURCE, stat.MPI_TAG,
+                    MPI_COMM_WORLD);
+                free(stt->src_name);
+                free(stt->hash_check);
+                free(stt->hash_stack);
+                free(stt);
+            }
+        } else {
+            // main and hash/stat done message to prevent deadlock
+            mpi_recv++;
+        }
+    }
+# endif
+  } else if (tid != 0) {
+    //////////////////////////////
+    // sum handler on all nodes //
+    //////////////////////////////
+    // indicate ready for request on other nodes
+    if (x.mgr_port || pid != 0) sem_q_push(&send_q, NULL);
+    sum_task_t *stt;
+    while ((stt = sem_q_pop(&task_q)) != NULL) {
+      struct timespec ts[2];
+      if (x.print_stats) clock_gettime(0, &ts[0]);
+      oks[tid] &= sum_task(stt, &x);
+      if (x.print_stats) {
+        clock_gettime(0, &ts[1]);
+        stt->sum_time = (double) (
+          (double) ts[1].tv_sec + (double) ts[1].tv_nsec / (double) 1.0e9 -
+          (double) ts[0].tv_sec - (double) ts[0].tv_nsec / (double) 1.0e9);
+      }
+      sem_q_push(&send_q, stt);
+      // indicate ready for request on other nodes
+      if (x.mgr_port || pid != 0) sem_q_push(&send_q, NULL);
+    }
+  } else {
+#endif
+// < PZK
 
   for (; optind < argc; ++optind)
     {
       char *file = argv[optind];
-
+// PZK >
+      if (x.read_stdin) {
+        char *buf = NULL;
+        size_t buf_max = 0;
+
+        while (getline(&buf, &buf_max, stdin) > 0) {
+            buf[strcspn(buf, "\n")] = '\0';
+            size_t irange = strcspn(buf, " ");
+            if (buf[irange] == '\0') irange = 0;
+            else buf[irange++] = '\0';
+            file = unescape(buf, 0);
+            if (file == NULL) {
+                //TODO: error handling if can't unescape
+                continue;
+            }
+            int file_is_binary = binary;
+            if (irange > 0) {
+                off_t x1, x2;
+                while (sscanf(&buf[irange], "%lld-%lld", &x1, &x2) == 2) {
+                    x.offset = x1;
+                    x.length = x2 - x1;
+                    if (! digest_file (&x, NULL, file, &file_is_binary,
+                            bin_buffer)) ok = false;
+                    irange += strcspn(&buf[irange], ",");
+                    if (buf[irange] == ',') irange++;
+                }
+            } else {
+                x.offset = 0;
+                x.length = -1;
+                if (! digest_file (&x, NULL, file, &file_is_binary, bin_buffer))
+                    ok = false;
+            }
+        }
+        free(buf);
+        break;
+      }
+// < PZK
       if (do_check)
-        ok &= digest_check (file);
+// PZK >
+        ok &= digest_check (&x, file);
+// < PZK
       else
         {
           int file_is_binary = binary;
 
-          if (! digest_file (file, &file_is_binary, bin_buffer))
+// PZK >
+          if (! digest_file (&x, NULL, file, &file_is_binary, bin_buffer))
+// < PZK
             ok = false;
           else
             {
+// PZK >
+#ifdef _OPENMP
+              if (!STREQ (file, "-")) continue;
+#endif
+// < PZK
               /* We don't really need to escape, and hence detect, the '\\'
                  char, and not doing so should be both forwards and backwards
                  compatible, since only escaped lines would have a '\\' char at
@@ -870,6 +2678,40 @@ main (int argc, char **argv)
             }
         }
     }
+// PZK >
+#ifdef _OPENMP
+    // indicate that main thread is done traversing file system
+    main_done = 1;
+    // send terminating NULL task to stat/hash thread
+    sem_q_push(&send_q, NULL);
+    // send terminating NULL task to all worker threads
+    for (int i = 0; i < x.threads - 1; i++)
+        sem_q_push(&task_q, NULL);
+# if HAVE_LIBMPI
+    if (x.mpi) {
+        // send message to MPI handler on main node to break out of
+        // a final receive called just before main_done is set
+        long long sz = -1;
+        MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+    }
+# endif
+  }
+}
+
+# if HAVE_LIBMPI
+  if (x.mpi) MPI_Finalize();
+# endif
+
+  // destroy all queues
+  sem_q_destroy(&send_q);
+  sem_q_destroy(&task_q);
+
+  //TODO: this no longer works with mpi/tcp
+  // reduce oks array to single value
+  for (int i = 0; i < x.threads; i++)
+    ok &= oks[i];
+#endif
+// < PZK
 
   if (have_read_stdin && fclose (stdin) == EOF)
     error (EXIT_FAILURE, errno, _("standard input"));
diff -rupN orig/src/mutil-q.h new/src/mutil-q.h
--- orig/src/mutil-q.h	1969-12-31 16:00:00.000000000 -0800
+++ new/src/mutil-q.h	2018-01-18 14:44:17.931923912 -0800
@@ -0,0 +1,109 @@
+// PZK >
+/* mutil-q.h -- semaphore-protected queues
+
+   Copyright 2010 United States Government National Aeronautics and
+   Space Administration (NASA).  No copyright is claimed in the United
+   States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License Version 3 with
+   Additional Terms below (per Section 7 of GPL V3).
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Paul Kolano.  */
+
+/* Additional Terms per Section 7 of GNU General Public License Version 3
+
+1.  DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION
+
+    No Warranty: NASA PROVIDES THE COVERED WORKS "AS IS" WITHOUT ANY
+    WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
+    INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE COVERED WORKS
+    WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
+    INFRINGEMENT, ANY WARRANTY THAT THE COVERED WORKS WILL BE ERROR
+    FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
+    TO THE COVERED WORKS. THIS AGREEMENT DOES NOT, IN ANY MANNER,
+    CONSTITUTE AN ENDORSEMENT BY NASA OR ANY OTHER RECIPIENT OF ANY
+    RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER
+    APPLICATIONS RESULTING FROM USE OF THE COVERED WORKS.  FURTHER, NASA
+    DISCLAIMS ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY
+    SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT
+    "AS IS."
+
+    Waiver and Indemnity: YOU AGREE TO WAIVE ANY AND ALL CLAIMS
+    AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
+    SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT.  IF YOUR USE OF THE
+    COVERED WORKS RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES
+    OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM PRODUCTS
+    BASED ON, OR RESULTING FROM, YOUR USE OF THE COVERED WORKS, YOU
+    SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS
+    CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT, TO
+    THE EXTENT PERMITTED BY LAW.  YOUR SOLE REMEDY FOR ANY SUCH MATTER
+    SHALL BE THE IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
+
+2.  You must ensure that the following copyright notice appears
+    prominently in the covered works:
+
+        Copyright 2010 United States Government National Aeronautics and
+        Space Administration (NASA).  No copyright is claimed in the United
+        States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+3.  You must characterize Your alteration of the covered works as a
+    Modification or Contribution and must identify Yourself as the
+    originator of Your Modification or Contribution in a manner that
+    reasonably allows subsequent Recipients to identify the originator
+    of the Modification or Contribution.  In fulfillment of these
+    requirements, You must include a file (e.g., a change log file) that
+    describes the alterations made and the date of the alterations,
+    identifies You as originator of the alterations, and consents to
+    characterization of the alterations as a Modification or
+    Contribution, for example, by including a statement that the
+    Modification or Contribution is derived, directly or indirectly,
+    from covered work provided by NASA. Once consent is granted, it may
+    not thereafter be revoked.
+
+4.  You may not make any representation in the covered works or in any
+    promotional, advertising or other material that may be construed as
+    an endorsement by NASA or by any other Recipient of any product or
+    service provided by You, or that may seek to obtain commercial
+    advantage of NASA's or any other Recipient's participation in this
+    License.
+*/
+
+#ifndef MUTIL_Q_H
+# define MUTIL_Q_H
+
+# include <sys/types.h>
+# include <sys/ipc.h>
+# include <sys/sem.h>
+
+/////////////////////////
+//// Semaphore Queue ////
+/////////////////////////
+
+typedef struct {
+    int sem_id;
+    int size;
+    size_t ptr_size;
+    int i_read;
+    int i_write;
+    void **vals;
+} sem_q_t;
+
+void sem_q_init(sem_q_t *q, int size, size_t ptr_size);
+void sem_q_destroy(sem_q_t *q);
+void sem_q_push(sem_q_t *q, void *val);
+void *sem_q_pop(sem_q_t *q);
+int sem_q_size(sem_q_t *q);
+
+#endif
+// < PZK
+
diff -rupN orig/src/mutil.c new/src/mutil.c
--- orig/src/mutil.c	1969-12-31 16:00:00.000000000 -0800
+++ new/src/mutil.c	2018-01-18 14:44:17.931923912 -0800
@@ -0,0 +1,492 @@
+// PZK >
+/* mutil.c -- core functions for copying/hashing files
+
+   Copyright 2010 United States Government National Aeronautics and
+   Space Administration (NASA).  No copyright is claimed in the United
+   States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License Version 3 with
+   Additional Terms below (per Section 7 of GPL V3).
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Paul Kolano.  */
+
+/* Additional Terms per Section 7 of GNU General Public License Version 3
+
+1.  DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION
+
+    No Warranty: NASA PROVIDES THE COVERED WORKS "AS IS" WITHOUT ANY
+    WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
+    INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE COVERED WORKS
+    WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
+    INFRINGEMENT, ANY WARRANTY THAT THE COVERED WORKS WILL BE ERROR
+    FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
+    TO THE COVERED WORKS. THIS AGREEMENT DOES NOT, IN ANY MANNER,
+    CONSTITUTE AN ENDORSEMENT BY NASA OR ANY OTHER RECIPIENT OF ANY
+    RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER
+    APPLICATIONS RESULTING FROM USE OF THE COVERED WORKS.  FURTHER, NASA
+    DISCLAIMS ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY
+    SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT
+    "AS IS."
+
+    Waiver and Indemnity: YOU AGREE TO WAIVE ANY AND ALL CLAIMS
+    AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
+    SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT.  IF YOUR USE OF THE
+    COVERED WORKS RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES
+    OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM PRODUCTS
+    BASED ON, OR RESULTING FROM, YOUR USE OF THE COVERED WORKS, YOU
+    SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS
+    CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT, TO
+    THE EXTENT PERMITTED BY LAW.  YOUR SOLE REMEDY FOR ANY SUCH MATTER
+    SHALL BE THE IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
+
+2.  You must ensure that the following copyright notice appears
+    prominently in the covered works:
+
+        Copyright 2010 United States Government National Aeronautics and
+        Space Administration (NASA).  No copyright is claimed in the United
+        States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+3.  You must characterize Your alteration of the covered works as a
+    Modification or Contribution and must identify Yourself as the
+    originator of Your Modification or Contribution in a manner that
+    reasonably allows subsequent Recipients to identify the originator
+    of the Modification or Contribution.  In fulfillment of these
+    requirements, You must include a file (e.g., a change log file) that
+    describes the alterations made and the date of the alterations,
+    identifies You as originator of the alterations, and consents to
+    characterization of the alterations as a Modification or
+    Contribution, for example, by including a statement that the
+    Modification or Contribution is derived, directly or indirectly,
+    from covered work provided by NASA. Once consent is granted, it may
+    not thereafter be revoked.
+
+4.  You may not make any representation in the covered works or in any
+    promotional, advertising or other material that may be construed as
+    an endorsement by NASA or by any other Recipient of any product or
+    service provided by You, or that may seek to obtain commercial
+    advantage of NASA's or any other Recipient's participation in this
+    License.
+*/
+
+#include "mutil.h"
+
+#ifndef CLOCK_REALTIME
+int clock_gettime(int clk_id, struct timespec* t) {
+    struct timeval now;
+    int rv = gettimeofday(&now, NULL);
+    if (rv) return rv;
+    t->tv_sec  = now.tv_sec;
+    t->tv_nsec = now.tv_usec * 1000;
+    return 0;
+}
+#endif
+
+///////////////////
+//// Hash Tree ////
+///////////////////
+
+#if HAVE_LIBGCRYPT
+# include <gcrypt.h>
+# include "copy.h"
+
+void hash_tree(hash_tree_t *htt, copy_reg_t *crt, struct cp_options *co,
+        const char *buf, off_t total_n_read)
+{
+    off_t n_hash = 0;
+    while (htt->total_n_hash + co->hash_leaf_size <= total_n_read) {
+        hash_leaf(htt, crt, co, &buf[n_hash],
+            co->hash_leaf_size - htt->hash_ctx_len);
+        n_hash += co->hash_leaf_size - htt->hash_ctx_len;
+        htt->hash_ctx_len = 0;
+        htt->total_n_hash += co->hash_leaf_size;
+    }
+    if (total_n_read >= crt->stop_offset - crt->start_offset) {
+        // last iteration
+        if (total_n_read > htt->total_n_hash)
+            hash_leaf(htt, crt, co, &buf[n_hash],
+                total_n_read - htt->total_n_hash - htt->hash_ctx_len);
+    } else {
+        // store in hash context for next iteration
+        if (total_n_read - htt->total_n_hash > 0)
+            gcry_md_write(*htt->hash_ctx, &buf[n_hash],
+                total_n_read - htt->total_n_hash - htt->hash_ctx_len);
+        htt->hash_ctx_len = total_n_read - htt->total_n_hash;
+    }
+}
+
+void hash_final(hash_tree_t *htt, copy_reg_t *crt, struct cp_options *co,
+        size_t start, size_t end)
+{
+    if (start + 1 >= end) return;
+
+    // find nearest power of 2 less than (end - start)
+    size_t n = 1;
+    size_t leafs = end - start;
+    while (n < leafs) n <<= 1;
+    n >>= 1;
+
+    // compute hash of left and right subtrees
+    gcry_md_hd_t ctx;
+    gcry_md_open(&ctx, co->hash_type, 0);
+    hash_final(htt, crt, co, start, start + n);
+    gcry_md_write(ctx, &crt->hash_stack[start * co->hash_size], co->hash_size);
+    if (end > start + n) {
+        hash_final(htt, crt, co, start + n, end);
+        gcry_md_write(ctx, &crt->hash_stack[(start + n) * co->hash_size],
+            co->hash_size);
+    }
+    unsigned char *hash = gcry_md_read(ctx, 0);
+    memcpy(&crt->hash_stack[start * co->hash_size], hash, co->hash_size);
+    gcry_md_close(ctx);
+}
+
+void hash_leaf(hash_tree_t *htt, copy_reg_t *crt, struct cp_options *co,
+        const char *buf, ssize_t buf_len)
+{
+    if (htt->hash_ctx_len + buf_len > 0 || htt->total_n_hash == 0) {
+        // something to hash or zero-length file
+
+        // compute hash of block [start, end)
+        if (buf_len > 0) gcry_md_write(*htt->hash_ctx, buf, buf_len);
+        unsigned char *hash = gcry_md_read(*htt->hash_ctx, 0);
+
+        // store hash on stack
+        memcpy(&htt->stack[htt->stack_len], hash, co->hash_size);
+        htt->stack_len += co->hash_size;
+    }
+
+    off_t total = htt->total_n_hash + htt->hash_ctx_len + buf_len;
+    off_t total_pow2 = total;
+
+    // for final partial leaf node, compute hash subtree as if it were full
+    if (htt->hash_ctx_len + buf_len < co->hash_leaf_size) {
+        off_t n = 1;
+        double leafs = total / (double) co->hash_leaf_size;
+        while (n < leafs) n <<= 1;
+        total_pow2 = n * co->hash_leaf_size;
+    }
+
+    // compute hash subtree from bottom up
+    ssize_t i = 1;
+    while (htt->stack_len >= 2 * co->hash_size && total_pow2 != 0 &&
+            total_pow2 / (i * co->hash_leaf_size) % 2 == 0) {
+        if (total_pow2 - i * co->hash_leaf_size < total) {
+            // compute hash of last two hashes on stack
+            gcry_md_reset(*htt->hash_ctx);
+            gcry_md_write(*htt->hash_ctx,&htt->stack[htt->stack_len - 2 * co->hash_size],
+                co->hash_size);
+            gcry_md_write(*htt->hash_ctx, &htt->stack[htt->stack_len - co->hash_size],
+                co->hash_size);
+            htt->stack_len -= 2 * co->hash_size;
+            unsigned char *hash = gcry_md_read(*htt->hash_ctx, 0);
+
+            // store hash on stack
+            memcpy(&htt->stack[htt->stack_len], hash, co->hash_size);
+            htt->stack_len += co->hash_size;
+        }
+        i *= 2;
+    }
+    gcry_md_reset(*htt->hash_ctx);
+}
+
+#endif
+
+
+/////////////////////////
+//// Semaphore Queue ////
+/////////////////////////
+
+void sem_q_init(sem_q_t *q, int size, size_t ptr_size) {
+    q->sem_id = semget(0, 3, IPC_PRIVATE | IPC_CREAT | 0600);
+
+    // max_sem
+    semctl(q->sem_id, 0, SETVAL, size);
+
+    // min_sem
+    semctl(q->sem_id, 1, SETVAL, 0);
+
+    // q_lock
+    semctl(q->sem_id, 2, SETVAL, 1);
+
+    q->i_read = 0;
+    q->i_write = 0;
+    q->size = size;
+    q->ptr_size = ptr_size;
+    q->vals = (void **) calloc(size, ptr_size);
+}
+
+void sem_q_destroy(sem_q_t *q) {
+    free(q->vals);
+    semctl(q->sem_id, 0, IPC_RMID);
+}
+
+void sem_q_push(sem_q_t *q, void *val) {
+    struct sembuf sb;
+    sb.sem_flg = 0;
+
+    // wait max_sem
+    sb.sem_num = 0;
+    sb.sem_op = -1;
+    semop(q->sem_id, &sb, 1);
+
+    // wait q_lock
+    sb.sem_num = 2;
+    semop(q->sem_id, &sb, 1);
+
+    q->vals[q->i_write] = val;
+    q->i_write = (q->i_write + 1) % q->size;
+
+    // post q_lock
+    sb.sem_op = 1;
+    semop(q->sem_id, &sb, 1);
+
+    // post min_sem
+    sb.sem_num = 1;
+    semop(q->sem_id, &sb, 1);
+}
+
+void *sem_q_pop(sem_q_t *q) {
+    struct sembuf sb;
+    sb.sem_flg = 0;
+
+    // wait min_sem
+    sb.sem_num = 1;
+    sb.sem_op = -1;
+    semop(q->sem_id, &sb, 1);
+
+    // wait q_lock
+    sb.sem_num = 2;
+    semop(q->sem_id, &sb, 1);
+
+    void *val = q->vals[q->i_read];
+    q->i_read = (q->i_read + 1) % q->size;
+
+    // post q_lock
+    sb.sem_op = 1;
+    semop(q->sem_id, &sb, 1);
+
+    // post max_sem
+    sb.sem_num = 0;
+    semop(q->sem_id, &sb, 1);
+
+    return val;
+}
+
+int sem_q_size(sem_q_t *q) {
+    return (q->size + q->i_write - q->i_read) % q->size;
+}
+
+
+////////////////////////////////
+//// Secure Remote Password ////
+////////////////////////////////
+
+#if HAVE_LIBGNUTLS
+
+/* Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 Simon Josefsson
+ * Copyright (C) 2001,2003 Nikos Mavrogiannopoulos
+ * Copyright (C) 2004 Free Software Foundation
+ *
+ * Modified version of GNUTLS crypt.c distributed under GPLv3.
+ */
+ 
+# include <gcrypt.h>
+# include <pwd.h>
+# include <gnutls/gnutls.h>
+# include <unistd.h>
+
+static int generate_create_conf(char *tpasswd_conf) {
+    FILE *fd;
+    char line[5 * 1024];
+    int index = 1;
+    gnutls_datum_t g, n;
+    gnutls_datum_t str_g, str_n;
+
+    fd = fopen(tpasswd_conf, "w");
+    if (fd == NULL) return -1;
+
+    for (index = 1; index <= 3; index++) {
+        if (index == 1) {
+            n = gnutls_srp_1024_group_prime;
+            g = gnutls_srp_1024_group_generator;
+        } else if (index == 2) {
+            n = gnutls_srp_1536_group_prime;
+            g = gnutls_srp_1536_group_generator;
+        } else {
+            n = gnutls_srp_2048_group_prime;
+            g = gnutls_srp_2048_group_generator;
+        }
+
+        if (gnutls_srp_base64_encode_alloc(&n, &str_n) < 0) return -1;
+        if (gnutls_srp_base64_encode_alloc(&g, &str_g) < 0) return -1;
+
+        sprintf(line, "%d:%s:%s\n", index, str_n.data, str_g.data);
+
+        gnutls_free(str_n.data);
+        gnutls_free(str_g.data);
+
+        fwrite(line, 1, strlen(line), fd);
+    }
+
+    fclose(fd);
+
+    return 0;
+}
+
+/* this function parses tpasswd.conf file. Format is:
+ * int(index):base64(n):base64(g)
+ */
+static int read_conf_values(gnutls_datum_t * g, gnutls_datum_t * n, char *str) {
+    char *p;
+    int len;
+    int index, ret;
+    gnutls_datum_t dat;
+
+    index = atoi(str);
+
+    p = strrchr(str, ':');   /* we have g */
+    if (p == NULL) return -1;
+
+    *p = '\0';
+    p++;
+
+    /* read the generator */
+    len = strlen(p);
+    if (p[len - 1] == '\n') len--;
+
+    dat.data = p;
+    dat.size = len;
+    ret = gnutls_srp_base64_decode_alloc (&dat, g);
+
+    if (ret < 0) return -1;
+
+    /* now go for n - modulo */
+    p = strrchr(str, ':');   /* we have n */
+    if (p == NULL) return -1;
+
+    *p = '\0';
+    p++;
+
+    dat.data = p;
+    dat.size = strlen(p);
+
+    ret = gnutls_srp_base64_decode_alloc(&dat, n);
+
+    if (ret < 0) {
+        free(g->data);
+        return -1;
+    }
+
+    return index;
+}
+
+static char *_srp_crypt (const char *username, const char *passwd,
+        int salt_size, const gnutls_datum_t * g, const gnutls_datum_t * n) {
+    char salt[128];
+    static char result[1024];
+    gnutls_datum_t dat_salt, txt_salt;
+    gnutls_datum_t verifier, txt_verifier;
+
+    if ((unsigned) salt_size > sizeof(salt)) return NULL;
+
+    /* generate the salt */
+    gcry_create_nonce(salt, salt_size);
+
+    dat_salt.data = salt;
+    dat_salt.size = salt_size;
+
+    if (gnutls_srp_verifier(username, passwd, &dat_salt, g, n, &verifier) < 0)
+        return NULL;
+
+    /* base64 encode the verifier */
+    if (gnutls_srp_base64_encode_alloc(&verifier, &txt_verifier) < 0) {
+        free(verifier.data);
+        return NULL;
+    }
+
+    free (verifier.data);
+
+    if (gnutls_srp_base64_encode_alloc(&dat_salt, &txt_salt) < 0) return NULL;
+
+    sprintf(result, "%s:%s", txt_verifier.data, txt_salt.data);
+    free(txt_salt.data);
+    free(txt_verifier.data);
+
+    return result;
+}
+
+static int crypt_int (const char *username, const char *passwd, int salt_size,
+        char *tpasswd_conf, char *tpasswd, int uindex) {
+    FILE *fd;
+    char *cr;
+    gnutls_datum_t g, n;
+    char line[5 * 1024];
+    char *p, *pp;
+    int iindex;
+
+    fd = fopen(tpasswd_conf, "r");
+    if (fd == NULL) return -1;
+
+    /* find the specified uindex in file */
+    do {
+        p = fgets (line, sizeof (line) - 1, fd);
+        iindex = atoi(p);
+    } while (p != NULL && iindex != uindex);
+
+    if (p == NULL) return -1;
+    line[sizeof(line) - 1] = 0;
+
+    fclose (fd);
+    if ((iindex = read_conf_values(&g, &n, line)) < 0) return -1;
+
+    cr = _srp_crypt(username, passwd, salt_size, &g, &n);
+    if (cr == NULL) {
+        return -1;
+    } else {
+        /* delete previous entry */
+        struct stat st;
+        int put;
+
+        fd = fopen(tpasswd, "w");
+        if (fd == NULL) return -1;
+
+        fprintf(fd, "%s:%s:%u\n", username, cr, iindex);
+
+        fclose(fd);
+    }
+
+    return 0;
+}
+
+int srp_generate_auth(char *client_pw_file, char *pw_file, char *mg_file) {
+    mode_t umask_save = umask(077);
+    if (generate_create_conf(mg_file) < 0) return -1;
+    struct passwd *pw = getpwuid(getuid());
+    if (pw == NULL) return -1;
+    char *upass = gcry_random_bytes_secure(16, GCRY_STRONG_RANDOM);
+    if (upass == NULL) return -1;
+    // ensure printable ascii
+    for (int i = 0; i < 16; i++)
+      upass[i] = (upass[i] + 128) % 95 + 32;
+    if (crypt_int(pw->pw_name, upass, 16, mg_file, pw_file, 1) < 0)
+        return -1;
+    FILE *f = fopen(client_pw_file, "w");
+    if (f == NULL) return -1;
+    if (fwrite(upass, 16, 1, f) < 1) return -1;
+    fclose(f);
+    gcry_free(upass);
+    umask(umask_save);
+}
+ 
+#endif
+// < PZK
diff -rupN orig/src/mutil.h new/src/mutil.h
--- orig/src/mutil.h	1969-12-31 16:00:00.000000000 -0800
+++ new/src/mutil.h	2018-01-18 14:44:17.927923805 -0800
@@ -0,0 +1,135 @@
+// PZK >
+/* mutil.h -- core functions for copying/hashing files
+
+   Copyright 2010 United States Government National Aeronautics and
+   Space Administration (NASA).  No copyright is claimed in the United
+   States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License Version 3 with
+   Additional Terms below (per Section 7 of GPL V3).
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Paul Kolano.  */
+
+/* Additional Terms per Section 7 of GNU General Public License Version 3
+
+1.  DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION
+
+    No Warranty: NASA PROVIDES THE COVERED WORKS "AS IS" WITHOUT ANY
+    WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
+    INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE COVERED WORKS
+    WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
+    INFRINGEMENT, ANY WARRANTY THAT THE COVERED WORKS WILL BE ERROR
+    FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
+    TO THE COVERED WORKS. THIS AGREEMENT DOES NOT, IN ANY MANNER,
+    CONSTITUTE AN ENDORSEMENT BY NASA OR ANY OTHER RECIPIENT OF ANY
+    RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER
+    APPLICATIONS RESULTING FROM USE OF THE COVERED WORKS.  FURTHER, NASA
+    DISCLAIMS ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY
+    SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT
+    "AS IS."
+
+    Waiver and Indemnity: YOU AGREE TO WAIVE ANY AND ALL CLAIMS
+    AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
+    SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT.  IF YOUR USE OF THE
+    COVERED WORKS RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES
+    OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM PRODUCTS
+    BASED ON, OR RESULTING FROM, YOUR USE OF THE COVERED WORKS, YOU
+    SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS
+    CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT, TO
+    THE EXTENT PERMITTED BY LAW.  YOUR SOLE REMEDY FOR ANY SUCH MATTER
+    SHALL BE THE IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
+
+2.  You must ensure that the following copyright notice appears
+    prominently in the covered works:
+
+        Copyright 2010 United States Government National Aeronautics and
+        Space Administration (NASA).  No copyright is claimed in the United
+        States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+3.  You must characterize Your alteration of the covered works as a
+    Modification or Contribution and must identify Yourself as the
+    originator of Your Modification or Contribution in a manner that
+    reasonably allows subsequent Recipients to identify the originator
+    of the Modification or Contribution.  In fulfillment of these
+    requirements, You must include a file (e.g., a change log file) that
+    describes the alterations made and the date of the alterations,
+    identifies You as originator of the alterations, and consents to
+    characterization of the alterations as a Modification or
+    Contribution, for example, by including a statement that the
+    Modification or Contribution is derived, directly or indirectly,
+    from covered work provided by NASA. Once consent is granted, it may
+    not thereafter be revoked.
+
+4.  You may not make any representation in the covered works or in any
+    promotional, advertising or other material that may be construed as
+    an endorsement by NASA or by any other Recipient of any product or
+    service provided by You, or that may seek to obtain commercial
+    advantage of NASA's or any other Recipient's participation in this
+    License.
+*/
+
+#ifndef MUTIL_H
+# define MUTIL_H
+
+# include <config.h>
+
+# ifdef _OPENMP
+#  include <omp.h>
+# endif
+
+# include "copy.h"
+# include "mutil-q.h"
+
+#ifndef CLOCK_REALTIME
+# include <sys/time.h>
+int clock_gettime(int clk_id, struct timespec* t);
+#endif
+
+///////////////////
+//// Hash Tree ////
+///////////////////
+
+# if HAVE_LIBGCRYPT
+#  include <gcrypt.h>
+
+typedef struct {
+    off_t total_n_hash;
+    gcry_md_hd_t *hash_ctx;
+    size_t hash_ctx_len;
+    char *stack;
+    size_t stack_len;
+} hash_tree_t;
+
+void hash_final(hash_tree_t *htt, copy_reg_t *crt, struct cp_options *co,
+        size_t start, size_t end);
+void hash_leaf(hash_tree_t *htt, copy_reg_t *crt, struct cp_options *co,
+    const char *buf, ssize_t buf_len);
+void hash_tree(hash_tree_t *htt, copy_reg_t *crt, struct cp_options *co,
+    const char *buf, off_t total_n_read);
+
+# endif
+
+
+////////////////////////////////
+//// Secure Remote Password ////
+////////////////////////////////
+
+# if HAVE_LIBGNUTLS
+
+int srp_generate_auth(char *client_pw_file, char *pw_file, char *mg_file);
+
+# endif
+
+#endif
+// < PZK
+
diff -rupN orig/tests/cp/backup-is-src.sh new/tests/cp/backup-is-src.sh
--- orig/tests/cp/backup-is-src.sh	2013-12-04 06:48:30.000000000 -0800
+++ new/tests/cp/backup-is-src.sh	2018-01-18 14:44:20.055981159 -0800
@@ -23,7 +23,9 @@ echo a > a || framework_failure_
 echo a-tilde > a~ || framework_failure_
 
 # This cp command should exit nonzero.
-cp --b=simple a~ a > out 2>&1 && fail=1
+# PZK >
+cp --backup=simple a~ a > out 2>&1 && fail=1
+# < PZK
 
 sed "s,cp:,XXX:," out > out2
 
